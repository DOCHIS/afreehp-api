/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/shepherd/shepherd.js":
/*!***********************************!*\
  !*** ./libs/shepherd/shepherd.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shepherd: function() { return /* reexport default from dynamic */ shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL3NoZXBoZXJkL3NoZXBoZXJkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRCIsInNvdXJjZXMiOlsid2VicGFjazovL1NuZWF0Ly4vbGlicy9zaGVwaGVyZC9zaGVwaGVyZC5qcz83YTgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTaGVwaGVyZCBmcm9tICdzaGVwaGVyZC5qcy9kaXN0L2pzL3NoZXBoZXJkJztcblxuZXhwb3J0IHsgU2hlcGhlcmQgfTtcbiJdLCJuYW1lcyI6WyJTaGVwaGVyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/shepherd/shepherd.js\n");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*! shepherd.js 11.1.1 */\n\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  var isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n  };\n  function isNonNullObject(value) {\n    return !!value && _typeof(value) === 'object';\n  }\n  function isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n  }\n\n  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n  function isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n  }\n  function emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n  }\n  function cloneUnlessOtherwiseSpecified(value, options) {\n    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n  }\n  function defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n      return cloneUnlessOtherwiseSpecified(element, options);\n    });\n  }\n  function getMergeFunction(key, options) {\n    if (!options.customMerge) {\n      return deepmerge;\n    }\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepmerge;\n  }\n  function getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n      return Object.propertyIsEnumerable.call(target, symbol);\n    }) : [];\n  }\n  function getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n  }\n  function propertyIsOnObject(object, property) {\n    try {\n      return property in object;\n    } catch (_) {\n      return false;\n    }\n  }\n\n  // Protects from prototype poisoning and unexpected merging up the prototype chain.\n  function propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n  }\n\n  function mergeObject(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n      getKeys(target).forEach(function (key) {\n        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n      });\n    }\n    getKeys(source).forEach(function (key) {\n      if (propertyIsUnsafe(target, key)) {\n        return;\n      }\n      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n      } else {\n        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n      }\n    });\n    return destination;\n  }\n  function deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject;\n    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n      return cloneUnlessOtherwiseSpecified(source, options);\n    } else if (sourceIsArray) {\n      return options.arrayMerge(target, source, options);\n    } else {\n      return mergeObject(target, source, options);\n    }\n  }\n  deepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n      throw new Error('first argument should be an array');\n    }\n    return array.reduce(function (prev, next) {\n      return deepmerge(prev, next, options);\n    }, {});\n  };\n  var deepmerge_1 = deepmerge;\n  var cjs = deepmerge_1;\n\n  /**\n   * Checks if `value` is classified as an `Element`.\n   * @param {*} value The param to check if it is an Element\n   */\n  function isElement$1(value) {\n    return value instanceof Element;\n  }\n\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n  function isHTMLElement$1(value) {\n    return value instanceof HTMLElement;\n  }\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n  function isString(value) {\n    return typeof value === 'string';\n  }\n\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n  function isUndefined(value) {\n    return value === undefined;\n  }\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx, once) {\n        if (once === void 0) {\n          once = false;\n        }\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        return this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return this;\n        }\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n              handler = binding.handler,\n              once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }]);\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n    return self;\n  }\n\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref2 = step.options.advanceOn || {},\n      event = _ref2.event,\n      selector = _ref2.selector;\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step);\n\n      // TODO: this should also bind/unbind on show/hide\n      var el;\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {\n        // TODO\n      }\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \".concat(selector));\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n    return prefix.charAt(prefix.length - 1) !== '-' ? \"\".concat(prefix, \"-\") : prefix;\n  }\n\n  /**\n   * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n   * @param {Step} step The step instance\n   * @returns {{}|{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n    if (isFunction(returnOpts.element)) {\n      // Bind the callback to step so that it has access to the object, to enable running additional logic\n      returnOpts.element = returnOpts.element.call(step);\n    }\n    if (isString(returnOpts.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(returnOpts.element);\n      } catch (e) {\n        // TODO\n      }\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n    return returnOpts;\n  }\n\n  /**\n   * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n   * alternative for the deprecated step.isCentered() method.\n   * @param resolvedAttachToOptions\n   * @returns {boolean}\n   */\n  function shouldCenterStep(resolvedAttachToOptions) {\n    if (resolvedAttachToOptions === undefined || resolvedAttachToOptions === null) {\n      return true;\n    }\n    return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n  }\n\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n    return target;\n  }\n  var _excluded2 = [\"mainAxis\", \"crossAxis\", \"fallbackPlacements\", \"fallbackStrategy\", \"fallbackAxisSideDirection\", \"flipAlignment\"],\n    _excluded4 = [\"mainAxis\", \"crossAxis\", \"limiter\"];\n  function getAlignment(placement) {\n    return placement.split('-')[1];\n  }\n  function getLengthFromAxis(axis) {\n    return axis === 'y' ? 'height' : 'width';\n  }\n  function getSide(placement) {\n    return placement.split('-')[0];\n  }\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n  }\n  function computeCoordsFromPlacement(_ref, placement, rtl) {\n    var reference = _ref.reference,\n      floating = _ref.floating;\n    var commonX = reference.x + reference.width / 2 - floating.width / 2;\n    var commonY = reference.y + reference.height / 2 - floating.height / 2;\n    var mainAxis = getMainAxisFromPlacement(placement);\n    var length = getLengthFromAxis(mainAxis);\n    var commonAlign = reference[length] / 2 - floating[length] / 2;\n    var side = getSide(placement);\n    var isVertical = mainAxis === 'x';\n    var coords;\n    switch (side) {\n      case 'top':\n        coords = {\n          x: commonX,\n          y: reference.y - floating.height\n        };\n        break;\n      case 'bottom':\n        coords = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case 'right':\n        coords = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case 'left':\n        coords = {\n          x: reference.x - floating.width,\n          y: commonY\n        };\n        break;\n      default:\n        coords = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    switch (getAlignment(placement)) {\n      case 'start':\n        coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n        break;\n      case 'end':\n        coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n        break;\n    }\n    return coords;\n  }\n\n  /**\n   * Computes the `x` and `y` coordinates that will place the floating element\n   * next to a reference element when it is given a certain positioning strategy.\n   *\n   * This export does not have any `platform` interface logic. You will need to\n   * write one for the platform you are using Floating UI with.\n   */\n  var computePosition$1 = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(reference, floating, config) {\n      var _config$placement, placement, _config$strategy, strategy, _config$middleware, middleware, platform, validMiddleware, rtl, rects, _computeCoordsFromPla, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware$i, name, fn, _yield$fn, nextX, nextY, data, reset, _computeCoordsFromPla2;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _config$placement = config.placement, placement = _config$placement === void 0 ? 'bottom' : _config$placement, _config$strategy = config.strategy, strategy = _config$strategy === void 0 ? 'absolute' : _config$strategy, _config$middleware = config.middleware, middleware = _config$middleware === void 0 ? [] : _config$middleware, platform = config.platform;\n            validMiddleware = middleware.filter(Boolean);\n            _context.next = 4;\n            return platform.isRTL == null ? void 0 : platform.isRTL(floating);\n          case 4:\n            rtl = _context.sent;\n            _context.next = 7;\n            return platform.getElementRects({\n              reference: reference,\n              floating: floating,\n              strategy: strategy\n            });\n          case 7:\n            rects = _context.sent;\n            _computeCoordsFromPla = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPla.x, y = _computeCoordsFromPla.y;\n            statefulPlacement = placement;\n            middlewareData = {};\n            resetCount = 0;\n            i = 0;\n          case 13:\n            if (!(i < validMiddleware.length)) {\n              _context.next = 46;\n              break;\n            }\n            _validMiddleware$i = validMiddleware[i], name = _validMiddleware$i.name, fn = _validMiddleware$i.fn;\n            _context.next = 17;\n            return fn({\n              x: x,\n              y: y,\n              initialPlacement: placement,\n              placement: statefulPlacement,\n              strategy: strategy,\n              middlewareData: middlewareData,\n              rects: rects,\n              platform: platform,\n              elements: {\n                reference: reference,\n                floating: floating\n              }\n            });\n          case 17:\n            _yield$fn = _context.sent;\n            nextX = _yield$fn.x;\n            nextY = _yield$fn.y;\n            data = _yield$fn.data;\n            reset = _yield$fn.reset;\n            x = nextX != null ? nextX : x;\n            y = nextY != null ? nextY : y;\n            middlewareData = _extends({}, middlewareData, _defineProperty({}, name, _extends({}, middlewareData[name], data)));\n            if (!(reset && resetCount <= 50)) {\n              _context.next = 43;\n              break;\n            }\n            resetCount++;\n            if (!(_typeof(reset) === 'object')) {\n              _context.next = 41;\n              break;\n            }\n            if (reset.placement) {\n              statefulPlacement = reset.placement;\n            }\n            if (!reset.rects) {\n              _context.next = 38;\n              break;\n            }\n            if (!(reset.rects === true)) {\n              _context.next = 36;\n              break;\n            }\n            _context.next = 33;\n            return platform.getElementRects({\n              reference: reference,\n              floating: floating,\n              strategy: strategy\n            });\n          case 33:\n            _context.t0 = _context.sent;\n            _context.next = 37;\n            break;\n          case 36:\n            _context.t0 = reset.rects;\n          case 37:\n            rects = _context.t0;\n          case 38:\n            _computeCoordsFromPla2 = computeCoordsFromPlacement(rects, statefulPlacement, rtl);\n            x = _computeCoordsFromPla2.x;\n            y = _computeCoordsFromPla2.y;\n          case 41:\n            i = -1;\n            return _context.abrupt(\"continue\", 43);\n          case 43:\n            i++;\n            _context.next = 13;\n            break;\n          case 46:\n            return _context.abrupt(\"return\", {\n              x: x,\n              y: y,\n              placement: statefulPlacement,\n              strategy: strategy,\n              middlewareData: middlewareData\n            });\n          case 47:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function computePosition$1(_x, _x2, _x3) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  function expandPaddingObject(padding) {\n    return _extends({\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }, padding);\n  }\n  function getSideObjectFromPadding(padding) {\n    return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n      top: padding,\n      right: padding,\n      bottom: padding,\n      left: padding\n    };\n  }\n  function rectToClientRect(rect) {\n    return _extends({}, rect, {\n      top: rect.y,\n      left: rect.x,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n\n  /**\n   * Resolves with an object of overflow side offsets that determine how much the\n   * element is overflowing a given clipping boundary on each side.\n   * - positive = overflowing the boundary by that number of pixels\n   * - negative = how many pixels left before it will overflow\n   * - 0 = lies flush with the boundary\n   * @see https://floating-ui.com/docs/detectOverflow\n   */\n  function detectOverflow(_x4, _x5) {\n    return _detectOverflow.apply(this, arguments);\n  }\n  function _detectOverflow() {\n    _detectOverflow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(state, options) {\n      var _await$platform$isEle, x, y, platform, rects, elements, strategy, _options5, _options5$boundary, boundary, _options5$rootBoundar, rootBoundary, _options5$elementCont, elementContext, _options5$altBoundary, altBoundary, _options5$padding, padding, paddingObject, altContext, element, clippingClientRect, rect, offsetParent, offsetScale, elementClientRect;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            if (options === void 0) {\n              options = {};\n            }\n            x = state.x, y = state.y, platform = state.platform, rects = state.rects, elements = state.elements, strategy = state.strategy;\n            _options5 = options, _options5$boundary = _options5.boundary, boundary = _options5$boundary === void 0 ? 'clippingAncestors' : _options5$boundary, _options5$rootBoundar = _options5.rootBoundary, rootBoundary = _options5$rootBoundar === void 0 ? 'viewport' : _options5$rootBoundar, _options5$elementCont = _options5.elementContext, elementContext = _options5$elementCont === void 0 ? 'floating' : _options5$elementCont, _options5$altBoundary = _options5.altBoundary, altBoundary = _options5$altBoundary === void 0 ? false : _options5$altBoundary, _options5$padding = _options5.padding, padding = _options5$padding === void 0 ? 0 : _options5$padding;\n            paddingObject = getSideObjectFromPadding(padding);\n            altContext = elementContext === 'floating' ? 'reference' : 'floating';\n            element = elements[altBoundary ? altContext : elementContext];\n            _context7.t0 = rectToClientRect;\n            _context7.t1 = platform;\n            _context7.next = 10;\n            return platform.isElement == null ? void 0 : platform.isElement(element);\n          case 10:\n            _context7.t2 = _await$platform$isEle = _context7.sent;\n            if (!(_context7.t2 != null)) {\n              _context7.next = 15;\n              break;\n            }\n            _context7.t3 = _await$platform$isEle;\n            _context7.next = 16;\n            break;\n          case 15:\n            _context7.t3 = true;\n          case 16:\n            if (!_context7.t3) {\n              _context7.next = 20;\n              break;\n            }\n            _context7.t4 = element;\n            _context7.next = 26;\n            break;\n          case 20:\n            _context7.t5 = element.contextElement;\n            if (_context7.t5) {\n              _context7.next = 25;\n              break;\n            }\n            _context7.next = 24;\n            return platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating);\n          case 24:\n            _context7.t5 = _context7.sent;\n          case 25:\n            _context7.t4 = _context7.t5;\n          case 26:\n            _context7.t6 = _context7.t4;\n            _context7.t7 = boundary;\n            _context7.t8 = rootBoundary;\n            _context7.t9 = strategy;\n            _context7.t10 = {\n              element: _context7.t6,\n              boundary: _context7.t7,\n              rootBoundary: _context7.t8,\n              strategy: _context7.t9\n            };\n            _context7.next = 33;\n            return _context7.t1.getClippingRect.call(_context7.t1, _context7.t10);\n          case 33:\n            _context7.t11 = _context7.sent;\n            clippingClientRect = (0, _context7.t0)(_context7.t11);\n            rect = elementContext === 'floating' ? _extends({}, rects.floating, {\n              x: x,\n              y: y\n            }) : rects.reference;\n            _context7.next = 38;\n            return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating);\n          case 38:\n            offsetParent = _context7.sent;\n            _context7.next = 41;\n            return platform.isElement == null ? void 0 : platform.isElement(offsetParent);\n          case 41:\n            if (!_context7.sent) {\n              _context7.next = 50;\n              break;\n            }\n            _context7.next = 44;\n            return platform.getScale == null ? void 0 : platform.getScale(offsetParent);\n          case 44:\n            _context7.t13 = _context7.sent;\n            if (_context7.t13) {\n              _context7.next = 47;\n              break;\n            }\n            _context7.t13 = {\n              x: 1,\n              y: 1\n            };\n          case 47:\n            _context7.t12 = _context7.t13;\n            _context7.next = 51;\n            break;\n          case 50:\n            _context7.t12 = {\n              x: 1,\n              y: 1\n            };\n          case 51:\n            offsetScale = _context7.t12;\n            _context7.t14 = rectToClientRect;\n            if (!platform.convertOffsetParentRelativeRectToViewportRelativeRect) {\n              _context7.next = 59;\n              break;\n            }\n            _context7.next = 56;\n            return platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n              rect: rect,\n              offsetParent: offsetParent,\n              strategy: strategy\n            });\n          case 56:\n            _context7.t15 = _context7.sent;\n            _context7.next = 60;\n            break;\n          case 59:\n            _context7.t15 = rect;\n          case 60:\n            _context7.t16 = _context7.t15;\n            elementClientRect = (0, _context7.t14)(_context7.t16);\n            return _context7.abrupt(\"return\", {\n              top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n              bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n              left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n              right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n            });\n          case 63:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }));\n    return _detectOverflow.apply(this, arguments);\n  }\n  var min$1 = Math.min;\n  var max$1 = Math.max;\n  function within(min$1$1, value, max$1$1) {\n    return max$1(min$1$1, min$1(value, max$1$1));\n  }\n\n  /**\n   * Provides data to position an inner element of the floating element so that it\n   * appears centered to the reference element.\n   * @see https://floating-ui.com/docs/arrow\n   */\n  var arrow = function arrow(options) {\n    return {\n      name: 'arrow',\n      options: options,\n      fn: function fn(state) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var _data, _ref5;\n          var _ref4, element, _ref4$padding, padding, x, y, placement, rects, platform, elements, paddingObject, coords, axis, length, arrowDimensions, isYAxis, minProp, maxProp, clientProp, endDiff, startDiff, arrowOffsetParent, clientSize, centerToReference, min, max, center, offset, shouldAddOffset, alignmentOffset;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                // Since `element` is required, we don't Partial<> the type.\n                _ref4 = options || {}, element = _ref4.element, _ref4$padding = _ref4.padding, padding = _ref4$padding === void 0 ? 0 : _ref4$padding;\n                x = state.x, y = state.y, placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements;\n                if (!(element == null)) {\n                  _context2.next = 4;\n                  break;\n                }\n                return _context2.abrupt(\"return\", {});\n              case 4:\n                paddingObject = getSideObjectFromPadding(padding);\n                coords = {\n                  x: x,\n                  y: y\n                };\n                axis = getMainAxisFromPlacement(placement);\n                length = getLengthFromAxis(axis);\n                _context2.next = 10;\n                return platform.getDimensions(element);\n              case 10:\n                arrowDimensions = _context2.sent;\n                isYAxis = axis === 'y';\n                minProp = isYAxis ? 'top' : 'left';\n                maxProp = isYAxis ? 'bottom' : 'right';\n                clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n                endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n                startDiff = coords[axis] - rects.reference[axis];\n                _context2.next = 19;\n                return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element);\n              case 19:\n                arrowOffsetParent = _context2.sent;\n                clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0; // DOM platform can return `window` as the `offsetParent`.\n                _context2.t0 = !clientSize;\n                if (_context2.t0) {\n                  _context2.next = 26;\n                  break;\n                }\n                _context2.next = 25;\n                return platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent);\n              case 25:\n                _context2.t0 = !_context2.sent;\n              case 26:\n                if (!_context2.t0) {\n                  _context2.next = 28;\n                  break;\n                }\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n              case 28:\n                centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n                // point is outside the floating element's bounds.\n                min = paddingObject[minProp];\n                max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n                center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n                offset = within(min, center, max); // If the reference is small enough that the arrow's padding causes it to\n                // to point to nothing for an aligned placement, adjust the offset of the\n                // floating element itself. This stops `shift()` from taking action, but can\n                // be worked around by calling it again after the `arrow()` if desired.\n                shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n                alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n                return _context2.abrupt(\"return\", (_ref5 = {}, _defineProperty(_ref5, axis, coords[axis] - alignmentOffset), _defineProperty(_ref5, \"data\", (_data = {}, _defineProperty(_data, axis, offset), _defineProperty(_data, \"centerOffset\", center - offset), _data)), _ref5));\n              case 36:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }))();\n      }\n    };\n  };\n  var oppositeSideMap = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (side) {\n      return oppositeSideMap[side];\n    });\n  }\n  function getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n      rtl = false;\n    }\n    var alignment = getAlignment(placement);\n    var mainAxis = getMainAxisFromPlacement(placement);\n    var length = getLengthFromAxis(mainAxis);\n    var mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n    if (rects.reference[length] > rects.floating[length]) {\n      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return {\n      main: mainAlignmentSide,\n      cross: getOppositePlacement(mainAlignmentSide)\n    };\n  }\n  var oppositeAlignmentMap = {\n    start: 'end',\n    end: 'start'\n  };\n  function getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, function (alignment) {\n      return oppositeAlignmentMap[alignment];\n    });\n  }\n  function getExpandedPlacements(placement) {\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n  }\n  function getSideList(side, isStart, rtl) {\n    var lr = ['left', 'right'];\n    var rl = ['right', 'left'];\n    var tb = ['top', 'bottom'];\n    var bt = ['bottom', 'top'];\n    switch (side) {\n      case 'top':\n      case 'bottom':\n        if (rtl) return isStart ? rl : lr;\n        return isStart ? lr : rl;\n      case 'left':\n      case 'right':\n        return isStart ? tb : bt;\n      default:\n        return [];\n    }\n  }\n  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    var alignment = getAlignment(placement);\n    var list = getSideList(getSide(placement), direction === 'start', rtl);\n    if (alignment) {\n      list = list.map(function (side) {\n        return side + \"-\" + alignment;\n      });\n      if (flipAlignment) {\n        list = list.concat(list.map(getOppositeAlignmentPlacement));\n      }\n    }\n    return list;\n  }\n\n  /**\n   * Optimizes the visibility of the floating element by flipping the `placement`\n   * in order to keep it in view when the preferred placement(s) will overflow the\n   * clipping boundary. Alternative to `autoPlacement`.\n   * @see https://floating-ui.com/docs/flip\n   */\n  var flip = function flip(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'flip',\n      options: options,\n      fn: function fn(state) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n          var _middlewareData$flip, placement, middlewareData, rects, initialPlacement, platform, elements, _options, _options$mainAxis, checkMainAxis, _options$crossAxis, checkCrossAxis, specifiedFallbackPlacements, _options$fallbackStra, fallbackStrategy, _options$fallbackAxis, fallbackAxisSideDirection, _options$flipAlignmen, flipAlignment, detectOverflowOptions, side, isBasePlacement, rtl, fallbackPlacements, placements, overflow, overflows, overflowsData, _getAlignmentSides, main, cross, _middlewareData$flip2, _overflowsData$filter, nextIndex, nextPlacement, resetPlacement, _overflowsData$map$so, _placement;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                placement = state.placement, middlewareData = state.middlewareData, rects = state.rects, initialPlacement = state.initialPlacement, platform = state.platform, elements = state.elements;\n                _options = options, _options$mainAxis = _options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$crossAxis = _options.crossAxis, checkCrossAxis = _options$crossAxis === void 0 ? true : _options$crossAxis, specifiedFallbackPlacements = _options.fallbackPlacements, _options$fallbackStra = _options.fallbackStrategy, fallbackStrategy = _options$fallbackStra === void 0 ? 'bestFit' : _options$fallbackStra, _options$fallbackAxis = _options.fallbackAxisSideDirection, fallbackAxisSideDirection = _options$fallbackAxis === void 0 ? 'none' : _options$fallbackAxis, _options$flipAlignmen = _options.flipAlignment, flipAlignment = _options$flipAlignmen === void 0 ? true : _options$flipAlignmen, detectOverflowOptions = _objectWithoutPropertiesLoose(options, _excluded2);\n                side = getSide(placement);\n                isBasePlacement = getSide(initialPlacement) === initialPlacement;\n                _context3.next = 6;\n                return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);\n              case 6:\n                rtl = _context3.sent;\n                fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n                if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n                  fallbackPlacements.push.apply(fallbackPlacements, _toConsumableArray(getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl)));\n                }\n                placements = [initialPlacement].concat(_toConsumableArray(fallbackPlacements));\n                _context3.next = 12;\n                return detectOverflow(state, detectOverflowOptions);\n              case 12:\n                overflow = _context3.sent;\n                overflows = [];\n                overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n                if (checkMainAxis) {\n                  overflows.push(overflow[side]);\n                }\n                if (checkCrossAxis) {\n                  _getAlignmentSides = getAlignmentSides(placement, rects, rtl), main = _getAlignmentSides.main, cross = _getAlignmentSides.cross;\n                  overflows.push(overflow[main], overflow[cross]);\n                }\n                overflowsData = [].concat(_toConsumableArray(overflowsData), [{\n                  placement: placement,\n                  overflows: overflows\n                }]);\n\n                // One or more sides is overflowing.\n                if (overflows.every(function (side) {\n                  return side <= 0;\n                })) {\n                  _context3.next = 35;\n                  break;\n                }\n                nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                nextPlacement = placements[nextIndex];\n                if (!nextPlacement) {\n                  _context3.next = 23;\n                  break;\n                }\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    index: nextIndex,\n                    overflows: overflowsData\n                  },\n                  reset: {\n                    placement: nextPlacement\n                  }\n                });\n              case 23:\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                resetPlacement = (_overflowsData$filter = overflowsData.filter(function (d) {\n                  return d.overflows[0] <= 0;\n                }).sort(function (a, b) {\n                  return a.overflows[1] - b.overflows[1];\n                })[0]) == null ? void 0 : _overflowsData$filter.placement; // Otherwise fallback.\n                if (resetPlacement) {\n                  _context3.next = 33;\n                  break;\n                }\n                _context3.t0 = fallbackStrategy;\n                _context3.next = _context3.t0 === 'bestFit' ? 28 : _context3.t0 === 'initialPlacement' ? 31 : 33;\n                break;\n              case 28:\n                _placement = (_overflowsData$map$so = overflowsData.map(function (d) {\n                  return [d.placement, d.overflows.filter(function (overflow) {\n                    return overflow > 0;\n                  }).reduce(function (acc, overflow) {\n                    return acc + overflow;\n                  }, 0)];\n                }).sort(function (a, b) {\n                  return a[1] - b[1];\n                })[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (_placement) {\n                  resetPlacement = _placement;\n                }\n                return _context3.abrupt(\"break\", 33);\n              case 31:\n                resetPlacement = initialPlacement;\n                return _context3.abrupt(\"break\", 33);\n              case 33:\n                if (!(placement !== resetPlacement)) {\n                  _context3.next = 35;\n                  break;\n                }\n                return _context3.abrupt(\"return\", {\n                  reset: {\n                    placement: resetPlacement\n                  }\n                });\n              case 35:\n                return _context3.abrupt(\"return\", {});\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3);\n        }))();\n      }\n    };\n  };\n  function getCrossAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n\n  /**\n   * Optimizes the visibility of the floating element by shifting it in order to\n   * keep it in view when it will overflow the clipping boundary.\n   * @see https://floating-ui.com/docs/shift\n   */\n  var shift = function shift(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'shift',\n      options: options,\n      fn: function fn(state) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n          var _extends3;\n          var x, y, placement, _options2, _options2$mainAxis, checkMainAxis, _options2$crossAxis, checkCrossAxis, _options2$limiter, limiter, detectOverflowOptions, coords, overflow, mainAxis, crossAxis, mainAxisCoord, crossAxisCoord, minSide, maxSide, _min, _max, _minSide, _maxSide, _min2, _max2, limitedCoords;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) switch (_context4.prev = _context4.next) {\n              case 0:\n                x = state.x, y = state.y, placement = state.placement;\n                _options2 = options, _options2$mainAxis = _options2.mainAxis, checkMainAxis = _options2$mainAxis === void 0 ? true : _options2$mainAxis, _options2$crossAxis = _options2.crossAxis, checkCrossAxis = _options2$crossAxis === void 0 ? false : _options2$crossAxis, _options2$limiter = _options2.limiter, limiter = _options2$limiter === void 0 ? {\n                  fn: function fn(_ref) {\n                    var x = _ref.x,\n                      y = _ref.y;\n                    return {\n                      x: x,\n                      y: y\n                    };\n                  }\n                } : _options2$limiter, detectOverflowOptions = _objectWithoutPropertiesLoose(options, _excluded4);\n                coords = {\n                  x: x,\n                  y: y\n                };\n                _context4.next = 5;\n                return detectOverflow(state, detectOverflowOptions);\n              case 5:\n                overflow = _context4.sent;\n                mainAxis = getMainAxisFromPlacement(getSide(placement));\n                crossAxis = getCrossAxis(mainAxis);\n                mainAxisCoord = coords[mainAxis];\n                crossAxisCoord = coords[crossAxis];\n                if (checkMainAxis) {\n                  minSide = mainAxis === 'y' ? 'top' : 'left';\n                  maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n                  _min = mainAxisCoord + overflow[minSide];\n                  _max = mainAxisCoord - overflow[maxSide];\n                  mainAxisCoord = within(_min, mainAxisCoord, _max);\n                }\n                if (checkCrossAxis) {\n                  _minSide = crossAxis === 'y' ? 'top' : 'left';\n                  _maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n                  _min2 = crossAxisCoord + overflow[_minSide];\n                  _max2 = crossAxisCoord - overflow[_maxSide];\n                  crossAxisCoord = within(_min2, crossAxisCoord, _max2);\n                }\n                limitedCoords = limiter.fn(_extends({}, state, (_extends3 = {}, _defineProperty(_extends3, mainAxis, mainAxisCoord), _defineProperty(_extends3, crossAxis, crossAxisCoord), _extends3)));\n                return _context4.abrupt(\"return\", _extends({}, limitedCoords, {\n                  data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y\n                  }\n                }));\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }, _callee4);\n        }))();\n      }\n    };\n  };\n  /**\n   * Built-in `limiter` that will stop `shift()` at a certain point.\n   */\n  var limitShift = function limitShift(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      options: options,\n      fn: function fn(state) {\n        var _ref6;\n        var x = state.x,\n          y = state.y,\n          placement = state.placement,\n          rects = state.rects,\n          middlewareData = state.middlewareData;\n        var _options3 = options,\n          _options3$offset = _options3.offset,\n          offset = _options3$offset === void 0 ? 0 : _options3$offset,\n          _options3$mainAxis = _options3.mainAxis,\n          checkMainAxis = _options3$mainAxis === void 0 ? true : _options3$mainAxis,\n          _options3$crossAxis = _options3.crossAxis,\n          checkCrossAxis = _options3$crossAxis === void 0 ? true : _options3$crossAxis;\n        var coords = {\n          x: x,\n          y: y\n        };\n        var mainAxis = getMainAxisFromPlacement(placement);\n        var crossAxis = getCrossAxis(mainAxis);\n        var mainAxisCoord = coords[mainAxis];\n        var crossAxisCoord = coords[crossAxis];\n        var rawOffset = typeof offset === 'function' ? offset(state) : offset;\n        var computedOffset = typeof rawOffset === 'number' ? {\n          mainAxis: rawOffset,\n          crossAxis: 0\n        } : _extends({\n          mainAxis: 0,\n          crossAxis: 0\n        }, rawOffset);\n        if (checkMainAxis) {\n          var len = mainAxis === 'y' ? 'height' : 'width';\n          var limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n          var limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n          if (mainAxisCoord < limitMin) {\n            mainAxisCoord = limitMin;\n          } else if (mainAxisCoord > limitMax) {\n            mainAxisCoord = limitMax;\n          }\n        }\n        if (checkCrossAxis) {\n          var _middlewareData$offse, _middlewareData$offse2;\n          var _len2 = mainAxis === 'y' ? 'width' : 'height';\n          var isOriginSide = ['top', 'left'].includes(getSide(placement));\n          var _limitMin = rects.reference[crossAxis] - rects.floating[_len2] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n          var _limitMax = rects.reference[crossAxis] + rects.reference[_len2] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n          if (crossAxisCoord < _limitMin) {\n            crossAxisCoord = _limitMin;\n          } else if (crossAxisCoord > _limitMax) {\n            crossAxisCoord = _limitMax;\n          }\n        }\n        return _ref6 = {}, _defineProperty(_ref6, mainAxis, mainAxisCoord), _defineProperty(_ref6, crossAxis, crossAxisCoord), _ref6;\n      }\n    };\n  };\n  function getWindow(node) {\n    var _node$ownerDocument;\n    return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n  }\n  function getComputedStyle$1(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function isNode(value) {\n    return value instanceof getWindow(value).Node;\n  }\n  function getNodeName(node) {\n    return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n  }\n  var uaString;\n  function getUAString() {\n    if (uaString) {\n      return uaString;\n    }\n    var uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n      uaString = uaData.brands.map(function (item) {\n        return item.brand + \"/\" + item.version;\n      }).join(' ');\n      return uaString;\n    }\n    return navigator.userAgent;\n  }\n  function isHTMLElement(value) {\n    return value instanceof getWindow(value).HTMLElement;\n  }\n  function isElement(value) {\n    return value instanceof getWindow(value).Element;\n  }\n  function isShadowRoot(node) {\n    // Browsers without `ShadowRoot` support.\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n  function isOverflowElement(element) {\n    var _getComputedStyle$ = getComputedStyle$1(element),\n      overflow = _getComputedStyle$.overflow,\n      overflowX = _getComputedStyle$.overflowX,\n      overflowY = _getComputedStyle$.overflowY,\n      display = _getComputedStyle$.display;\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].includes(getNodeName(element));\n  }\n  function isContainingBlock(element) {\n    // TODO: Try to use feature detection here instead.\n    var isFirefox = /firefox/i.test(getUAString());\n    var css = getComputedStyle$1(element);\n    var backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n\n    // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(function (value) {\n      return css.willChange.includes(value);\n    }) || ['paint', 'layout', 'strict', 'content'].some(function (value) {\n      // Add type check for old browsers.\n      var contain = css.contain;\n      return contain != null ? contain.includes(value) : false;\n    });\n  }\n\n  /**\n   * Determines whether or not `.getBoundingClientRect()` is affected by visual\n   * viewport offsets. In Safari, the `x`/`y` offsets are values relative to the\n   * visual viewport, while in other engines, they are values relative to the\n   * layout viewport.\n   */\n  function isClientRectVisualViewportBased() {\n    // TODO: Try to use feature detection here instead. Feature detection for\n    // this can fail in various ways, making the userAgent check the most\n    // reliable:\n    // • Always-visible scrollbar or not\n    // • Width of <html>\n\n    // Is Safari.\n    return /^((?!chrome|android).)*safari/i.test(getUAString());\n  }\n  function isLastTraversableNode(node) {\n    return ['html', 'body', '#document'].includes(getNodeName(node));\n  }\n  var min = Math.min;\n  var max = Math.max;\n  var round = Math.round;\n  function getCssDimensions(element) {\n    var css = getComputedStyle$1(element);\n    var width = parseFloat(css.width);\n    var height = parseFloat(css.height);\n    var hasOffset = isHTMLElement(element);\n    var offsetWidth = hasOffset ? element.offsetWidth : width;\n    var offsetHeight = hasOffset ? element.offsetHeight : height;\n    var shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n    if (shouldFallback) {\n      width = offsetWidth;\n      height = offsetHeight;\n    }\n    return {\n      width: width,\n      height: height,\n      fallback: shouldFallback\n    };\n  }\n  function unwrapElement(element) {\n    return !isElement(element) ? element.contextElement : element;\n  }\n  var FALLBACK_SCALE = {\n    x: 1,\n    y: 1\n  };\n  function getScale(element) {\n    var domElement = unwrapElement(element);\n    if (!isHTMLElement(domElement)) {\n      return FALLBACK_SCALE;\n    }\n    var rect = domElement.getBoundingClientRect();\n    var _getCssDimensions = getCssDimensions(domElement),\n      width = _getCssDimensions.width,\n      height = _getCssDimensions.height,\n      fallback = _getCssDimensions.fallback;\n    var x = (fallback ? round(rect.width) : rect.width) / width;\n    var y = (fallback ? round(rect.height) : rect.height) / height;\n\n    // 0, NaN, or Infinity should always fallback to 1.\n\n    if (!x || !Number.isFinite(x)) {\n      x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n      y = 1;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  }\n  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    var _win$visualViewport, _win$visualViewport2;\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n      isFixedStrategy = false;\n    }\n    var clientRect = element.getBoundingClientRect();\n    var domElement = unwrapElement(element);\n    var scale = FALLBACK_SCALE;\n    if (includeScale) {\n      if (offsetParent) {\n        if (isElement(offsetParent)) {\n          scale = getScale(offsetParent);\n        }\n      } else {\n        scale = getScale(element);\n      }\n    }\n    var win = domElement ? getWindow(domElement) : window;\n    var addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;\n    var x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n    var y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n    var width = clientRect.width / scale.x;\n    var height = clientRect.height / scale.y;\n    if (domElement) {\n      var _win = getWindow(domElement);\n      var offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n      var currentIFrame = _win.frameElement;\n      while (currentIFrame && offsetParent && offsetWin !== _win) {\n        var iframeScale = getScale(currentIFrame);\n        var iframeRect = currentIFrame.getBoundingClientRect();\n        var css = getComputedStyle(currentIFrame);\n        iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n        iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n        x *= iframeScale.x;\n        y *= iframeScale.y;\n        width *= iframeScale.x;\n        height *= iframeScale.y;\n        x += iframeRect.x;\n        y += iframeRect.y;\n        currentIFrame = getWindow(currentIFrame).frameElement;\n      }\n    }\n    return rectToClientRect({\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    });\n  }\n  function getDocumentElement(node) {\n    return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n  }\n  function getNodeScroll(element) {\n    if (isElement(element)) {\n      return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n      };\n    }\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    var rect = _ref.rect,\n      offsetParent = _ref.offsetParent,\n      strategy = _ref.strategy;\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    if (offsetParent === documentElement) {\n      return rect;\n    }\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var scale = {\n      x: 1,\n      y: 1\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        var offsetRect = getBoundingClientRect(offsetParent);\n        scale = getScale(offsetParent);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      }\n    }\n    return {\n      width: rect.width * scale.x,\n      height: rect.height * scale.y,\n      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n  }\n\n  // Gets the entire size of the scrollable document area, even extending outside\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable.\n  function getDocumentRect(element) {\n    var html = getDocumentElement(element);\n    var scroll = getNodeScroll(element);\n    var body = element.ownerDocument.body;\n    var width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    var height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    var x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -scroll.scrollTop;\n    if (getComputedStyle$1(body).direction === 'rtl') {\n      x += max(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function getParentNode(node) {\n    if (getNodeName(node) === 'html') {\n      return node;\n    }\n    var result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    isShadowRoot(node) && node.host ||\n    // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n  }\n  function getNearestOverflowAncestor(node) {\n    var parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n      // `getParentNode` will never return a `Document` due to the fallback\n      // check, so it's either the <html> or <body> element.\n      return parentNode.ownerDocument.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n      return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n  }\n  function getOverflowAncestors(node, list) {\n    var _node$ownerDocument;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollableAncestor = getNearestOverflowAncestor(node);\n    var isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n    var win = getWindow(scrollableAncestor);\n    if (isBody) {\n      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n  }\n  function getViewportRect(element, strategy) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0;\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height;\n      var visualViewportBased = isClientRectVisualViewportBased();\n      if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n\n  // Returns the inner client rect, subtracting scrollbars if present.\n  function getInnerBoundingClientRect(element, strategy) {\n    var clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n    var top = clientRect.top + element.clientTop;\n    var left = clientRect.left + element.clientLeft;\n    var scale = isHTMLElement(element) ? getScale(element) : {\n      x: 1,\n      y: 1\n    };\n    var width = element.clientWidth * scale.x;\n    var height = element.clientHeight * scale.y;\n    var x = left * scale.x;\n    var y = top * scale.y;\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    var rect;\n    if (clippingAncestor === 'viewport') {\n      rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === 'document') {\n      rect = getDocumentRect(getDocumentElement(element));\n    } else if (isElement(clippingAncestor)) {\n      rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n      var mutableRect = _extends({}, clippingAncestor);\n      if (isClientRectVisualViewportBased()) {\n        var _win$visualViewport, _win$visualViewport2;\n        var win = getWindow(element);\n        mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;\n        mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;\n      }\n      rect = mutableRect;\n    }\n    return rectToClientRect(rect);\n  }\n\n  // A \"clipping ancestor\" is an `overflow` element with the characteristic of\n  // clipping (or hiding) child elements. This returns all clipping ancestors\n  // of the given element up the tree.\n  function getClippingElementAncestors(element, cache) {\n    var cachedResult = cache.get(element);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    var result = getOverflowAncestors(element).filter(function (el) {\n      return isElement(el) && getNodeName(el) !== 'body';\n    });\n    var currentContainingBlockComputedStyle = null;\n    var elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n    var currentNode = elementIsFixed ? getParentNode(element) : element;\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      var computedStyle = getComputedStyle$1(currentNode);\n      var containingBlock = isContainingBlock(currentNode);\n      var shouldIgnoreCurrentNode = computedStyle.position === 'fixed';\n      if (shouldIgnoreCurrentNode) {\n        currentContainingBlockComputedStyle = null;\n      } else {\n        var shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n        if (shouldDropCurrentNode) {\n          // Drop non-containing blocks.\n          result = result.filter(function (ancestor) {\n            return ancestor !== currentNode;\n          });\n        } else {\n          // Record last containing block for next iteration.\n          currentContainingBlockComputedStyle = computedStyle;\n        }\n      }\n      currentNode = getParentNode(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n  }\n\n  // Gets the maximum area that the element is visible in due to any number of\n  // clipping ancestors.\n  function getClippingRect(_ref) {\n    var element = _ref.element,\n      boundary = _ref.boundary,\n      rootBoundary = _ref.rootBoundary,\n      strategy = _ref.strategy;\n    var elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    var clippingAncestors = [].concat(_toConsumableArray(elementClippingAncestors), [rootBoundary]);\n    var firstClippingAncestor = clippingAncestors[0];\n    var clippingRect = clippingAncestors.reduce(function (accRect, clippingAncestor) {\n      var rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n      width: clippingRect.right - clippingRect.left,\n      height: clippingRect.bottom - clippingRect.top,\n      x: clippingRect.left,\n      y: clippingRect.top\n    };\n  }\n  function getDimensions(element) {\n    return getCssDimensions(element);\n  }\n  function getTrueOffsetParent(element, polyfill) {\n    if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n      return null;\n    }\n    if (polyfill) {\n      return polyfill(element);\n    }\n    return element.offsetParent;\n  }\n  function getContainingBlock(element) {\n    var currentNode = getParentNode(element);\n    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      if (isContainingBlock(currentNode)) {\n        return currentNode;\n      } else {\n        currentNode = getParentNode(currentNode);\n      }\n    }\n    return null;\n  }\n\n  // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n  function getOffsetParent(element, polyfill) {\n    var window = getWindow(element);\n    if (!isHTMLElement(element)) {\n      return window;\n    }\n    var offsetParent = getTrueOffsetParent(element, polyfill);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        var offsetRect = getBoundingClientRect(offsetParent, true);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  var platform = {\n    getClippingRect: getClippingRect,\n    convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect,\n    isElement: isElement,\n    getDimensions: getDimensions,\n    getOffsetParent: getOffsetParent,\n    getDocumentElement: getDocumentElement,\n    getScale: getScale,\n    getElementRects: function getElementRects(_ref) {\n      var _this3 = this;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var reference, floating, strategy, getOffsetParentFn, getDimensionsFn;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              reference = _ref.reference, floating = _ref.floating, strategy = _ref.strategy;\n              getOffsetParentFn = _this3.getOffsetParent || getOffsetParent;\n              getDimensionsFn = _this3.getDimensions;\n              _context5.t0 = getRectRelativeToOffsetParent;\n              _context5.t1 = reference;\n              _context5.next = 7;\n              return getOffsetParentFn(floating);\n            case 7:\n              _context5.t2 = _context5.sent;\n              _context5.t3 = strategy;\n              _context5.t4 = (0, _context5.t0)(_context5.t1, _context5.t2, _context5.t3);\n              _context5.t5 = _extends;\n              _context5.t6 = {\n                x: 0,\n                y: 0\n              };\n              _context5.next = 14;\n              return getDimensionsFn(floating);\n            case 14:\n              _context5.t7 = _context5.sent;\n              _context5.t8 = (0, _context5.t5)(_context5.t6, _context5.t7);\n              return _context5.abrupt(\"return\", {\n                reference: _context5.t4,\n                floating: _context5.t8\n              });\n            case 17:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }))();\n    },\n    getClientRects: function getClientRects(element) {\n      return Array.from(element.getClientRects());\n    },\n    isRTL: function isRTL(element) {\n      return getComputedStyle$1(element).direction === 'rtl';\n    }\n  };\n\n  /**\n   * Automatically updates the position of the floating element when necessary.\n   * Should only be called when the floating element is mounted on the DOM or\n   * visible on the screen.\n   * @returns cleanup function that should be invoked when the floating element is\n   * removed from the DOM or hidden from the screen.\n   * @see https://floating-ui.com/docs/autoUpdate\n   */\n  function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options4 = options,\n      _options4$ancestorScr = _options4.ancestorScroll,\n      _ancestorScroll = _options4$ancestorScr === void 0 ? true : _options4$ancestorScr,\n      _options4$ancestorRes = _options4.ancestorResize,\n      ancestorResize = _options4$ancestorRes === void 0 ? true : _options4$ancestorRes,\n      _options4$elementResi = _options4.elementResize,\n      elementResize = _options4$elementResi === void 0 ? true : _options4$elementResi,\n      _options4$animationFr = _options4.animationFrame,\n      animationFrame = _options4$animationFr === void 0 ? false : _options4$animationFr;\n    var ancestorScroll = _ancestorScroll && !animationFrame;\n    var ancestors = ancestorScroll || ancestorResize ? [].concat(_toConsumableArray(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), _toConsumableArray(getOverflowAncestors(floating))) : [];\n    ancestors.forEach(function (ancestor) {\n      ancestorScroll && ancestor.addEventListener('scroll', update, {\n        passive: true\n      });\n      ancestorResize && ancestor.addEventListener('resize', update);\n    });\n    var observer = null;\n    if (elementResize) {\n      observer = new ResizeObserver(function () {\n        update();\n      });\n      isElement(reference) && !animationFrame && observer.observe(reference);\n      if (!isElement(reference) && reference.contextElement && !animationFrame) {\n        observer.observe(reference.contextElement);\n      }\n      observer.observe(floating);\n    }\n    var frameId;\n    var prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n      frameLoop();\n    }\n    function frameLoop() {\n      var nextRefRect = getBoundingClientRect(reference);\n      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n        update();\n      }\n      prevRefRect = nextRefRect;\n      frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return function () {\n      var _observer;\n      ancestors.forEach(function (ancestor) {\n        ancestorScroll && ancestor.removeEventListener('scroll', update);\n        ancestorResize && ancestor.removeEventListener('resize', update);\n      });\n      (_observer = observer) == null ? void 0 : _observer.disconnect();\n      observer = null;\n      if (animationFrame) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }\n\n  /**\n   * Computes the `x` and `y` coordinates that will place the floating element\n   * next to a reference element when it is given a certain CSS positioning\n   * strategy.\n   */\n  var computePosition = function computePosition(reference, floating, options) {\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    var cache = new Map();\n    var mergedOptions = _extends({\n      platform: platform\n    }, options);\n    var platformWithCache = _extends({}, mergedOptions.platform, {\n      _c: cache\n    });\n    return computePosition$1(reference, floating, _extends({}, mergedOptions, {\n      platform: platformWithCache\n    }));\n  };\n\n  /**\n   * Floating UI Options\n   *\n   * @typedef {object} FloatingUIOptions\n   */\n\n  /**\n   * Determines options for the tooltip and initializes event listeners.\n   *\n   * @param {Step} step The step instance\n   *\n   * @return {FloatingUIOptions}\n   */\n  function setupTooltip(step) {\n    if (step.cleanup) {\n      step.cleanup();\n    }\n    var attachToOptions = step._getResolvedAttachToOptions();\n    var target = attachToOptions.element;\n    var floatingUIOptions = getFloatingUIOptions(attachToOptions, step);\n    var shouldCenter = shouldCenterStep(attachToOptions);\n    if (shouldCenter) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n    step.cleanup = autoUpdate(target, step.el, function () {\n      // The element might have already been removed by the end of the tour.\n      if (!step.el) {\n        step.cleanup();\n        return;\n      }\n      setPosition(target, step, floatingUIOptions, shouldCenter);\n    });\n    step.target = attachToOptions.element;\n    return floatingUIOptions;\n  }\n\n  /**\n   * Merge tooltip options handling nested keys.\n   *\n   * @param tourOptions - The default tour options.\n   * @param options - Step specific options.\n   *\n   * @return {floatingUIOptions: FloatingUIOptions}\n   */\n  function mergeTooltipConfig(tourOptions, options) {\n    return {\n      floatingUIOptions: cjs(tourOptions.floatingUIOptions || {}, options.floatingUIOptions || {})\n    };\n  }\n\n  /**\n   * Cleanup function called when the step is closed/destroyed.\n   *\n   * @param {Step} step\n   */\n  function destroyTooltip(step) {\n    if (step.cleanup) {\n      step.cleanup();\n    }\n    step.cleanup = null;\n  }\n\n  /**\n   *\n   * @return {Promise<*>}\n   */\n  function setPosition(target, step, floatingUIOptions, shouldCenter) {\n    return computePosition(target, step.el, floatingUIOptions).then(floatingUIposition(step, shouldCenter))\n    // Wait before forcing focus.\n    .then(function (step) {\n      return new Promise(function (resolve) {\n        setTimeout(function () {\n          return resolve(step);\n        }, 300);\n      });\n    })\n    // Replaces focusAfterRender modifier.\n    .then(function (step) {\n      if (step && step.el) {\n        step.el.focus({\n          preventScroll: true\n        });\n      }\n    });\n  }\n\n  /**\n   *\n   * @param step\n   * @param shouldCenter\n   * @return {function({x: *, y: *, placement: *, middlewareData: *}): Promise<unknown>}\n   */\n  function floatingUIposition(step, shouldCenter) {\n    return function (_ref) {\n      var x = _ref.x,\n        y = _ref.y,\n        placement = _ref.placement,\n        middlewareData = _ref.middlewareData;\n      if (!step.el) {\n        return step;\n      }\n      if (shouldCenter) {\n        Object.assign(step.el.style, {\n          position: 'fixed',\n          left: '50%',\n          top: '50%',\n          transform: 'translate(-50%, -50%)'\n        });\n      } else {\n        Object.assign(step.el.style, {\n          position: 'absolute',\n          left: \"\".concat(x, \"px\"),\n          top: \"\".concat(y, \"px\")\n        });\n      }\n      step.el.dataset.popperPlacement = placement;\n      placeArrow(step.el, middlewareData);\n      return step;\n    };\n  }\n\n  /**\n   *\n   * @param el\n   * @param middlewareData\n   */\n  function placeArrow(el, middlewareData) {\n    var arrowEl = el.querySelector('.shepherd-arrow');\n    if (arrowEl && middlewareData.arrow) {\n      var _middlewareData$arrow = middlewareData.arrow,\n        arrowX = _middlewareData$arrow.x,\n        arrowY = _middlewareData$arrow.y;\n      Object.assign(arrowEl.style, {\n        left: arrowX != null ? \"\".concat(arrowX, \"px\") : '',\n        top: arrowY != null ? \"\".concat(arrowY, \"px\") : ''\n      });\n    }\n  }\n\n  /**\n   * Gets the `Floating UI` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n  function getFloatingUIOptions(attachToOptions, step) {\n    var options = {\n      strategy: 'absolute',\n      middleware: []\n    };\n    var arrowEl = addArrow(step);\n    var shouldCenter = shouldCenterStep(attachToOptions);\n    if (!shouldCenter) {\n      options.middleware.push(flip(),\n      // Replicate PopperJS default behavior.\n      shift({\n        limiter: limitShift(),\n        crossAxis: true\n      }));\n      if (arrowEl) {\n        options.middleware.push(arrow({\n          element: arrowEl\n        }));\n      }\n      options.placement = attachToOptions.on;\n    }\n    return cjs(step.options.floatingUIOptions || {}, options);\n  }\n\n  /**\n   * @param {Step} step\n   * @return {HTMLElement|false|null}\n   */\n  function addArrow(step) {\n    if (step.options.arrow && step.el) {\n      return step.el.querySelector('.shepherd-arrow');\n    }\n    return false;\n  }\n  function noop() {}\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) tar[k] = src[k];\n    return tar;\n  }\n  function run(fn) {\n    return fn();\n  }\n  function blank_object() {\n    return Object.create(null);\n  }\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n  function append(target, node) {\n    target.appendChild(node);\n  }\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n  function detach(node) {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  }\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n  function element(name) {\n    return document.createElement(name);\n  }\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n  function text(data) {\n    return document.createTextNode(data);\n  }\n  function space() {\n    return text(' ');\n  }\n  function empty() {\n    return text('');\n  }\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value') {\n        node.value = node[key] = attributes[key];\n      } else if (descriptors[key] && descriptors[key].set) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n  var current_component;\n  function set_current_component(component) {\n    current_component = component;\n  }\n  function get_current_component() {\n    if (!current_component) throw new Error('Function called outside component initialization');\n    return current_component;\n  }\n  /**\n   * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n   * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n   * it can be called from an external module).\n   *\n   * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n   *\n   * https://svelte.dev/docs#run-time-svelte-onmount\n   */\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n  /**\n   * Schedules a callback to run immediately after the component has been updated.\n   *\n   * The first time the callback runs will be after the initial `onMount`\n   */\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = /* @__PURE__ */Promise.resolve();\n  var update_scheduled = false;\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n  // flush() calls callbacks in this order:\n  // 1. All beforeUpdate callbacks, in order: parents before children\n  // 2. All bind:this callbacks, in reverse order: children before parents.\n  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n  //    for afterUpdates called during the initial onMount, which are called in\n  //    reverse order: children before parents.\n  // Since callbacks might update component values, which could trigger another\n  // call to flush(), the following steps guard against this:\n  // 1. During beforeUpdate, any updated components will be added to the\n  //    dirty_components array and will cause a reentrant call to flush(). Because\n  //    the flush index is kept outside the function, the reentrant call will pick\n  //    up where the earlier call left off and go through all dirty components. The\n  //    current_component value is saved and restored so that the reentrant call will\n  //    not interfere with the \"parent\" flush() call.\n  // 2. bind:this callbacks cannot trigger new flush() calls.\n  // 3. During afterUpdate, any updated components will NOT have their afterUpdate\n  //    callback called a second time; the seen_callbacks set, outside the flush()\n  //    function, guarantees this behavior.\n  var seen_callbacks = new Set();\n  var flushidx = 0; // Do *not* move this inside the flush() function\n  function flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n      return;\n    }\n    var saved_component = current_component;\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      try {\n        while (flushidx < dirty_components.length) {\n          var component = dirty_components[flushidx];\n          flushidx++;\n          set_current_component(component);\n          update(component.$$);\n        }\n      } catch (e) {\n        // reset dirty state to not end up in a deadlocked state and then rethrow\n        dirty_components.length = 0;\n        flushidx = 0;\n        throw e;\n      }\n      set_current_component(null);\n      dirty_components.length = 0;\n      flushidx = 0;\n      while (binding_callbacks.length) binding_callbacks.pop()();\n      // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n      for (var i = 0; i < render_callbacks.length; i += 1) {\n        var callback = render_callbacks[i];\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n  }\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n  /**\n   * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n   */\n  function flush_render_callbacks(fns) {\n    var filtered = [];\n    var targets = [];\n    render_callbacks.forEach(function (c) {\n      return fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c);\n    });\n    targets.forEach(function (c) {\n      return c();\n    });\n    render_callbacks = filtered;\n  }\n  var outroing = new Set();\n  var outros;\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n    };\n  }\n\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n    outros = outros.p;\n  }\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n        for (var _key2 in n) {\n          if (!accounted_for[_key2]) {\n            update[_key2] = n[_key2];\n            accounted_for[_key2] = 1;\n          }\n        }\n        levels[i] = n;\n      } else {\n        for (var _key3 in o) {\n          accounted_for[_key3] = 1;\n        }\n      }\n    }\n    for (var _key4 in to_null_out) {\n      if (!(_key4 in update)) update[_key4] = undefined;\n    }\n    return update;\n  }\n  function create_component(block) {\n    block && block.c();\n  }\n  function mount_component(component, target, anchor, customElement) {\n    var _component$$$ = component.$$,\n      fragment = _component$$$.fragment,\n      after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n      // onMount happens before the initial afterUpdate\n      add_render_callback(function () {\n        var new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n        // if the component was destroyed immediately\n        // it will update the `$$.on_destroy` reference to `null`.\n        // the destructured on_destroy may still reference to the old array\n        if (component.$$.on_destroy) {\n          var _component$$$$on_dest;\n          (_component$$$$on_dest = component.$$.on_destroy).push.apply(_component$$$$on_dest, _toConsumableArray(new_on_destroy));\n        } else {\n          // Edge case - component was destroyed immediately,\n          // most likely as a result of a binding initialising\n          run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n      });\n    }\n    after_update.forEach(add_render_callback);\n  }\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n    if ($$.fragment !== null) {\n      flush_render_callbacks($$.after_update);\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching);\n      // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n  function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty) {\n    if (dirty === void 0) {\n      dirty = [-1];\n    }\n    var parent_component = current_component;\n    set_current_component(component);\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: [],\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty,\n      skip_bound: false,\n      root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    var ready = false;\n    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor, options.customElement);\n      flush();\n    }\n    set_current_component(parent_component);\n  }\n  /**\n   * Base class for Svelte components. Used when dev=false.\n   */\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {\n      _classCallCheck(this, SvelteComponent);\n    }\n    _createClass(SvelteComponent, [{\n      key: \"$destroy\",\n      value: function $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n      }\n    }, {\n      key: \"$on\",\n      value: function $on(type, callback) {\n        if (!is_function(callback)) {\n          return noop;\n        }\n        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n        callbacks.push(callback);\n        return function () {\n          var index = callbacks.indexOf(callback);\n          if (index !== -1) callbacks.splice(index, 1);\n        };\n      }\n    }, {\n      key: \"$set\",\n      value: function $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n          this.$$.skip_bound = true;\n          this.$$set($$props);\n          this.$$.skip_bound = false;\n        }\n      }\n    }]);\n    return SvelteComponent;\n  }();\n  /* src/js/components/shepherd-button.svelte generated by Svelte v3.58.0 */\n  function create_fragment$8(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value = /*label*/ctx[3] ? /*label*/ctx[3] : null);\n        attr(button, \"class\", button_class_value = \"\".concat( /*classes*/ctx[1] || '', \" shepherd-button \").concat( /*secondary*/ctx[4] ? 'shepherd-button-secondary' : ''));\n        button.disabled = /*disabled*/ctx[2];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        button.innerHTML = /*text*/ctx[5];\n        if (!mounted) {\n          dispose = listen(button, \"click\", function () {\n            if (is_function( /*action*/ctx[0])) /*action*/ctx[0].apply(this, arguments);\n          });\n          mounted = true;\n        }\n      },\n      p: function p(new_ctx, _ref) {\n        var _ref7 = _slicedToArray(_ref, 1),\n          dirty = _ref7[0];\n        ctx = new_ctx;\n        if (dirty & /*text*/32) button.innerHTML = /*text*/ctx[5];\n        if (dirty & /*label*/8 && button_aria_label_value !== (button_aria_label_value = /*label*/ctx[3] ? /*label*/ctx[3] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n        if (dirty & /*classes, secondary*/18 && button_class_value !== (button_class_value = \"\".concat( /*classes*/ctx[1] || '', \" shepherd-button \").concat( /*secondary*/ctx[4] ? 'shepherd-button-secondary' : ''))) {\n          attr(button, \"class\", button_class_value);\n        }\n        if (dirty & /*disabled*/4) {\n          button.disabled = /*disabled*/ctx[2];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$8($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n      step = $$props.step;\n    var action, classes, disabled, label, secondary, text;\n    function getConfigOption(option) {\n      if (isFunction(option)) {\n        return option = option.call(step);\n      }\n      return option;\n    }\n    $$self.$$set = function ($$props) {\n      if ('config' in $$props) $$invalidate(6, config = $$props.config);\n      if ('step' in $$props) $$invalidate(7, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*config, step*/192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, disabled = config.disabled ? getConfigOption(config.disabled) : false);\n          $$invalidate(3, label = config.label ? getConfigOption(config.label) : null);\n          $$invalidate(4, secondary = config.secondary);\n          $$invalidate(5, text = config.text ? getConfigOption(config.text) : null);\n        }\n      }\n    };\n    return [action, classes, disabled, label, secondary, text, config, step];\n  }\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inherits(Shepherd_button, _SvelteComponent);\n    var _super = _createSuper(Shepherd_button);\n    function Shepherd_button(options) {\n      var _this4;\n      _classCallCheck(this, Shepherd_button);\n      _this4 = _super.call(this);\n      init(_assertThisInitialized(_this4), options, instance$8, create_fragment$8, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this4;\n    }\n    return _createClass(Shepherd_button);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-footer.svelte generated by Svelte v3.58.0 */\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  }\n\n  // (24:4) {#if buttons}\n  function create_if_block$3(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value = /*buttons*/ctx[1];\n    var each_blocks = [];\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n    return {\n      c: function c() {\n        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {\n          each_blocks[_i2].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n          if (each_blocks[_i3]) {\n            each_blocks[_i3].m(target, anchor);\n          }\n        }\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty & /*buttons, step*/3) {\n          each_value = /*buttons*/ctx[1];\n          var _i4;\n          for (_i4 = 0; _i4 < each_value.length; _i4 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i4);\n            if (each_blocks[_i4]) {\n              each_blocks[_i4].p(child_ctx, dirty);\n              transition_in(each_blocks[_i4], 1);\n            } else {\n              each_blocks[_i4] = create_each_block(child_ctx);\n              each_blocks[_i4].c();\n              transition_in(each_blocks[_i4], 1);\n              each_blocks[_i4].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          group_outros();\n          for (_i4 = each_value.length; _i4 < each_blocks.length; _i4 += 1) {\n            out(_i4);\n          }\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        for (var _i5 = 0; _i5 < each_value.length; _i5 += 1) {\n          transition_in(each_blocks[_i5]);\n        }\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {\n          transition_out(each_blocks[_i6]);\n        }\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  }\n\n  // (25:8) {#each buttons as config}\n  function create_each_block(ctx) {\n    var shepherdbutton;\n    var current;\n    shepherdbutton = new Shepherd_button({\n      props: {\n        config: /*config*/ctx[2],\n        step: /*step*/ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty & /*buttons*/2) shepherdbutton_changes.config = /*config*/ctx[2];\n        if (dirty & /*step*/1) shepherdbutton_changes.step = /*step*/ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n  function create_fragment$7(ctx) {\n    var footer;\n    var current;\n    var if_block = /*buttons*/ctx[1] && create_if_block$3(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref8 = _slicedToArray(_ref, 1),\n          dirty = _ref8[0];\n        if ( /*buttons*/ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n            if (dirty & /*buttons*/2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block$3(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n  function instance$7($$self, $$props, $$invalidate) {\n    var buttons;\n    var step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('step' in $$props) $$invalidate(0, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n    return [step, buttons];\n  }\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent2) {\n    _inherits(Shepherd_footer, _SvelteComponent2);\n    var _super2 = _createSuper(Shepherd_footer);\n    function Shepherd_footer(options) {\n      var _this5;\n      _classCallCheck(this, Shepherd_footer);\n      _this5 = _super2.call(this);\n      init(_assertThisInitialized(_this5), options, instance$7, create_fragment$7, safe_not_equal, {\n        step: 0\n      });\n      return _this5;\n    }\n    return _createClass(Shepherd_footer);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-cancel-icon.svelte generated by Svelte v3.58.0 */\n  function create_fragment$6(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"×\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value = /*cancelIcon*/ctx[0].label ? /*cancelIcon*/ctx[0].label : 'Close Tour');\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        append(button, span);\n        if (!mounted) {\n          dispose = listen(button, \"click\", /*handleCancelClick*/ctx[1]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref9 = _slicedToArray(_ref, 1),\n          dirty = _ref9[0];\n        if (dirty & /*cancelIcon*/1 && button_aria_label_value !== (button_aria_label_value = /*cancelIcon*/ctx[0].label ? /*cancelIcon*/ctx[0].label : 'Close Tour')) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$6($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n      step = $$props.step;\n\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n    $$self.$$set = function ($$props) {\n      if ('cancelIcon' in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [cancelIcon, handleCancelClick, step];\n  }\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent3) {\n    _inherits(Shepherd_cancel_icon, _SvelteComponent3);\n    var _super3 = _createSuper(Shepherd_cancel_icon);\n    function Shepherd_cancel_icon(options) {\n      var _this6;\n      _classCallCheck(this, Shepherd_cancel_icon);\n      _this6 = _super3.call(this);\n      init(_assertThisInitialized(_this6), options, instance$6, create_fragment$6, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this6;\n    }\n    return _createClass(Shepherd_cancel_icon);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-title.svelte generated by Svelte v3.58.0 */\n  function create_fragment$5(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\", /*labelId*/ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref) {\n        var _ref10 = _slicedToArray(_ref, 1),\n          dirty = _ref10[0];\n        if (dirty & /*labelId*/2) {\n          attr(h3, \"id\", /*labelId*/ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$5($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      element = $$props.element,\n      title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('title' in $$props) $$invalidate(2, title = $$props.title);\n    };\n    return [element, labelId, title, h3_binding];\n  }\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent4) {\n    _inherits(Shepherd_title, _SvelteComponent4);\n    var _super4 = _createSuper(Shepherd_title);\n    function Shepherd_title(options) {\n      var _this7;\n      _classCallCheck(this, Shepherd_title);\n      _this7 = _super4.call(this);\n      init(_assertThisInitialized(_this7), options, instance$5, create_fragment$5, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this7;\n    }\n    return _createClass(Shepherd_title);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-header.svelte generated by Svelte v3.58.0 */\n  function create_if_block_1$1(ctx) {\n    var shepherdtitle;\n    var current;\n    shepherdtitle = new Shepherd_title({\n      props: {\n        labelId: /*labelId*/ctx[0],\n        title: /*title*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty & /*labelId*/1) shepherdtitle_changes.labelId = /*labelId*/ctx[0];\n        if (dirty & /*title*/4) shepherdtitle_changes.title = /*title*/ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  }\n\n  // (39:4) {#if cancelIcon && cancelIcon.enabled}\n  function create_if_block$2(ctx) {\n    var shepherdcancelicon;\n    var current;\n    shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon: /*cancelIcon*/ctx[3],\n        step: /*step*/ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty & /*cancelIcon*/8) shepherdcancelicon_changes.cancelIcon = /*cancelIcon*/ctx[3];\n        if (dirty & /*step*/2) shepherdcancelicon_changes.step = /*step*/ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 = /*title*/ctx[2] && create_if_block_1$1(ctx);\n    var if_block1 = /*cancelIcon*/ctx[3] && /*cancelIcon*/ctx[3].enabled && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref11 = _slicedToArray(_ref, 1),\n          dirty = _ref11[0];\n        if ( /*title*/ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*title*/4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1$1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if ( /*cancelIcon*/ctx[3] && /*cancelIcon*/ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*cancelIcon*/8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$2(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      step = $$props.step;\n    var title, cancelIcon;\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(1, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n    return [labelId, step, title, cancelIcon];\n  }\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent5) {\n    _inherits(Shepherd_header, _SvelteComponent5);\n    var _super5 = _createSuper(Shepherd_header);\n    function Shepherd_header(options) {\n      var _this8;\n      _classCallCheck(this, Shepherd_header);\n      _this8 = _super5.call(this);\n      init(_assertThisInitialized(_this8), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this8;\n    }\n    return _createClass(Shepherd_header);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-text.svelte generated by Svelte v3.58.0 */\n  function create_fragment$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\", /*descriptionId*/ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref) {\n        var _ref12 = _slicedToArray(_ref, 1),\n          dirty = _ref12[0];\n        if (dirty & /*descriptionId*/2) {\n          attr(div, \"id\", /*descriptionId*/ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$3($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      element = $$props.element,\n      step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n      if (isHTMLElement$1(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [element, descriptionId, step, div_binding];\n  }\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent6) {\n    _inherits(Shepherd_text, _SvelteComponent6);\n    var _super6 = _createSuper(Shepherd_text);\n    function Shepherd_text(options) {\n      var _this9;\n      _classCallCheck(this, Shepherd_text);\n      _this9 = _super6.call(this);\n      init(_assertThisInitialized(_this9), options, instance$3, create_fragment$3, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this9;\n    }\n    return _createClass(Shepherd_text);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-content.svelte generated by Svelte v3.58.0 */\n  function create_if_block_2(ctx) {\n    var shepherdheader;\n    var current;\n    shepherdheader = new Shepherd_header({\n      props: {\n        labelId: /*labelId*/ctx[1],\n        step: /*step*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty & /*labelId*/2) shepherdheader_changes.labelId = /*labelId*/ctx[1];\n        if (dirty & /*step*/4) shepherdheader_changes.step = /*step*/ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  }\n\n  // (28:2) {#if !isUndefined(step.options.text)}\n  function create_if_block_1(ctx) {\n    var shepherdtext;\n    var current;\n    shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId: /*descriptionId*/ctx[0],\n        step: /*step*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty & /*descriptionId*/1) shepherdtext_changes.descriptionId = /*descriptionId*/ctx[0];\n        if (dirty & /*step*/4) shepherdtext_changes.step = /*step*/ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  }\n\n  // (35:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n  function create_if_block$1(ctx) {\n    var shepherdfooter;\n    var current;\n    shepherdfooter = new Shepherd_footer({\n      props: {\n        step: /*step*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty & /*step*/4) shepherdfooter_changes.step = /*step*/ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n  function create_fragment$2(ctx) {\n    var div;\n    var show_if_2 = !isUndefined( /*step*/ctx[2].options.title) || /*step*/ctx[2].options.cancelIcon && /*step*/ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined( /*step*/ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray( /*step*/ctx[2].options.buttons) && /*step*/ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1(ctx);\n    var if_block2 = show_if && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref13 = _slicedToArray(_ref, 1),\n          dirty = _ref13[0];\n        if (dirty & /*step*/4) show_if_2 = !isUndefined( /*step*/ctx[2].options.title) || /*step*/ctx[2].options.cancelIcon && /*step*/ctx[2].options.cancelIcon.enabled;\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*step*/4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/4) show_if_1 = !isUndefined( /*step*/ctx[2].options.text);\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*step*/4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/4) show_if = Array.isArray( /*step*/ctx[2].options.buttons) && /*step*/ctx[2].options.buttons.length;\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n            if (dirty & /*step*/4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$1(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n  function instance$2($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      labelId = $$props.labelId,\n      step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [descriptionId, labelId, step];\n  }\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent7) {\n    _inherits(Shepherd_content, _SvelteComponent7);\n    var _super7 = _createSuper(Shepherd_content);\n    function Shepherd_content(options) {\n      var _this10;\n      _classCallCheck(this, Shepherd_content);\n      _this10 = _super7.call(this);\n      init(_assertThisInitialized(_this10), options, instance$2, create_fragment$2, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this10;\n    }\n    return _createClass(Shepherd_content);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-element.svelte generated by Svelte v3.58.0 */\n  function create_if_block(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n  function create_fragment$1(ctx) {\n    var div;\n    var t;\n    var shepherdcontent;\n    var div_aria_describedby_value;\n    var div_aria_labelledby_value;\n    var current;\n    var mounted;\n    var dispose;\n    var if_block = /*step*/ctx[4].options.arrow && /*step*/ctx[4].options.attachTo && /*step*/ctx[4].options.attachTo.element && /*step*/ctx[4].options.attachTo.on && create_if_block();\n    shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId: /*descriptionId*/ctx[2],\n        labelId: /*labelId*/ctx[3],\n        step: /*step*/ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": div_aria_describedby_value = !isUndefined( /*step*/ctx[4].options.text) ? /*descriptionId*/ctx[2] : null\n    }, {\n      \"aria-labelledby\": div_aria_labelledby_value = /*step*/ctx[4].options.title ? /*labelId*/ctx[3] : null\n    }, /*dataStepId*/ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n        ctx[13](div);\n        current = true;\n        if (!mounted) {\n          dispose = listen(div, \"keydown\", /*handleKeyDown*/ctx[7]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref14 = _slicedToArray(_ref, 1),\n          dirty = _ref14[0];\n        if ( /*step*/ctx[4].options.arrow && /*step*/ctx[4].options.attachTo && /*step*/ctx[4].options.attachTo.element && /*step*/ctx[4].options.attachTo.on) {\n          if (if_block) ;else {\n            if_block = create_if_block();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n        var shepherdcontent_changes = {};\n        if (dirty & /*descriptionId*/4) shepherdcontent_changes.descriptionId = /*descriptionId*/ctx[2];\n        if (dirty & /*labelId*/8) shepherdcontent_changes.labelId = /*labelId*/ctx[3];\n        if (dirty & /*step*/16) shepherdcontent_changes.step = /*step*/ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty & /*step, descriptionId*/20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined( /*step*/ctx[4].options.text) ? /*descriptionId*/ctx[2] : null)) && {\n          \"aria-describedby\": div_aria_describedby_value\n        }, (!current || dirty & /*step, labelId*/24 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*step*/ctx[4].options.title ? /*labelId*/ctx[3] : null)) && {\n          \"aria-labelledby\": div_aria_labelledby_value\n        }, dirty & /*dataStepId*/2 && /*dataStepId*/ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n        ctx[13](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n  function getClassesArray(classes) {\n    return classes.split(' ').filter(function (className) {\n      return !!className.length;\n    });\n  }\n  function instance$1($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n      element = $$props.element,\n      descriptionId = $$props.descriptionId,\n      firstFocusableElement = $$props.firstFocusableElement,\n      focusableElements = $$props.focusableElements,\n      labelId = $$props.labelId,\n      lastFocusableElement = $$props.lastFocusableElement,\n      step = $$props.step,\n      dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n    var getElement = function getElement() {\n      return element;\n    };\n    onMount(function () {\n      // Get all elements that are focusable\n      $$invalidate(1, dataStepId = _defineProperty({}, \"data-\".concat(classPrefix, \"shepherd-step-id\"), step.id));\n      $$invalidate(9, focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]'));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n        if (oldClasses.length) {\n          var _element$classList;\n          (_element$classList = element.classList).remove.apply(_element$classList, _toConsumableArray(oldClasses));\n        }\n      }\n    }\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n        if (newClasses.length) {\n          var _element$classList2;\n          (_element$classList2 = element.classList).add.apply(_element$classList2, _toConsumableArray(newClasses));\n        }\n      }\n    }\n\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n        tour = _step.tour;\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          }\n          // Backward tab\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains('shepherd-element')) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n          break;\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            step.cancel();\n          }\n          break;\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.back();\n          }\n          break;\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.next();\n          }\n          break;\n      }\n    };\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('classPrefix' in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('descriptionId' in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if ('firstFocusableElement' in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if ('focusableElements' in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if ('labelId' in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if ('lastFocusableElement' in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if ('step' in $$props) $$invalidate(4, step = $$props.step);\n      if ('dataStepId' in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];\n  }\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent8) {\n    _inherits(Shepherd_element, _SvelteComponent8);\n    var _super8 = _createSuper(Shepherd_element);\n    function Shepherd_element(options) {\n      var _this11;\n      _classCallCheck(this, Shepherd_element);\n      _this11 = _super8.call(this);\n      init(_assertThisInitialized(_this11), options, instance$1, create_fragment$1, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this11;\n    }\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n    return Shepherd_element;\n  }(SvelteComponent);\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inherits(Step, _Evented);\n    var _super9 = _createSuper(Step);\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {object} options.attachTo The element the step should be attached to on the page.\n     * An object with properties `element` and `on`.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you don’t specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.\n     * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).\n     * @param {string} options.attachTo.on The optional direction to place the FloatingUI tooltip relative to the element.\n     *   - Possible string values: 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel “✕” be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {number | { topLeft: number, bottomLeft: number, bottomRight: number, topRight: number }} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @param {object} options.floatingUIOptions Extra options to pass to FloatingUI\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @return {Step} The newly created Step instance\n     */\n    function Step(tour, options) {\n      var _this12;\n      _classCallCheck(this, Step);\n      if (options === void 0) {\n        options = {};\n      }\n      _this12 = _super9.call(this, tour, options);\n      _this12.tour = tour;\n      _this12.classPrefix = _this12.tour.options ? normalizePrefix(_this12.tour.options.classPrefix) : '';\n      _this12.styles = tour.styles;\n\n      /**\n       * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n       * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n       * @type {null|{}|{element, to}}\n       * @private\n       */\n      _this12._resolvedAttachTo = null;\n      autoBind(_assertThisInitialized(_this12));\n      _this12._setOptions(options);\n      return _possibleConstructorReturn(_this12, _assertThisInitialized(_this12));\n    }\n\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n    _createClass(Step, [{\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n\n      /**\n       * Remove the step, delete the step's element, and destroy the FloatingUI instance for the step.\n       * Triggers `destroy` event\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        destroyTooltip(this);\n        if (isHTMLElement$1(this.el)) {\n          this.el.remove();\n          this.el = null;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('destroy');\n      }\n\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n\n      /**\n       * Hide the step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n        if (this.el) {\n          this.el.hidden = true;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('hide');\n      }\n\n      /**\n       * Resolves attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_resolveAttachToOptions\",\n      value: function _resolveAttachToOptions() {\n        this._resolvedAttachTo = parseAttachTo(this);\n        return this._resolvedAttachTo;\n      }\n\n      /**\n       * A selector for resolved attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_getResolvedAttachToOptions\",\n      value: function _getResolvedAttachToOptions() {\n        if (this._resolvedAttachTo === null) {\n          return this._resolveAttachToOptions();\n        }\n        return this._resolvedAttachTo;\n      }\n\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.el && !this.el.hidden);\n      }\n\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this13 = this;\n        if (isFunction(this.options.beforeShowPromise)) {\n          return Promise.resolve(this.options.beforeShowPromise()).then(function () {\n            return _this13._show();\n          });\n        }\n        return Promise.resolve(this._show());\n      }\n\n      /**\n       * Updates the options of the step.\n       *\n       * @param {Object} options The options for the step\n       */\n    }, {\n      key: \"updateStepOptions\",\n      value: function updateStepOptions(options) {\n        Object.assign(this.options, options);\n        if (this.shepherdElementComponent) {\n          this.shepherdElementComponent.$set({\n            step: this\n          });\n        }\n      }\n\n      /**\n       * Returns the element for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n       */\n    }, {\n      key: \"getElement\",\n      value: function getElement() {\n        return this.el;\n      }\n\n      /**\n       * Returns the target for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n       */\n    }, {\n      key: \"getTarget\",\n      value: function getTarget() {\n        return this.target;\n      }\n\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @return {Element} The DOM element for the step tooltip\n       * @private\n       */\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var descriptionId = \"\".concat(this.id, \"-description\");\n        var labelId = \"\".concat(this.id, \"-label\");\n        this.shepherdElementComponent = new Shepherd_element({\n          target: this.tour.options.stepsContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            descriptionId: descriptionId,\n            labelId: labelId,\n            step: this,\n            styles: this.styles\n          }\n        });\n        return this.shepherdElementComponent.getElement();\n      }\n\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       * @private\n       */\n    }, {\n      key: \"_scrollTo\",\n      value: function _scrollTo(scrollToOptions) {\n        var _this$_getResolvedAtt = this._getResolvedAttachToOptions(),\n          element = _this$_getResolvedAtt.element;\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (isElement$1(element) && typeof element.scrollIntoView === 'function') {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n\n      /**\n       * _getClassOptions gets all possible classes for the step\n       * @param {Object} stepOptions The step specific options\n       * @returns {String} unique string from array of classes\n       * @private\n       */\n    }, {\n      key: \"_getClassOptions\",\n      value: function _getClassOptions(stepOptions) {\n        var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n        var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n        var allClasses = [].concat(_toConsumableArray(stepClasses.split(' ')), _toConsumableArray(defaultStepOptionsClasses.split(' ')));\n        var uniqClasses = new Set(allClasses);\n        return Array.from(uniqClasses).join(' ').trim();\n      }\n\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       * @private\n       */\n    }, {\n      key: \"_setOptions\",\n      value: function _setOptions(options) {\n        var _this14 = this;\n        if (options === void 0) {\n          options = {};\n        }\n        var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        tourOptions = cjs({}, tourOptions || {});\n        this.options = Object.assign({\n          arrow: true\n        }, tourOptions, options, mergeTooltipConfig(tourOptions, options));\n        var when = this.options.when;\n        this.options.classes = this._getClassOptions(options);\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uuid());\n        if (when) {\n          Object.keys(when).forEach(function (event) {\n            _this14.on(event, when[event], _this14);\n          });\n        }\n      }\n\n      /**\n       * Create the element and set up the FloatingUI instance\n       * @private\n       */\n    }, {\n      key: \"_setupElements\",\n      value: function _setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n        this.el = this._createTooltipContent();\n        if (this.options.advanceOn) {\n          bindAdvance(this);\n        }\n\n        // The tooltip implementation details are handled outside of the Step\n        // object.\n        setupTooltip(this);\n      }\n\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a FloatingUI instance for the tooltip, then triggers `show`.\n       * @private\n       */\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this15 = this;\n        this.trigger('before-show');\n\n        // Force resolve to make sure the options are updated on subsequent shows.\n        this._resolveAttachToOptions();\n        this._setupElements();\n        if (!this.tour.modal) {\n          this.tour._setupModal();\n        }\n        this.tour.modal.setupForStep(this);\n        this._styleTargetElementForStep(this);\n        this.el.hidden = false;\n\n        // start scrolling to target before showing the step\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this15._scrollTo(_this15.options.scrollTo);\n          });\n        }\n        this.el.hidden = false;\n        var content = this.shepherdElementComponent.getElement();\n        var target = this.target || document.body;\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-enabled\"));\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-target\"));\n        content.classList.add('shepherd-enabled');\n        this.trigger('show');\n      }\n\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = step.target;\n        if (!targetElement) {\n          return;\n        }\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n        targetElement.classList.remove('shepherd-target-click-disabled');\n        if (step.options.canClickTarget === false) {\n          targetElement.classList.add('shepherd-target-click-disabled');\n        }\n      }\n\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        var target = this.target || document.body;\n        if (this.options.highlightClass) {\n          target.classList.remove(this.options.highlightClass);\n        }\n        target.classList.remove('shepherd-target-click-disabled', \"\".concat(this.classPrefix, \"shepherd-enabled\"), \"\".concat(this.classPrefix, \"shepherd-target\"));\n      }\n    }]);\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number | { topLeft: number, topRight: number, bottomRight: number, bottomLeft: number }} [r=0] - Corner Radius. Keep this smaller than half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n  function makeOverlayPath(_ref) {\n    var width = _ref.width,\n      height = _ref.height,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      _ref$r = _ref.r,\n      r = _ref$r === void 0 ? 0 : _ref$r;\n    var _window = window,\n      w = _window.innerWidth,\n      h = _window.innerHeight;\n    var _ref15 = typeof r === 'number' ? {\n        topLeft: r,\n        topRight: r,\n        bottomRight: r,\n        bottomLeft: r\n      } : r,\n      _ref15$topLeft = _ref15.topLeft,\n      topLeft = _ref15$topLeft === void 0 ? 0 : _ref15$topLeft,\n      _ref15$topRight = _ref15.topRight,\n      topRight = _ref15$topRight === void 0 ? 0 : _ref15$topRight,\n      _ref15$bottomRight = _ref15.bottomRight,\n      bottomRight = _ref15$bottomRight === void 0 ? 0 : _ref15$bottomRight,\n      _ref15$bottomLeft = _ref15.bottomLeft,\n      bottomLeft = _ref15$bottomLeft === void 0 ? 0 : _ref15$bottomLeft;\n    return \"M\".concat(w, \",\").concat(h, \"H0V0H\").concat(w, \"V\").concat(h, \"ZM\").concat(x + topLeft, \",\").concat(y, \"a\").concat(topLeft, \",\").concat(topLeft, \",0,0,0-\").concat(topLeft, \",\").concat(topLeft, \"V\").concat(height + y - bottomLeft, \"a\").concat(bottomLeft, \",\").concat(bottomLeft, \",0,0,0,\").concat(bottomLeft, \",\").concat(bottomLeft, \"H\").concat(width + x - bottomRight, \"a\").concat(bottomRight, \",\").concat(bottomRight, \",0,0,0,\").concat(bottomRight, \"-\").concat(bottomRight, \"V\").concat(y + topRight, \"a\").concat(topRight, \",\").concat(topRight, \",0,0,0-\").concat(topRight, \"-\").concat(topRight, \"Z\");\n  }\n\n  /* src/js/components/shepherd-modal.svelte generated by Svelte v3.58.0 */\n  function create_fragment(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\", /*pathDefinition*/ctx[2]);\n        attr(svg, \"class\", svg_class_value = \"\".concat( /*modalIsVisible*/ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"));\n      },\n      m: function m(target, anchor) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n        ctx[11](svg);\n        if (!mounted) {\n          dispose = listen(svg, \"touchmove\", /*_preventModalOverlayTouch*/ctx[3]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref16 = _slicedToArray(_ref, 1),\n          dirty = _ref16[0];\n        if (dirty & /*pathDefinition*/4) {\n          attr(path, \"d\", /*pathDefinition*/ctx[2]);\n        }\n        if (dirty & /*modalIsVisible*/2 && svg_class_value !== (svg_class_value = \"\".concat( /*modalIsVisible*/ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"))) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n        ctx[11](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n    return _getScrollParent(element.parentElement);\n  }\n\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n    return {\n      y: top,\n      height: height\n    };\n  }\n  function instance($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n      openingProperties = $$props.openingProperties;\n    uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n    var getElement = function getElement() {\n      return element;\n    };\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n    function hide() {\n      $$invalidate(1, modalIsVisible = false);\n\n      // Ensure we cleanup all event listeners when we hide the modal\n      _cleanupStepEventListeners();\n    }\n    function positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, targetElement) {\n      if (modalOverlayOpeningPadding === void 0) {\n        modalOverlayOpeningPadding = 0;\n      }\n      if (modalOverlayOpeningRadius === void 0) {\n        modalOverlayOpeningRadius = 0;\n      }\n      if (targetElement) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n          y = _getVisibleHeight2.y,\n          height = _getVisibleHeight2.height;\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n          x = _targetElement$getBou.x,\n          width = _targetElement$getBou.width,\n          left = _targetElement$getBou.left;\n\n        // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      } else {\n        closeModalOpening();\n      }\n    }\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n        show();\n      } else {\n        hide();\n      }\n    }\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n      window.removeEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n    function _styleForStep(step) {\n      var _step$options = step.options,\n        modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n      var scrollParent = _getScrollParent(step.target);\n\n      // Setup recursive function to call requestAnimationFrame to update the modal opening position\n      var rafLoop = function rafLoop() {\n        rafId = undefined;\n        positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);\n        rafId = requestAnimationFrame(rafLoop);\n      };\n      rafLoop();\n      _addStepEventListeners();\n    }\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('openingProperties' in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*openingProperties*/16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];\n  }\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent9) {\n    _inherits(Shepherd_modal, _SvelteComponent9);\n    var _super10 = _createSuper(Shepherd_modal);\n    function Shepherd_modal(options) {\n      var _this16;\n      _classCallCheck(this, Shepherd_modal);\n      _this16 = _super10.call(this);\n      init(_assertThisInitialized(_this16), options, instance, create_fragment, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModal: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this16;\n    }\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModal\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n    return Shepherd_modal;\n  }(SvelteComponent);\n  var Shepherd = new Evented();\n\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n  var Tour = /*#__PURE__*/function (_Evented2) {\n    _inherits(Tour, _Evented2);\n    var _super11 = _createSuper(Tour);\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean | function(): boolean | Promise<boolean> | function(): Promise<boolean>} options.confirmCancel If true, will issue a `window.confirm` before cancelling.\n     * If it is a function(support Async Function), it will be called and wait for the return value, and will only be cancelled if the value returned is true\n     * @param {string} options.confirmCancelMessage The message to display in the `window.confirm` dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n     * If not set, the steps will be appended to `document.body`.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n    function Tour(options) {\n      var _this17;\n      _classCallCheck(this, Tour);\n      if (options === void 0) {\n        options = {};\n      }\n      _this17 = _super11.call(this, options);\n      autoBind(_assertThisInitialized(_this17));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this17.options = Object.assign({}, defaultTourOptions, options);\n      _this17.classPrefix = normalizePrefix(_this17.options.classPrefix);\n      _this17.steps = [];\n      _this17.addSteps(_this17.options.steps);\n\n      // Pass these events onto the global Shepherd object\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this17.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this17);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n      _this17._setTourID();\n      return _possibleConstructorReturn(_this17, _assertThisInitialized(_this17));\n    }\n\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(options, index) {\n        var step = options;\n        if (!(step instanceof Step)) {\n          step = new Step(this, step);\n        } else {\n          step.tour = this;\n        }\n        if (!isUndefined(index)) {\n          this.steps.splice(index, 0, step);\n        } else {\n          this.steps.push(step);\n        }\n        return step;\n      }\n\n      /**\n       * Add multiple steps to the tour\n       * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n       */\n    }, {\n      key: \"addSteps\",\n      value: function addSteps(steps) {\n        var _this18 = this;\n        if (Array.isArray(steps)) {\n          steps.forEach(function (step) {\n            _this18.addStep(step);\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Go to the previous step in the tour\n       */\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n\n      /**\n       * Calls _done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       * If `confirmCancel` is a function, will call it and wait for the return value,\n       * and only cancel when the value returned is true\n       */\n    }, {\n      key: \"cancel\",\n      value: function () {\n        var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n          var confirmCancelIsFunction, cancelMessage, stopTour;\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!this.options.confirmCancel) {\n                  _context6.next = 14;\n                  break;\n                }\n                confirmCancelIsFunction = typeof this.options.confirmCancel === 'function';\n                cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n                if (!confirmCancelIsFunction) {\n                  _context6.next = 9;\n                  break;\n                }\n                _context6.next = 6;\n                return this.options.confirmCancel();\n              case 6:\n                _context6.t0 = _context6.sent;\n                _context6.next = 10;\n                break;\n              case 9:\n                _context6.t0 = window.confirm(cancelMessage);\n              case 10:\n                stopTour = _context6.t0;\n                if (stopTour) {\n                  this._done('cancel');\n                }\n                _context6.next = 15;\n                break;\n              case 14:\n                this._done('cancel');\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }, _callee6, this);\n        }));\n        function cancel() {\n          return _cancel.apply(this, arguments);\n        }\n        return cancel;\n      }()\n      /**\n       * Calls _done() triggering the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._done('complete');\n      }\n\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n\n      /**\n       * Hide the current step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this19 = this;\n        var current = this.getCurrentStep();\n\n        // Find the step, destroy it and remove it from this.steps\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n            step.destroy();\n            _this19.steps.splice(i, 1);\n            return true;\n          }\n        });\n        if (current && current.id === name) {\n          this.currentStep = undefined;\n\n          // If we have steps left, show the first one, otherwise just cancel the tour\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n    }, {\n      key: \"show\",\n      value: function show(key, forward) {\n        if (key === void 0) {\n          key = 0;\n        }\n        if (forward === void 0) {\n          forward = true;\n        }\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n        if (step) {\n          this._updateStateBeforeShow();\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn();\n\n          // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n\n      /**\n       * Start the tour\n       */\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start');\n\n        // Save the focused element before the tour opens\n        this.focusedElBeforeOpen = document.activeElement;\n        this.currentStep = null;\n        this._setupModal();\n        this._setupActiveTour();\n        this.next();\n      }\n\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       * @private\n       */\n    }, {\n      key: \"_done\",\n      value: function _done(event) {\n        var index = this.steps.indexOf(this.currentStep);\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n        cleanupSteps(this);\n        this.trigger(event, {\n          index: index\n        });\n        Shepherd.activeTour = null;\n        this.trigger('inactive', {\n          tour: this\n        });\n        if (this.modal) {\n          this.modal.hide();\n        }\n        if (event === 'cancel' || event === 'complete') {\n          if (this.modal) {\n            var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n            if (modalContainer) {\n              modalContainer.remove();\n            }\n          }\n        }\n\n        // Focus the element that was focused before the tour started\n        if (isHTMLElement$1(this.focusedElBeforeOpen)) {\n          this.focusedElBeforeOpen.focus();\n        }\n      }\n\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n\n      /**\n       * _setupModal create the modal container and instance\n       * @private\n       */\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        this.modal = new Shepherd_modal({\n          target: this.options.modalContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            styles: this.styles\n          }\n        });\n      }\n\n      /**\n       * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          var nextIndex = forward ? index + 1 : index - 1;\n          this.show(nextIndex, forward);\n        }\n      }\n\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        this.id = \"\".concat(tourName, \"--\").concat(uuid());\n      }\n    }]);\n    return Tour;\n  }(Evented);\n  var isServerSide = typeof window === 'undefined';\n  var NoOp = /*#__PURE__*/_createClass(function NoOp() {\n    _classCallCheck(this, NoOp);\n  });\n  if (isServerSide) {\n    Object.assign(Shepherd, {\n      Tour: NoOp,\n      Step: NoOp\n    });\n  } else {\n    Object.assign(Shepherd, {\n      Tour: Tour,\n      Step: Step\n    });\n  }\n  return Shepherd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQUVBLElBQUlBLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFpQkEsQ0FBQ0MsS0FBSyxFQUFFO0lBQ3pELE9BQU9DLGVBQWUsQ0FBQ0QsS0FBSyxDQUFDLElBQ3pCLENBQUNFLFNBQVMsQ0FBQ0YsS0FBSyxDQUFDO0VBQ3RCLENBQUM7RUFFRCxTQUFTQyxlQUFlQSxDQUFDRCxLQUFLLEVBQUU7SUFDL0IsT0FBTyxDQUFDLENBQUNBLEtBQUssSUFBSUcsT0FBQSxDQUFPSCxLQUFLLE1BQUssUUFBUTtFQUM1QztFQUVBLFNBQVNFLFNBQVNBLENBQUNGLEtBQUssRUFBRTtJQUN6QixJQUFJSSxXQUFXLEdBQUdDLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1IsS0FBSyxDQUFDO0lBRXZELE9BQU9JLFdBQVcsS0FBSyxpQkFBaUIsSUFDcENBLFdBQVcsS0FBSyxlQUFlLElBQy9CSyxjQUFjLENBQUNULEtBQUssQ0FBQztFQUMxQjs7RUFFQTtFQUNBLElBQUlVLFlBQVksR0FBRyxPQUFPQyxNQUFNLEtBQUssVUFBVSxJQUFJQSxNQUFNLENBQUNDLEdBQUc7RUFDN0QsSUFBSUMsa0JBQWtCLEdBQUdILFlBQVksR0FBR0MsTUFBTSxDQUFDQyxHQUFHLENBQUMsZUFBZSxDQUFDLEdBQUcsTUFBTTtFQUU1RSxTQUFTSCxjQUFjQSxDQUFDVCxLQUFLLEVBQUU7SUFDOUIsT0FBT0EsS0FBSyxDQUFDYyxRQUFRLEtBQUtELGtCQUFrQjtFQUM3QztFQUVBLFNBQVNFLFdBQVdBLENBQUNDLEdBQUcsRUFBRTtJQUN6QixPQUFPQyxLQUFLLENBQUNDLE9BQU8sQ0FBQ0YsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUU7RUFDcEM7RUFFQSxTQUFTRyw2QkFBNkJBLENBQUNuQixL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QUFBLE9BQUEyd0IsSUFBQTtFQUFBLEVBcFh3QnYwQixPQUFPO0VDaEJqQyxJQUFNZzNCLFlBQVksR0FBRyxPQUFPcGlCLE1BQU0sS0FBSyxXQUFXO0VBQUEsSUFFNUNxaUIsSUFBSSxnQkFBQS8yQixZQUFBLENBQ1IsU0FBQSsyQixLQUFBLEVBQWM7SUFBQWgzQixlQUFBLE9BQUFnM0IsSUFBQTtFQUFDO0VBR2pCLElBQUlELFlBQVksRUFBRTtJQUNoQmg3QixNQUFNLENBQUN5SCxNQUFNLENBQUM2d0IsUUFBUSxFQUFFO01BQUVDLElBQUksRUFBRTBDLElBQUk7TUFBRWpKLElBQUksRUFBRWlKO0lBQUssQ0FBQyxDQUFDO0VBQ3JELENBQUMsTUFBTTtJQUNMajdCLE1BQU0sQ0FBQ3lILE1BQU0sQ0FBQzZ3QixRQUFRLEVBQUU7TUFBRUMsSUFBSSxFQUFKQSxJQUFJO01BQUV2RyxJQUFBLEVBQUFBO0lBQUssQ0FBQyxDQUFDO0VBQ3pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU25lYXQvLi4vLi4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcz81YWQxIiwid2VicGFjazovL1NuZWF0Ly4uLy4uL3NyYy9qcy91dGlscy90eXBlLWNoZWNrLmpzPzFmZDMiLCJ3ZWJwYWNrOi8vU25lYXQvLi4vLi4vc3JjL2pzL2V2ZW50ZWQuanM/OTczZCIsIndlYnBhY2s6Ly9TbmVhdC8uLi8uLi9zcmMvanMvdXRpbHMvYXV0by1iaW5kLmpzPzdiMTYiLCJ3ZWJwYWNrOi8vU25lYXQvLi4vLi4vc3JjL2pzL3V0aWxzL2JpbmQuanM/YTUxNSIsIndlYnBhY2s6Ly9TbmVhdC8uLi8uLi9zcmMvanMvdXRpbHMvZ2VuZXJhbC5qcz9iNDJkIiwid2VicGFjazovL1NuZWF0Ly4uLy4uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvY29yZS9kaXN0L2Zsb2F0aW5nLXVpLmNvcmUuZXNtLmpzPzBjY2UiLCJ3ZWJwYWNrOi8vU25lYXQvLi4vLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9kb20vZGlzdC9mbG9hdGluZy11aS5kb20uZXNtLmpzPzEzNDMiLCJ3ZWJwYWNrOi8vU25lYXQvLi4vLi4vc3JjL2pzL3V0aWxzL2Zsb2F0aW5nLXVpLmpzP2VjZGMiLCJ3ZWJwYWNrOi8vU25lYXQvLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9pbnRlcm5hbC9pbmRleC5tanM/MDRmNyIsIndlYnBhY2s6Ly9TbmVhdC8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1idXR0b24uc3ZlbHRlPzc4YzUiLCJ3ZWJwYWNrOi8vU25lYXQvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtZm9vdGVyLnN2ZWx0ZT9hZjQ3Iiwid2VicGFjazovL1NuZWF0Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWNhbmNlbC1pY29uLnN2ZWx0ZT83OWMxIiwid2VicGFjazovL1NuZWF0Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLXRpdGxlLnN2ZWx0ZT9jYWMyIiwid2VicGFjazovL1NuZWF0Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWhlYWRlci5zdmVsdGU/MmYyNyIsIndlYnBhY2s6Ly9TbmVhdC8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC10ZXh0LnN2ZWx0ZT9hY2VmIiwid2VicGFjazovL1NuZWF0Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWNvbnRlbnQuc3ZlbHRlP2YwN2UiLCJ3ZWJwYWNrOi8vU25lYXQvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtZWxlbWVudC5zdmVsdGU/YjU4NiIsIndlYnBhY2s6Ly9TbmVhdC8uLi8uLi9zcmMvanMvc3RlcC5qcz9hZDhkIiwid2VicGFjazovL1NuZWF0Ly4uLy4uL3NyYy9qcy91dGlscy9jbGVhbnVwLmpzPzZkY2EiLCJ3ZWJwYWNrOi8vU25lYXQvLi4vLi4vc3JjL2pzL3V0aWxzL292ZXJsYXktcGF0aC5qcz9jZDUzIiwid2VicGFjazovL1NuZWF0Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLW1vZGFsLnN2ZWx0ZT9mNTRiIiwid2VicGFjazovL1NuZWF0Ly4uLy4uL3NyYy9qcy90b3VyLmpzPzM5NTEiLCJ3ZWJwYWNrOi8vU25lYXQvLi4vLi4vc3JjL2pzL3NoZXBoZXJkLmpzPzUxNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRyZXR1cm4gc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxufVxuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKVxuXHRcdDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMuY3VzdG9tTWVyZ2UpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlXG5cdH1cblx0dmFyIGN1c3RvbU1lcmdlID0gb3B0aW9ucy5jdXN0b21NZXJnZShrZXkpO1xuXHRyZXR1cm4gdHlwZW9mIGN1c3RvbU1lcmdlID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWVyZ2UgOiBkZWVwbWVyZ2Vcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBzeW1ib2wpXG5cdFx0fSlcblx0XHQ6IFtdXG59XG5cbmZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLmNvbmNhdChnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5IGluIG9iamVjdFxuXHR9IGNhdGNoKF8pIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG4vLyBQcm90ZWN0cyBmcm9tIHByb3RvdHlwZSBwb2lzb25pbmcgYW5kIHVuZXhwZWN0ZWQgbWVyZ2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuZnVuY3Rpb24gcHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkge1xuXHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0JiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkgLy8gdW5zYWZlIGlmIHRoZXkgZXhpc3QgdXAgdGhlIHByb3RvdHlwZSBjaGFpbixcblx0XHRcdCYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwga2V5KSkgLy8gYW5kIGFsc28gdW5zYWZlIGlmIHRoZXkncmUgbm9uZW51bWVyYWJsZS5cbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cblx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0Ly8gaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgaXQuIFRoZSBjYWxsZXIgbWF5IG5vdCByZXBsYWNlIGl0LlxuXHRvcHRpb25zLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQ7XG5cblx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuXHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXknKVxuXHR9XG5cblx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zKVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwbWVyZ2VfMTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgRWxlbWVudGAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhbiBFbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBIVE1MRWxlbWVudGAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhbiBIVE1MRWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBhcmFtIHRvIGNoZWNrIGlmIGl0IGlzIGEgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2snO1xuXG5leHBvcnQgY2xhc3MgRXZlbnRlZCB7XG4gIG9uKGV2ZW50LCBoYW5kbGVyLCBjdHgsIG9uY2UgPSBmYWxzZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSkge1xuICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5nc1tldmVudF0pKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5wdXNoKHsgaGFuZGxlciwgY3R4LCBvbmNlIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvbmNlKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgaGFuZGxlciwgY3R4LCB0cnVlKTtcbiAgfVxuXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSB8fCBpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzW2V2ZW50XSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSkge1xuICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbZXZlbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5mb3JFYWNoKChiaW5kaW5nLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoYmluZGluZy5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0cmlnZ2VyKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSAmJiB0aGlzLmJpbmRpbmdzW2V2ZW50XSkge1xuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uZm9yRWFjaCgoYmluZGluZywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIGhhbmRsZXIsIG9uY2UgfSA9IGJpbmRpbmc7XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IGN0eCB8fCB0aGlzO1xuXG4gICAgICAgIGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cbiAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiLyoqXG4gKiBCaW5kcyBhbGwgdGhlIG1ldGhvZHMgb24gYSBKUyBDbGFzcyB0byB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzLlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYXV0by1iaW5kXG4gKiBAcGFyYW0ge29iamVjdH0gc2VsZiBUaGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgY2xhc3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b0JpbmQoc2VsZikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2VsZi5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbCA9IHNlbGZba2V5XTtcbiAgICBpZiAoa2V5ICE9PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNlbGZba2V5XSA9IHZhbC5iaW5kKHNlbGYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuL3R5cGUtY2hlY2snO1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIGhhbmRsZXIgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBhZHZhbmNlIHRoZSB0b3VyXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfc2V0dXBBZHZhbmNlT25IYW5kbGVyKHNlbGVjdG9yLCBzdGVwKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBpZiAoc3RlcC5pc09wZW4oKSkge1xuICAgICAgY29uc3QgdGFyZ2V0SXNFbCA9IHN0ZXAuZWwgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gc3RlcC5lbDtcbiAgICAgIGNvbnN0IHRhcmdldElzU2VsZWN0b3IgPVxuICAgICAgICAhaXNVbmRlZmluZWQoc2VsZWN0b3IpICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQubWF0Y2hlcyhzZWxlY3Rvcik7XG5cbiAgICAgIGlmICh0YXJnZXRJc1NlbGVjdG9yIHx8IHRhcmdldElzRWwpIHtcbiAgICAgICAgc3RlcC50b3VyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQmluZCB0aGUgZXZlbnQgaGFuZGxlciBmb3IgYWR2YW5jZU9uXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRBZHZhbmNlKHN0ZXApIHtcbiAgLy8gQW4gZW1wdHkgc2VsZWN0b3IgbWF0Y2hlcyB0aGUgc3RlcCBlbGVtZW50XG4gIGNvbnN0IHsgZXZlbnQsIHNlbGVjdG9yIH0gPSBzdGVwLm9wdGlvbnMuYWR2YW5jZU9uIHx8IHt9O1xuICBpZiAoZXZlbnQpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gX3NldHVwQWR2YW5jZU9uSGFuZGxlcihzZWxlY3Rvciwgc3RlcCk7XG5cbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBhbHNvIGJpbmQvdW5iaW5kIG9uIHNob3cvaGlkZVxuICAgIGxldCBlbDtcbiAgICB0cnkge1xuICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoc2VsZWN0b3IpICYmICFlbCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBObyBlbGVtZW50IHdhcyBmb3VuZCBmb3IgdGhlIHNlbGVjdG9yIHN1cHBsaWVkIHRvIGFkdmFuY2VPbjogJHtzZWxlY3Rvcn1gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgc3RlcC5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICBzdGVwLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcbiAgICAgICdhZHZhbmNlT24gd2FzIGRlZmluZWQsIGJ1dCBubyBldmVudCBuYW1lIHdhcyBwYXNzZWQuJ1xuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi90eXBlLWNoZWNrJztcblxuLyoqXG4gKiBFbnN1cmUgY2xhc3MgcHJlZml4IGVuZHMgaW4gYC1gXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gcHJlcGVuZCB0byB0aGUgY2xhc3MgbmFtZXMgZ2VuZXJhdGVkIGJ5IG5hbm8tY3NzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcmVmaXggZW5kaW5nIGluIGAtYFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUHJlZml4KHByZWZpeCkge1xuICBpZiAoIWlzU3RyaW5nKHByZWZpeCkgfHwgcHJlZml4ID09PSAnJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBwcmVmaXguY2hhckF0KHByZWZpeC5sZW5ndGggLSAxKSAhPT0gJy0nID8gYCR7cHJlZml4fS1gIDogcHJlZml4O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIGF0dGFjaFRvIG9wdGlvbnMsIGNvbnZlcnRpbmcgZWxlbWVudCBvcHRpb24gdmFsdWUgdG8gYSBxdWFsaWZpZWQgSFRNTEVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHt7fXx7ZWxlbWVudCwgb259fVxuICogYGVsZW1lbnRgIGlzIGEgcXVhbGlmaWVkIEhUTUwgRWxlbWVudFxuICogYG9uYCBpcyBhIHN0cmluZyBwb3NpdGlvbiB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBdHRhY2hUbyhzdGVwKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBzdGVwLm9wdGlvbnMuYXR0YWNoVG8gfHwge307XG4gIGNvbnN0IHJldHVybk9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICBpZiAoaXNGdW5jdGlvbihyZXR1cm5PcHRzLmVsZW1lbnQpKSB7XG4gICAgLy8gQmluZCB0aGUgY2FsbGJhY2sgdG8gc3RlcCBzbyB0aGF0IGl0IGhhcyBhY2Nlc3MgdG8gdGhlIG9iamVjdCwgdG8gZW5hYmxlIHJ1bm5pbmcgYWRkaXRpb25hbCBsb2dpY1xuICAgIHJldHVybk9wdHMuZWxlbWVudCA9IHJldHVybk9wdHMuZWxlbWVudC5jYWxsKHN0ZXApO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKHJldHVybk9wdHMuZWxlbWVudCkpIHtcbiAgICAvLyBDYW4ndCBvdmVycmlkZSB0aGUgZWxlbWVudCBpbiB1c2VyIG9wdHMgcmVmZXJlbmNlIGJlY2F1c2Ugd2UgY2FuJ3RcbiAgICAvLyBndWFyYW50ZWUgdGhhdCB0aGUgZWxlbWVudCB3aWxsIGV4aXN0IGluIHRoZSBmdXR1cmUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybk9wdHMuZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocmV0dXJuT3B0cy5lbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIGlmICghcmV0dXJuT3B0cy5lbGVtZW50KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgVGhlIGVsZW1lbnQgZm9yIHRoaXMgU2hlcGhlcmQgc3RlcCB3YXMgbm90IGZvdW5kICR7b3B0aW9ucy5lbGVtZW50fWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVybk9wdHM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdGVwIHNob3VsZCBiZSBjZW50ZXJlZCBvciBub3QuIERvZXMgbm90IHRyaWdnZXIgYXR0YWNoVG8uZWxlbWVudCBldmFsdWF0aW9uLCBtYWtpbmcgaXQgYSBwdXJlXG4gKiBhbHRlcm5hdGl2ZSBmb3IgdGhlIGRlcHJlY2F0ZWQgc3RlcC5pc0NlbnRlcmVkKCkgbWV0aG9kLlxuICogQHBhcmFtIHJlc29sdmVkQXR0YWNoVG9PcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZENlbnRlclN0ZXAocmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMpIHtcbiAgaWYgKFxuICAgIHJlc29sdmVkQXR0YWNoVG9PcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICByZXNvbHZlZEF0dGFjaFRvT3B0aW9ucyA9PT0gbnVsbFxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAhcmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMuZWxlbWVudCB8fCAhcmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMub247XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgdW5pcXVlIGlkIGZvciBzdGVwcywgdG91cnMsIG1vZGFscywgZXRjXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dWlkKCkge1xuICBsZXQgZCA9IERhdGUubm93KCk7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgY29uc3QgciA9IChkICsgTWF0aC5yYW5kb20oKSAqIDE2KSAlIDE2IHwgMDtcbiAgICBkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XG4gIH0pO1xufVxuIiwiZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aEZyb21BeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cblxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuXG5mdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmNsdWRlcyhnZXRTaWRlKHBsYWNlbWVudCkpID8gJ3gnIDogJ3knO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChfcmVmLCBwbGFjZW1lbnQsIHJ0bCkge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRMZW5ndGhGcm9tQXhpcyhtYWluQXhpcyk7XG4gIGNvbnN0IGNvbW1vbkFsaWduID0gcmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gZmxvYXRpbmdbbGVuZ3RoXSAvIDI7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBtYWluQXhpcyA9PT0gJ3gnO1xuICBsZXQgY29vcmRzO1xuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGZsb2F0aW5nLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBmbG9hdGluZy53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuICBzd2l0Y2ggKGdldEFsaWdubWVudChwbGFjZW1lbnQpKSB7XG4gICAgY2FzZSAnc3RhcnQnOlxuICAgICAgY29vcmRzW21haW5BeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW21haW5BeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSByZWZlcmVuY2UgZWxlbWVudCB3aGVuIGl0IGlzIGdpdmVuIGEgY2VydGFpbiBwb3NpdGlvbmluZyBzdHJhdGVneS5cbiAqXG4gKiBUaGlzIGV4cG9ydCBkb2VzIG5vdCBoYXZlIGFueSBgcGxhdGZvcm1gIGludGVyZmFjZSBsb2dpYy4gWW91IHdpbGwgbmVlZCB0b1xuICogd3JpdGUgb25lIGZvciB0aGUgcGxhdGZvcm0geW91IGFyZSB1c2luZyBGbG9hdGluZyBVSSB3aXRoLlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSBhc3luYyAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHZhbGlkTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAocGxhdGZvcm0gPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5lcnJvcihbJ0Zsb2F0aW5nIFVJOiBgcGxhdGZvcm1gIHByb3BlcnR5IHdhcyBub3QgcGFzc2VkIHRvIGNvbmZpZy4gSWYgeW91JywgJ3dhbnQgdG8gdXNlIEZsb2F0aW5nIFVJIG9uIHRoZSB3ZWIsIGluc3RhbGwgQGZsb2F0aW5nLXVpL2RvbScsICdpbnN0ZWFkIG9mIHRoZSAvY29yZSBwYWNrYWdlLiBPdGhlcndpc2UsIHlvdSBjYW4gY3JlYXRlIHlvdXIgb3duJywgJ2BwbGF0Zm9ybWA6IGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvcGxhdGZvcm0nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgICBpZiAodmFsaWRNaWRkbGV3YXJlLmZpbHRlcihfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIG5hbWUgPT09ICdhdXRvUGxhY2VtZW50JyB8fCBuYW1lID09PSAnZmxpcCc7XG4gICAgfSkubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFsnRmxvYXRpbmcgVUk6IGR1cGxpY2F0ZSBgZmxpcGAgYW5kL29yIGBhdXRvUGxhY2VtZW50YCBtaWRkbGV3YXJlJywgJ2RldGVjdGVkLiBUaGlzIHdpbGwgbGVhZCB0byBhbiBpbmZpbml0ZSBsb29wLiBFbnN1cmUgb25seSBvbmUgb2YnLCAnZWl0aGVyIGhhcyBiZWVuIHBhc3NlZCB0byB0aGUgYG1pZGRsZXdhcmVgIGFycmF5LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICAgIGlmICghcmVmZXJlbmNlIHx8ICFmbG9hdGluZykge1xuICAgICAgY29uc29sZS5lcnJvcihbJ0Zsb2F0aW5nIFVJOiBUaGUgcmVmZXJlbmNlIGFuZC9vciBmbG9hdGluZyBlbGVtZW50IHdhcyBub3QgZGVmaW5lZCcsICd3aGVuIGBjb21wdXRlUG9zaXRpb24oKWAgd2FzIGNhbGxlZC4gRW5zdXJlIHRoYXQgYm90aCBlbGVtZW50cyBoYXZlJywgJ2JlZW4gY3JlYXRlZCBhbmQgY2FuIGJlIG1lYXN1cmVkLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG4gIGxldCByZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pO1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHBsYWNlbWVudCwgcnRsKTtcbiAgbGV0IHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICBsZXQgbWlkZGxld2FyZURhdGEgPSB7fTtcbiAgbGV0IHJlc2V0Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkTWlkZGxld2FyZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBmblxuICAgIH0gPSB2YWxpZE1pZGRsZXdhcmVbaV07XG4gICAgY29uc3Qge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSBhd2FpdCBmbih7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4ID0gbmV4dFggIT0gbnVsbCA/IG5leHRYIDogeDtcbiAgICB5ID0gbmV4dFkgIT0gbnVsbCA/IG5leHRZIDogeTtcbiAgICBtaWRkbGV3YXJlRGF0YSA9IHtcbiAgICAgIC4uLm1pZGRsZXdhcmVEYXRhLFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIC4uLm1pZGRsZXdhcmVEYXRhW25hbWVdLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAocmVzZXRDb3VudCA+IDUwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBUaGUgbWlkZGxld2FyZSBsaWZlY3ljbGUgYXBwZWFycyB0byBiZSBydW5uaW5nIGluIGFuJywgJ2luZmluaXRlIGxvb3AuIFRoaXMgaXMgdXN1YWxseSBjYXVzZWQgYnkgYSBgcmVzZXRgIGNvbnRpbnVhbGx5JywgJ2JlaW5nIHJldHVybmVkIHdpdGhvdXQgYSBicmVhayBjb25kaXRpb24uJ10uam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc2V0ICYmIHJlc2V0Q291bnQgPD0gNTApIHtcbiAgICAgIHJlc2V0Q291bnQrKztcbiAgICAgIGlmICh0eXBlb2YgcmVzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChyZXNldC5wbGFjZW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZWZ1bFBsYWNlbWVudCA9IHJlc2V0LnBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZXQucmVjdHMpIHtcbiAgICAgICAgICByZWN0cyA9IHJlc2V0LnJlY3RzID09PSB0cnVlID8gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGZsb2F0aW5nLFxuICAgICAgICAgICAgc3RyYXRlZ3lcbiAgICAgICAgICB9KSA6IHJlc2V0LnJlY3RzO1xuICAgICAgICB9XG4gICAgICAgICh7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgc3RhdGVmdWxQbGFjZW1lbnQsIHJ0bCkpO1xuICAgICAgfVxuICAgICAgaSA9IC0xO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNpZGVPYmplY3RGcm9tUGFkZGluZyhwYWRkaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBleHBhbmRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIDoge1xuICAgIHRvcDogcGFkZGluZyxcbiAgICByaWdodDogcGFkZGluZyxcbiAgICBib3R0b206IHBhZGRpbmcsXG4gICAgbGVmdDogcGFkZGluZ1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZWN0LFxuICAgIHRvcDogcmVjdC55LFxuICAgIGxlZnQ6IHJlY3QueCxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICB2YXIgX2F3YWl0JHBsYXRmb3JtJGlzRWxlO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhdGZvcm0sXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IHN0YXRlO1xuICBjb25zdCB7XG4gICAgYm91bmRhcnkgPSAnY2xpcHBpbmdBbmNlc3RvcnMnLFxuICAgIHJvb3RCb3VuZGFyeSA9ICd2aWV3cG9ydCcsXG4gICAgZWxlbWVudENvbnRleHQgPSAnZmxvYXRpbmcnLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDBcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRTaWRlT2JqZWN0RnJvbVBhZGRpbmcocGFkZGluZyk7XG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/ICdyZWZlcmVuY2UnIDogJ2Zsb2F0aW5nJztcbiAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChhd2FpdCBwbGF0Zm9ybS5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgIGVsZW1lbnQ6ICgoX2F3YWl0JHBsYXRmb3JtJGlzRWxlID0gYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGVsZW1lbnQpKSkgIT0gbnVsbCA/IF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA6IHRydWUpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgKGF3YWl0IChwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpKSxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSkpO1xuICBjb25zdCByZWN0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyB7XG4gICAgLi4ucmVjdHMuZmxvYXRpbmcsXG4gICAgeCxcbiAgICB5XG4gIH0gOiByZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBvZmZzZXRTY2FsZSA9IChhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkpID8gKGF3YWl0IChwbGF0Zm9ybS5nZXRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0U2NhbGUob2Zmc2V0UGFyZW50KSkpIHx8IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfSA6IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfTtcbiAgY29uc3QgZWxlbWVudENsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0pIDogcmVjdCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIDtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IChjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3ApIC8gb2Zmc2V0U2NhbGUueSxcbiAgICBib3R0b206IChlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIC8gb2Zmc2V0U2NhbGUueSxcbiAgICBsZWZ0OiAoY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0KSAvIG9mZnNldFNjYWxlLngsXG4gICAgcmlnaHQ6IChlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQpIC8gb2Zmc2V0U2NhbGUueFxuICB9O1xufVxuXG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuXG5mdW5jdGlvbiB3aXRoaW4obWluJDEsIHZhbHVlLCBtYXgkMSkge1xuICByZXR1cm4gbWF4KG1pbiQxLCBtaW4odmFsdWUsIG1heCQxKSk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIC8vIFNpbmNlIGBlbGVtZW50YCBpcyByZXF1aXJlZCwgd2UgZG9uJ3QgUGFydGlhbDw+IHRoZSB0eXBlLlxuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYWRkaW5nID0gMFxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzXG4gICAgfSA9IHN0YXRlO1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGbG9hdGluZyBVSTogTm8gYGVsZW1lbnRgIHdhcyBwYXNzZWQgdG8gdGhlIGBhcnJvd2AgbWlkZGxld2FyZS4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFNpZGVPYmplY3RGcm9tUGFkZGluZyhwYWRkaW5nKTtcbiAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gICAgY29uc3QgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldExlbmd0aEZyb21BeGlzKGF4aXMpO1xuICAgIGNvbnN0IGFycm93RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudCk7XG4gICAgY29uc3QgaXNZQXhpcyA9IGF4aXMgPT09ICd5JztcbiAgICBjb25zdCBtaW5Qcm9wID0gaXNZQXhpcyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgIGNvbnN0IG1heFByb3AgPSBpc1lBeGlzID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgIGNvbnN0IGNsaWVudFByb3AgPSBpc1lBeGlzID8gJ2NsaWVudEhlaWdodCcgOiAnY2xpZW50V2lkdGgnO1xuICAgIGNvbnN0IGVuZERpZmYgPSByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSArIHJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIGNvb3Jkc1theGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgY29uc3Qgc3RhcnREaWZmID0gY29vcmRzW2F4aXNdIC0gcmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICAgIGNvbnN0IGFycm93T2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpKTtcbiAgICBsZXQgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXJyb3dPZmZzZXRQYXJlbnRbY2xpZW50UHJvcF0gOiAwO1xuXG4gICAgLy8gRE9NIHBsYXRmb3JtIGNhbiByZXR1cm4gYHdpbmRvd2AgYXMgdGhlIGBvZmZzZXRQYXJlbnRgLlxuICAgIGlmICghY2xpZW50U2l6ZSB8fCAhKGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChhcnJvd09mZnNldFBhcmVudCkpKSkge1xuICAgICAgY2xpZW50U2l6ZSA9IGVsZW1lbnRzLmZsb2F0aW5nW2NsaWVudFByb3BdIHx8IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBmbG9hdGluZyBlbGVtZW50IGlmIHRoZSBjZW50ZXJcbiAgICAvLyBwb2ludCBpcyBvdXRzaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgYm91bmRzLlxuICAgIGNvbnN0IG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gICAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGwgZW5vdWdoIHRoYXQgdGhlIGFycm93J3MgcGFkZGluZyBjYXVzZXMgaXQgdG9cbiAgICAvLyB0byBwb2ludCB0byBub3RoaW5nIGZvciBhbiBhbGlnbmVkIHBsYWNlbWVudCwgYWRqdXN0IHRoZSBvZmZzZXQgb2YgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCBpdHNlbGYuIFRoaXMgc3RvcHMgYHNoaWZ0KClgIGZyb20gdGFraW5nIGFjdGlvbiwgYnV0IGNhblxuICAgIC8vIGJlIHdvcmtlZCBhcm91bmQgYnkgY2FsbGluZyBpdCBhZ2FpbiBhZnRlciB0aGUgYGFycm93KClgIGlmIGRlc2lyZWQuXG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT0gbnVsbCAmJiBjZW50ZXIgIT0gb2Zmc2V0ICYmIHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdIC8gMiAtIChjZW50ZXIgPCBtaW4gPyBwYWRkaW5nT2JqZWN0W21pblByb3BdIDogcGFkZGluZ09iamVjdFttYXhQcm9wXSkgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgPCAwO1xuICAgIGNvbnN0IGFsaWdubWVudE9mZnNldCA9IHNob3VsZEFkZE9mZnNldCA/IGNlbnRlciA8IG1pbiA/IG1pbiAtIGNlbnRlciA6IG1heCAtIGNlbnRlciA6IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtheGlzXTogY29vcmRzW2F4aXNdIC0gYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgZGF0YToge1xuICAgICAgICBbYXhpc106IG9mZnNldCxcbiAgICAgICAgY2VudGVyT2Zmc2V0OiBjZW50ZXIgLSBvZmZzZXRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxsUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9zaWRlcy5yZWR1Y2UoKGFjYywgc2lkZSkgPT4gYWNjLmNvbmNhdChzaWRlLCBzaWRlICsgXCItc3RhcnRcIiwgc2lkZSArIFwiLWVuZFwiKSwgW10pO1xuXG5jb25zdCBvcHBvc2l0ZVNpZGVNYXAgPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgc2lkZSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuXG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpIHtcbiAgaWYgKHJ0bCA9PT0gdm9pZCAwKSB7XG4gICAgcnRsID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGxlbmd0aCA9IGdldExlbmd0aEZyb21BeGlzKG1haW5BeGlzKTtcbiAgbGV0IG1haW5BbGlnbm1lbnRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGFsaWdubWVudCA9PT0gKHJ0bCA/ICdlbmQnIDogJ3N0YXJ0JykgPyAncmlnaHQnIDogJ2xlZnQnIDogYWxpZ25tZW50ID09PSAnc3RhcnQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgaWYgKHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdID4gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXSkge1xuICAgIG1haW5BbGlnbm1lbnRTaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWFpbjogbWFpbkFsaWdubWVudFNpZGUsXG4gICAgY3Jvc3M6IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKVxuICB9O1xufVxuXG5jb25zdCBvcHBvc2l0ZUFsaWdubWVudE1hcCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2F1dG9QbGFjZW1lbnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9wbGFjZW1lbnRzVGhhdEZpdE9uRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IGFsbFBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgcGxhY2VtZW50cyA9IGFsaWdubWVudCAhPT0gdW5kZWZpbmVkIHx8IGFsbG93ZWRQbGFjZW1lbnRzID09PSBhbGxQbGFjZW1lbnRzID8gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQgfHwgbnVsbCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIDogYWxsb3dlZFBsYWNlbWVudHM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gKChfbWlkZGxld2FyZURhdGEkYXV0b1AgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QLmluZGV4KSB8fCAwO1xuICAgICAgY29uc3QgY3VycmVudFBsYWNlbWVudCA9IHBsYWNlbWVudHNbY3VycmVudEluZGV4XTtcbiAgICAgIGlmIChjdXJyZW50UGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluLFxuICAgICAgICBjcm9zc1xuICAgICAgfSA9IGdldEFsaWdubWVudFNpZGVzKGN1cnJlbnRQbGFjZW1lbnQsIHJlY3RzLCBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpO1xuXG4gICAgICAvLyBNYWtlIGBjb21wdXRlQ29vcmRzYCBzdGFydCBmcm9tIHRoZSByaWdodCBwbGFjZS5cbiAgICAgIGlmIChwbGFjZW1lbnQgIT09IGN1cnJlbnRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRzWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE92ZXJmbG93cyA9IFtvdmVyZmxvd1tnZXRTaWRlKGN1cnJlbnRQbGFjZW1lbnQpXSwgb3ZlcmZsb3dbbWFpbl0sIG92ZXJmbG93W2Nyb3NzXV07XG4gICAgICBjb25zdCBhbGxPdmVyZmxvd3MgPSBbLi4uKCgoX21pZGRsZXdhcmVEYXRhJGF1dG9QMiA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AyLm92ZXJmbG93cykgfHwgW10pLCB7XG4gICAgICAgIHBsYWNlbWVudDogY3VycmVudFBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzOiBjdXJyZW50T3ZlcmZsb3dzXG4gICAgICB9XTtcbiAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgbW9yZSBwbGFjZW1lbnRzIHRvIGNoZWNrLlxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlID0gYWxsT3ZlcmZsb3dzLm1hcChkID0+IHtcbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KGQucGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIFtkLnBsYWNlbWVudCwgYWxpZ25tZW50ICYmIGNyb3NzQXhpcyA/XG4gICAgICAgIC8vIENoZWNrIGFsb25nIHRoZSBtYWluQXhpcyBhbmQgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgZC5vdmVyZmxvd3Muc2xpY2UoMCwgMikucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYsIDApIDpcbiAgICAgICAgLy8gQ2hlY2sgb25seSB0aGUgbWFpbkF4aXMuXG4gICAgICAgIGQub3ZlcmZsb3dzWzBdLCBkLm92ZXJmbG93c107XG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUgPSBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UuZmlsdGVyKGQgPT4gZFsyXS5zbGljZSgwLFxuICAgICAgLy8gQWxpZ25lZCBwbGFjZW1lbnRzIHNob3VsZCBub3QgY2hlY2sgdGhlaXIgb3Bwb3NpdGUgY3Jvc3NBeGlzXG4gICAgICAvLyBzaWRlLlxuICAgICAgZ2V0QWxpZ25tZW50KGRbMF0pID8gMiA6IDMpLmV2ZXJ5KHYgPT4gdiA8PSAwKSk7XG4gICAgICBjb25zdCByZXNldFBsYWNlbWVudCA9ICgoX3BsYWNlbWVudHNUaGF0Rml0T25FID0gcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNUaGF0Rml0T25FWzBdKSB8fCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2VbMF1bMF07XG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgY29uc3Qgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgY29uc3QgbHIgPSBbJ2xlZnQnLCAncmlnaHQnXTtcbiAgY29uc3QgcmwgPSBbJ3JpZ2h0JywgJ2xlZnQnXTtcbiAgY29uc3QgdGIgPSBbJ3RvcCcsICdib3R0b20nXTtcbiAgY29uc3QgYnQgPSBbJ2JvdHRvbScsICd0b3AnXTtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgaWYgKHJ0bCkgcmV0dXJuIGlzU3RhcnQgPyBybCA6IGxyO1xuICAgICAgcmV0dXJuIGlzU3RhcnQgPyBsciA6IHJsO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGIgOiBidDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09ICdzdGFydCcsIHJ0bCk7XG4gIGlmIChhbGlnbm1lbnQpIHtcbiAgICBsaXN0ID0gbGlzdC5tYXAoc2lkZSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGZsaXA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBpbml0aWFsUGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZSxcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICAgIGZhbGxiYWNrU3RyYXRlZ3kgPSAnYmVzdEZpdCcsXG4gICAgICAgIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSAnbm9uZScsXG4gICAgICAgIGZsaXBBbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IGdldFNpZGUoaW5pdGlhbFBsYWNlbWVudCkgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgaWYgKCFzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgJiYgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50cy5wdXNoKC4uLmdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiwgcnRsKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWFpbixcbiAgICAgICAgICBjcm9zc1xuICAgICAgICB9ID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbbWFpbl0sIG92ZXJmbG93W2Nyb3NzXSk7XG4gICAgICB9XG4gICAgICBvdmVyZmxvd3NEYXRhID0gWy4uLm92ZXJmbG93c0RhdGEsIHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3NcbiAgICAgIH1dO1xuXG4gICAgICAvLyBPbmUgb3IgbW9yZSBzaWRlcyBpcyBvdmVyZmxvd2luZy5cbiAgICAgIGlmICghb3ZlcmZsb3dzLmV2ZXJ5KHNpZGUgPT4gc2lkZSA8PSAwKSkge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGZsaXAyLCBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXI7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9ICgoKF9taWRkbGV3YXJlRGF0YSRmbGlwMiA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcDIuaW5kZXgpIHx8IDApICsgMTtcbiAgICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHNbbmV4dEluZGV4XTtcbiAgICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgICAvLyBUcnkgbmV4dCBwbGFjZW1lbnQgYW5kIHJlLXJ1biB0aGUgbGlmZWN5Y2xlLlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgICAgICAgIG92ZXJmbG93czogb3ZlcmZsb3dzRGF0YVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudDogbmV4dFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCwgZmluZCB0aGUgY2FuZGlkYXRlcyB0aGF0IGZpdCBvbiB0aGUgbWFpbkF4aXMgc2lkZSBvZiBvdmVyZmxvdyxcbiAgICAgICAgLy8gdGhlbiBmaW5kIHRoZSBwbGFjZW1lbnQgdGhhdCBmaXRzIHRoZSBiZXN0IG9uIHRoZSBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBsZXQgcmVzZXRQbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoZCA9PiBkLm92ZXJmbG93c1swXSA8PSAwKS5zb3J0KChhLCBiKSA9PiBhLm92ZXJmbG93c1sxXSAtIGIub3ZlcmZsb3dzWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlci5wbGFjZW1lbnQ7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZhbGxiYWNrLlxuICAgICAgICBpZiAoIXJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgc3dpdGNoIChmYWxsYmFja1N0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlICdiZXN0Rml0JzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dzRGF0YSRtYXAkc287XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJG1hcCRzbyA9IG92ZXJmbG93c0RhdGEubWFwKGQgPT4gW2QucGxhY2VtZW50LCBkLm92ZXJmbG93cy5maWx0ZXIob3ZlcmZsb3cgPT4gb3ZlcmZsb3cgPiAwKS5yZWR1Y2UoKGFjYywgb3ZlcmZsb3cpID0+IGFjYyArIG92ZXJmbG93LCAwKV0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJG1hcCRzb1swXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQsXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyYXRlZ3kgPSAncmVmZXJlbmNlSGlkZGVuJyxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAncmVmZXJlbmNlSGlkZGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW5PZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbjogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdlc2NhcGVkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5mbG9hdGluZyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZE9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgZXNjYXBlZDogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHJlY3RzKSB7XG4gIGNvbnN0IG1pblggPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gIGNvbnN0IG1pblkgPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC50b3ApKTtcbiAgY29uc3QgbWF4WCA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gIGNvbnN0IG1heFkgPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5ib3R0b20pKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBtaW5YLFxuICAgIHk6IG1pblksXG4gICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlY3RzQnlMaW5lKHJlY3RzKSB7XG4gIGNvbnN0IHNvcnRlZFJlY3RzID0gcmVjdHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLnkgLSBiLnkpO1xuICBjb25zdCBncm91cHMgPSBbXTtcbiAgbGV0IHByZXZSZWN0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRSZWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlY3QgPSBzb3J0ZWRSZWN0c1tpXTtcbiAgICBpZiAoIXByZXZSZWN0IHx8IHJlY3QueSAtIHByZXZSZWN0LnkgPiBwcmV2UmVjdC5oZWlnaHQgLyAyKSB7XG4gICAgICBncm91cHMucHVzaChbcmVjdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdLnB1c2gocmVjdCk7XG4gICAgfVxuICAgIHByZXZSZWN0ID0gcmVjdDtcbiAgfVxuICByZXR1cm4gZ3JvdXBzLm1hcChyZWN0ID0+IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KHJlY3QpKSk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2lubGluZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICAvLyBBIE1vdXNlRXZlbnQncyBjbGllbnR7WCxZfSBjb29yZHMgY2FuIGJlIHVwIHRvIDIgcGl4ZWxzIG9mZiBhXG4gICAgICAvLyBDbGllbnRSZWN0J3MgYm91bmRzLCBkZXNwaXRlIHRoZSBldmVudCBsaXN0ZW5lciBiZWluZyB0cmlnZ2VyZWQuIEFcbiAgICAgIC8vIHBhZGRpbmcgb2YgMiBzZWVtcyB0byBoYW5kbGUgdGhpcyBpc3N1ZS5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFkZGluZyA9IDIsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgbmF0aXZlQ2xpZW50UmVjdHMgPSBBcnJheS5mcm9tKChhd2FpdCAocGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldENsaWVudFJlY3RzKGVsZW1lbnRzLnJlZmVyZW5jZSkpKSB8fCBbXSk7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IGdldFJlY3RzQnlMaW5lKG5hdGl2ZUNsaWVudFJlY3RzKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QobmF0aXZlQ2xpZW50UmVjdHMpKTtcbiAgICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRTaWRlT2JqZWN0RnJvbVBhZGRpbmcocGFkZGluZyk7XG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZC5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJiBjbGllbnRSZWN0c1swXS5sZWZ0ID4gY2xpZW50UmVjdHNbMV0ucmlnaHQgJiYgeCAhPSBudWxsICYmIHkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHJlY3QgaW4gd2hpY2ggdGhlIHBvaW50IGlzIGZ1bGx5IGluc2lkZS5cbiAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdHMuZmluZChyZWN0ID0+IHggPiByZWN0LmxlZnQgLSBwYWRkaW5nT2JqZWN0LmxlZnQgJiYgeCA8IHJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0ICYmIHkgPiByZWN0LnRvcCAtIHBhZGRpbmdPYmplY3QudG9wICYmIHkgPCByZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSB8fCBmYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGFyZSAyIG9yIG1vcmUgY29ubmVjdGVkIHJlY3RzLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBpZiAoZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkgPT09ICd4Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgaXNUb3AgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICd0b3AnO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzTGVmdFNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICdsZWZ0JztcbiAgICAgICAgICBjb25zdCBtYXhSaWdodCA9IG1heCguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gICAgICAgICAgY29uc3QgbWluTGVmdCA9IG1pbiguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIocmVjdCA9PiBpc0xlZnRTaWRlID8gcmVjdC5sZWZ0ID09PSBtaW5MZWZ0IDogcmVjdC5yaWdodCA9PT0gbWF4UmlnaHQpO1xuICAgICAgICAgIGNvbnN0IHRvcCA9IG1lYXN1cmVSZWN0c1swXS50b3A7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gbWVhc3VyZVJlY3RzW21lYXN1cmVSZWN0cy5sZW5ndGggLSAxXS5ib3R0b207XG4gICAgICAgICAgY29uc3QgbGVmdCA9IG1pbkxlZnQ7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBtYXhSaWdodDtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzZXRSZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogZWxlbWVudHMuZmxvYXRpbmcsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWN0cy5yZWZlcmVuY2UueCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueCB8fCByZWN0cy5yZWZlcmVuY2UueSAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueSB8fCByZWN0cy5yZWZlcmVuY2Uud2lkdGggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLndpZHRoIHx8IHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogcmVzZXRSZWN0c1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgdmFsdWUpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gJ3gnO1xuICBjb25zdCBtYWluQXhpc011bHRpID0gWydsZWZ0JywgJ3RvcCddLmluY2x1ZGVzKHNpZGUpID8gLTEgOiAxO1xuICBjb25zdCBjcm9zc0F4aXNNdWx0aSA9IHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxO1xuICBjb25zdCByYXdWYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHN0YXRlKSA6IHZhbHVlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogMCxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbCxcbiAgICAuLi5yYXdWYWx1ZVxuICB9O1xuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICB2YWx1ZSA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zOiB2YWx1ZSxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIHZhbHVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyBkaWZmQ29vcmRzLngsXG4gICAgICAgIHk6IHkgKyBkaWZmQ29vcmRzLnksXG4gICAgICAgIGRhdGE6IGRpZmZDb29yZHNcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Q3Jvc3NBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn1cblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaGlmdCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnRcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgIGxpbWl0ZXIgPSB7XG4gICAgICAgICAgZm46IF9yZWYgPT4ge1xuICAgICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0Q3Jvc3NBeGlzKG1haW5BeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IG1haW5BeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWFpbkF4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBtYWluQXhpc0Nvb3JkID0gd2l0aGluKG1pbiwgbWFpbkF4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IHdpdGhpbihtaW4sIGNyb3NzQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGltaXRlZENvb3JkcyA9IGxpbWl0ZXIuZm4oe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW21haW5BeGlzXTogbWFpbkF4aXNDb29yZCxcbiAgICAgICAgW2Nyb3NzQXhpc106IGNyb3NzQXhpc0Nvb3JkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmxpbWl0ZWRDb29yZHMsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB4OiBsaW1pdGVkQ29vcmRzLnggLSB4LFxuICAgICAgICAgIHk6IGxpbWl0ZWRDb29yZHMueSAtIHlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWVcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldENyb3NzQXhpcyhtYWluQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGNvbnN0IHJhd09mZnNldCA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoc3RhdGUpIDogb2Zmc2V0O1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dIC0gY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMjtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgaXNPcmlnaW5TaWRlID0gWyd0b3AnLCAnbGVmdCddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgKGlzT3JpZ2luU2lkZSA/ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlW2Nyb3NzQXhpc10pIHx8IDAgOiAwKSArIChpc09yaWdpblNpZGUgPyAwIDogY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dICsgKGlzT3JpZ2luU2lkZSA/IDAgOiAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pIHx8IDApIC0gKGlzT3JpZ2luU2lkZSA/IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyA6IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFwcGx5ID0gKCkgPT4ge30sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNYQXhpcyA9IGF4aXMgPT09ICd4JztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlY3RzLmZsb2F0aW5nO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGhlaWdodFNpZGUgPSBzaWRlO1xuICAgICAgICB3aWR0aFNpZGUgPSBhbGlnbm1lbnQgPT09ICgoYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKSA/ICdzdGFydCcgOiAnZW5kJykgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhTaWRlID0gc2lkZTtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBvdmVyZmxvd1toZWlnaHRTaWRlXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93W3dpZHRoU2lkZV07XG4gICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQ7XG4gICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGlzWEF4aXMpIHtcbiAgICAgICAgYXZhaWxhYmxlV2lkdGggPSBtaW4oXG4gICAgICAgIC8vIE1heGltdW0gY2xpcHBpbmcgdmlld3BvcnQgd2lkdGhcbiAgICAgICAgd2lkdGggLSBvdmVyZmxvdy5yaWdodCAtIG92ZXJmbG93LmxlZnQsIG92ZXJmbG93QXZhaWxhYmxlV2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbWluKFxuICAgICAgICAvLyBNYXhpbXVtIGNsaXBwaW5nIHZpZXdwb3J0IGhlaWdodFxuICAgICAgICBoZWlnaHQgLSBvdmVyZmxvdy5ib3R0b20gLSBvdmVyZmxvdy50b3AsIG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQgJiYgIWFsaWdubWVudCkge1xuICAgICAgICBjb25zdCB4TWluID0gbWF4KG92ZXJmbG93LmxlZnQsIDApO1xuICAgICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgICBjb25zdCB5TWF4ID0gbWF4KG92ZXJmbG93LmJvdHRvbSwgMCk7XG4gICAgICAgIGlmIChpc1hBeGlzKSB7XG4gICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIDIgKiAoeE1pbiAhPT0gMCB8fCB4TWF4ICE9PSAwID8geE1pbiArIHhNYXggOiBtYXgob3ZlcmZsb3cubGVmdCwgb3ZlcmZsb3cucmlnaHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IGFwcGx5KHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dERpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGlmICh3aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCByZWN0VG9DbGllbnRSZWN0LCBzaGlmdCwgc2l6ZSB9O1xuIiwiaW1wb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCwgY29tcHV0ZVBvc2l0aW9uIGFzIGNvbXB1dGVQb3NpdGlvbiQxIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2NvcmUnO1xuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgc2hpZnQsIHNpemUgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuICByZXR1cm4gKChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuXG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLk5vZGU7XG59XG5mdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIHJldHVybiBpc05vZGUobm9kZSkgPyAobm9kZS5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6ICcnO1xufVxuXG5sZXQgdWFTdHJpbmc7XG5mdW5jdGlvbiBnZXRVQVN0cmluZygpIHtcbiAgaWYgKHVhU3RyaW5nKSB7XG4gICAgcmV0dXJuIHVhU3RyaW5nO1xuICB9XG4gIGNvbnN0IHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICBpZiAodWFEYXRhICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICB1YVN0cmluZyA9IHVhRGF0YS5icmFuZHMubWFwKGl0ZW0gPT4gaXRlbS5icmFuZCArIFwiL1wiICsgaXRlbS52ZXJzaW9uKS5qb2luKCcgJyk7XG4gICAgcmV0dXJuIHVhU3RyaW5nO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5FbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBgU2hhZG93Um9vdGAgc3VwcG9ydC5cbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIGlzT3ZlcmZsb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1ksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVufGNsaXAvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpICYmICFbJ2lubGluZScsICdjb250ZW50cyddLmluY2x1ZGVzKGRpc3BsYXkpO1xufVxuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKGVsZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgLy8gVE9ETzogVHJ5IHRvIHVzZSBmZWF0dXJlIGRldGVjdGlvbiBoZXJlIGluc3RlYWQuXG4gIGNvbnN0IGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpO1xuICBjb25zdCBiYWNrZHJvcEZpbHRlciA9IGNzcy5iYWNrZHJvcEZpbHRlciB8fCBjc3MuV2Via2l0QmFja2Ryb3BGaWx0ZXI7XG5cbiAgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIHJldHVybiBjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgKGJhY2tkcm9wRmlsdGVyID8gYmFja2Ryb3BGaWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiAoY3NzLmZpbHRlciA/IGNzcy5maWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLnNvbWUodmFsdWUgPT4gY3NzLndpbGxDaGFuZ2UuaW5jbHVkZXModmFsdWUpKSB8fCBbJ3BhaW50JywgJ2xheW91dCcsICdzdHJpY3QnLCAnY29udGVudCddLnNvbWUodmFsdWUgPT4ge1xuICAgIC8vIEFkZCB0eXBlIGNoZWNrIGZvciBvbGQgYnJvd3NlcnMuXG4gICAgY29uc3QgY29udGFpbiA9IGNzcy5jb250YWluO1xuICAgIHJldHVybiBjb250YWluICE9IG51bGwgPyBjb250YWluLmluY2x1ZGVzKHZhbHVlKSA6IGZhbHNlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClgIGlzIGFmZmVjdGVkIGJ5IHZpc3VhbFxuICogdmlld3BvcnQgb2Zmc2V0cy4gSW4gU2FmYXJpLCB0aGUgYHhgL2B5YCBvZmZzZXRzIGFyZSB2YWx1ZXMgcmVsYXRpdmUgdG8gdGhlXG4gKiB2aXN1YWwgdmlld3BvcnQsIHdoaWxlIGluIG90aGVyIGVuZ2luZXMsIHRoZXkgYXJlIHZhbHVlcyByZWxhdGl2ZSB0byB0aGVcbiAqIGxheW91dCB2aWV3cG9ydC5cbiAqL1xuZnVuY3Rpb24gaXNDbGllbnRSZWN0VmlzdWFsVmlld3BvcnRCYXNlZCgpIHtcbiAgLy8gVE9ETzogVHJ5IHRvIHVzZSBmZWF0dXJlIGRldGVjdGlvbiBoZXJlIGluc3RlYWQuIEZlYXR1cmUgZGV0ZWN0aW9uIGZvclxuICAvLyB0aGlzIGNhbiBmYWlsIGluIHZhcmlvdXMgd2F5cywgbWFraW5nIHRoZSB1c2VyQWdlbnQgY2hlY2sgdGhlIG1vc3RcbiAgLy8gcmVsaWFibGU6XG4gIC8vIOKAoiBBbHdheXMtdmlzaWJsZSBzY3JvbGxiYXIgb3Igbm90XG4gIC8vIOKAoiBXaWR0aCBvZiA8aHRtbD5cblxuICAvLyBJcyBTYWZhcmkuXG4gIHJldHVybiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufVxuZnVuY3Rpb24gaXNMYXN0VHJhdmVyc2FibGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKG5vZGUpKTtcbn1cblxuY29uc3QgbWluID0gTWF0aC5taW47XG5jb25zdCBtYXggPSBNYXRoLm1heDtcbmNvbnN0IHJvdW5kID0gTWF0aC5yb3VuZDtcblxuZnVuY3Rpb24gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KTtcbiAgbGV0IHdpZHRoID0gcGFyc2VGbG9hdChjc3Mud2lkdGgpO1xuICBsZXQgaGVpZ2h0ID0gcGFyc2VGbG9hdChjc3MuaGVpZ2h0KTtcbiAgY29uc3QgaGFzT2Zmc2V0ID0gaXNIVE1MRWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgb2Zmc2V0V2lkdGggPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldFdpZHRoIDogd2lkdGg7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0O1xuICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHJvdW5kKHdpZHRoKSAhPT0gb2Zmc2V0V2lkdGggfHwgcm91bmQoaGVpZ2h0KSAhPT0gb2Zmc2V0SGVpZ2h0O1xuICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBmYWxsYmFjazogc2hvdWxkRmFsbGJhY2tcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW53cmFwRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiAhaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5jb250ZXh0RWxlbWVudCA6IGVsZW1lbnQ7XG59XG5cbmNvbnN0IEZBTExCQUNLX1NDQUxFID0ge1xuICB4OiAxLFxuICB5OiAxXG59O1xuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIEZBTExCQUNLX1NDQUxFO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGZhbGxiYWNrXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeCA9IChmYWxsYmFjayA/IHJvdW5kKHJlY3Qud2lkdGgpIDogcmVjdC53aWR0aCkgLyB3aWR0aDtcbiAgbGV0IHkgPSAoZmFsbGJhY2sgPyByb3VuZChyZWN0LmhlaWdodCkgOiByZWN0LmhlaWdodCkgLyBoZWlnaHQ7XG5cbiAgLy8gMCwgTmFOLCBvciBJbmZpbml0eSBzaG91bGQgYWx3YXlzIGZhbGxiYWNrIHRvIDEuXG5cbiAgaWYgKCF4IHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB4ID0gMTtcbiAgfVxuICBpZiAoIXkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHkgPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIHZhciBfd2luJHZpc3VhbFZpZXdwb3J0LCBfd2luJHZpc3VhbFZpZXdwb3J0MjtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBsZXQgc2NhbGUgPSBGQUxMQkFDS19TQ0FMRTtcbiAgaWYgKGluY2x1ZGVTY2FsZSkge1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHdpbiA9IGRvbUVsZW1lbnQgPyBnZXRXaW5kb3coZG9tRWxlbWVudCkgOiB3aW5kb3c7XG4gIGNvbnN0IGFkZFZpc3VhbE9mZnNldHMgPSBpc0NsaWVudFJlY3RWaXN1YWxWaWV3cG9ydEJhc2VkKCkgJiYgaXNGaXhlZFN0cmF0ZWd5O1xuICBsZXQgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyA/ICgoX3dpbiR2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW4kdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCkgfHwgMCA6IDApKSAvIHNjYWxlLng7XG4gIGxldCB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgPyAoKF93aW4kdmlzdWFsVmlld3BvcnQyID0gd2luLnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbiR2aXN1YWxWaWV3cG9ydDIub2Zmc2V0VG9wKSB8fCAwIDogMCkpIC8gc2NhbGUueTtcbiAgbGV0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlLng7XG4gIGxldCBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlLnk7XG4gIGlmIChkb21FbGVtZW50KSB7XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGRvbUVsZW1lbnQpO1xuICAgIGNvbnN0IG9mZnNldFdpbiA9IG9mZnNldFBhcmVudCAmJiBpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSA/IGdldFdpbmRvdyhvZmZzZXRQYXJlbnQpIDogb2Zmc2V0UGFyZW50O1xuICAgIGxldCBjdXJyZW50SUZyYW1lID0gd2luLmZyYW1lRWxlbWVudDtcbiAgICB3aGlsZSAoY3VycmVudElGcmFtZSAmJiBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0V2luICE9PSB3aW4pIHtcbiAgICAgIGNvbnN0IGlmcmFtZVNjYWxlID0gZ2V0U2NhbGUoY3VycmVudElGcmFtZSk7XG4gICAgICBjb25zdCBpZnJhbWVSZWN0ID0gY3VycmVudElGcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudElGcmFtZSk7XG4gICAgICBpZnJhbWVSZWN0LnggKz0gKGN1cnJlbnRJRnJhbWUuY2xpZW50TGVmdCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdMZWZ0KSkgKiBpZnJhbWVTY2FsZS54O1xuICAgICAgaWZyYW1lUmVjdC55ICs9IChjdXJyZW50SUZyYW1lLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdUb3ApKSAqIGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICB5ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB3aWR0aCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICs9IGlmcmFtZVJlY3QueDtcbiAgICAgIHkgKz0gaWZyYW1lUmVjdC55O1xuICAgICAgY3VycmVudElGcmFtZSA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKS5mcmFtZUVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICByZXR1cm4gKChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnBhZ2VYT2Zmc2V0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5wYWdlWU9mZnNldFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgc3RyYXRlZ3kgIT09ICdmaXhlZCcpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoICogc2NhbGUueCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICogc2NhbGUueSxcbiAgICB4OiByZWN0LnggKiBzY2FsZS54IC0gc2Nyb2xsLnNjcm9sbExlZnQgKiBzY2FsZS54ICsgb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QueSAqIHNjYWxlLnkgLSBzY3JvbGwuc2Nyb2xsVG9wICogc2NhbGUueSArIG9mZnNldHMueVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUkMShib2R5KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRXaWR0aCkgLSB3aWR0aDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShub2RlKSB7XG4gIGlmIChnZXROb2RlTmFtZShub2RlKSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID1cbiAgLy8gU3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGUuXG4gIG5vZGUuYXNzaWduZWRTbG90IHx8XG4gIC8vIERPTSBFbGVtZW50IGRldGVjdGVkLlxuICBub2RlLnBhcmVudE5vZGUgfHxcbiAgLy8gU2hhZG93Um9vdCBkZXRlY3RlZC5cbiAgaXNTaGFkb3dSb290KG5vZGUpICYmIG5vZGUuaG9zdCB8fFxuICAvLyBGYWxsYmFjay5cbiAgZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpO1xuICByZXR1cm4gaXNTaGFkb3dSb290KHJlc3VsdCkgPyByZXN1bHQuaG9zdCA6IHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIC8vIGBnZXRQYXJlbnROb2RlYCB3aWxsIG5ldmVyIHJldHVybiBhIGBEb2N1bWVudGAgZHVlIHRvIHRoZSBmYWxsYmFja1xuICAgIC8vIGNoZWNrLCBzbyBpdCdzIGVpdGhlciB0aGUgPGh0bWw+IG9yIDxib2R5PiBlbGVtZW50LlxuICAgIHJldHVybiBwYXJlbnROb2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCkge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmJvZHkpO1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsYWJsZUFuY2VzdG9yKTtcbiAgaWYgKGlzQm9keSkge1xuICAgIHJldHVybiBsaXN0LmNvbmNhdCh3aW4sIHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNPdmVyZmxvd0VsZW1lbnQoc2Nyb2xsYWJsZUFuY2VzdG9yKSA/IHNjcm9sbGFibGVBbmNlc3RvciA6IFtdKTtcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoc2Nyb2xsYWJsZUFuY2VzdG9yLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyhzY3JvbGxhYmxlQW5jZXN0b3IpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0QmFzZWQgPSBpc0NsaWVudFJlY3RWaXN1YWxWaWV3cG9ydEJhc2VkKCk7XG4gICAgaWYgKCF2aXN1YWxWaWV3cG9ydEJhc2VkIHx8IHZpc3VhbFZpZXdwb3J0QmFzZWQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbi8vIFJldHVybnMgdGhlIGlubmVyIGNsaWVudCByZWN0LCBzdWJ0cmFjdGluZyBzY3JvbGxiYXJzIGlmIHByZXNlbnQuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgY29uc3QgdG9wID0gY2xpZW50UmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgY29uc3QgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgY29uc3Qgc2NhbGUgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0U2NhbGUoZWxlbWVudCkgOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjYWxlLng7XG4gIGNvbnN0IGhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NhbGUueTtcbiAgY29uc3QgeCA9IGxlZnQgKiBzY2FsZS54O1xuICBjb25zdCB5ID0gdG9wICogc2NhbGUueTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpIHtcbiAgbGV0IHJlY3Q7XG4gIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAndmlld3BvcnQnKSB7XG4gICAgcmVjdCA9IGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSk7XG4gIH0gZWxzZSBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ2RvY3VtZW50Jykge1xuICAgIHJlY3QgPSBnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKTtcbiAgfSBlbHNlIGlmIChpc0VsZW1lbnQoY2xpcHBpbmdBbmNlc3RvcikpIHtcbiAgICByZWN0ID0gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG11dGFibGVSZWN0ID0ge1xuICAgICAgLi4uY2xpcHBpbmdBbmNlc3RvclxuICAgIH07XG4gICAgaWYgKGlzQ2xpZW50UmVjdFZpc3VhbFZpZXdwb3J0QmFzZWQoKSkge1xuICAgICAgdmFyIF93aW4kdmlzdWFsVmlld3BvcnQsIF93aW4kdmlzdWFsVmlld3BvcnQyO1xuICAgICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICAgICAgbXV0YWJsZVJlY3QueCAtPSAoKF93aW4kdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luJHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQpIHx8IDA7XG4gICAgICBtdXRhYmxlUmVjdC55IC09ICgoX3dpbiR2aXN1YWxWaWV3cG9ydDIgPSB3aW4udmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luJHZpc3VhbFZpZXdwb3J0Mi5vZmZzZXRUb3ApIHx8IDA7XG4gICAgfVxuICAgIHJlY3QgPSBtdXRhYmxlUmVjdDtcbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdChyZWN0KTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gYG92ZXJmbG93YCBlbGVtZW50IHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBjaGlsZCBlbGVtZW50cy4gVGhpcyByZXR1cm5zIGFsbCBjbGlwcGluZyBhbmNlc3RvcnNcbi8vIG9mIHRoZSBnaXZlbiBlbGVtZW50IHVwIHRoZSB0cmVlLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQpLmZpbHRlcihlbCA9PiBpc0VsZW1lbnQoZWwpICYmIGdldE5vZGVOYW1lKGVsKSAhPT0gJ2JvZHknKTtcbiAgbGV0IGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgY29uc3QgZWxlbWVudElzRml4ZWQgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGN1cnJlbnROb2RlKTtcbiAgICBjb25zdCBjb250YWluaW5nQmxvY2sgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgY29uc3Qgc2hvdWxkSWdub3JlQ3VycmVudE5vZGUgPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnO1xuICAgIGlmIChzaG91bGRJZ25vcmVDdXJyZW50Tm9kZSkge1xuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzaG91bGREcm9wQ3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/ICFjb250YWluaW5nQmxvY2sgJiYgIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIDogIWNvbnRhaW5pbmdCbG9jayAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbik7XG4gICAgICBpZiAoc2hvdWxkRHJvcEN1cnJlbnROb2RlKSB7XG4gICAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGFuY2VzdG9yID0+IGFuY2VzdG9yICE9PSBjdXJyZW50Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIGNhY2hlLnNldChlbGVtZW50LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBhbmNlc3RvcnMuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nQW5jZXN0b3JzJyA/IGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCB0aGlzLl9jKSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gWy4uLmVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF07XG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBmaXJzdENsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3AsXG4gICAgeDogY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgeTogY2xpcHBpbmdSZWN0LnRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2x5ZmlsbCkge1xuICAgIHJldHVybiBwb2x5ZmlsbChlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59XG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICBsZXQgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBpZiAoaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCk7XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlJDEob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZSQxKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChlbGVtZW50LCBvZmZzZXRQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJywgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIHN0cmF0ZWd5ICE9PSAnZml4ZWQnKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmNvbnN0IHBsYXRmb3JtID0ge1xuICBnZXRDbGlwcGluZ1JlY3QsXG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBpc0VsZW1lbnQsXG4gIGdldERpbWVuc2lvbnMsXG4gIGdldE9mZnNldFBhcmVudCxcbiAgZ2V0RG9jdW1lbnRFbGVtZW50LFxuICBnZXRTY2FsZSxcbiAgYXN5bmMgZ2V0RWxlbWVudFJlY3RzKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgcmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmcsXG4gICAgICBzdHJhdGVneVxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICAgIGNvbnN0IGdldERpbWVuc2lvbnNGbiA9IHRoaXMuZ2V0RGltZW5zaW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChyZWZlcmVuY2UsIGF3YWl0IGdldE9mZnNldFBhcmVudEZuKGZsb2F0aW5nKSwgc3RyYXRlZ3kpLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgLi4uKGF3YWl0IGdldERpbWVuc2lvbnNGbihmbG9hdGluZykpXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZ2V0Q2xpZW50UmVjdHM6IGVsZW1lbnQgPT4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpLFxuICBpc1JUTDogZWxlbWVudCA9PiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJ1xufTtcblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gbmVjZXNzYXJ5LlxuICogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgbW91bnRlZCBvbiB0aGUgRE9NIG9yXG4gKiB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiBAcmV0dXJucyBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGludm9rZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICogcmVtb3ZlZCBmcm9tIHRoZSBET00gb3IgaGlkZGVuIGZyb20gdGhlIHNjcmVlbi5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvVXBkYXRlXG4gKi9cbmZ1bmN0aW9uIGF1dG9VcGRhdGUocmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsOiBfYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHJ1ZSxcbiAgICBhbmltYXRpb25GcmFtZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBhbmNlc3RvclNjcm9sbCA9IF9hbmNlc3RvclNjcm9sbCAmJiAhYW5pbWF0aW9uRnJhbWU7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLihpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10pLCAuLi5nZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZyldIDogW107XG4gIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICB9KTtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpc0VsZW1lbnQocmVmZXJlbmNlKSAmJiAhYW5pbWF0aW9uRnJhbWUgJiYgb2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2UpO1xuICAgIGlmICghaXNFbGVtZW50KHJlZmVyZW5jZSkgJiYgcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ICYmICFhbmltYXRpb25GcmFtZSkge1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpO1xuICAgIH1cbiAgICBvYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAobmV4dFJlZlJlY3QueCAhPT0gcHJldlJlZlJlY3QueCB8fCBuZXh0UmVmUmVjdC55ICE9PSBwcmV2UmVmUmVjdC55IHx8IG5leHRSZWZSZWN0LndpZHRoICE9PSBwcmV2UmVmUmVjdC53aWR0aCB8fCBuZXh0UmVmUmVjdC5oZWlnaHQgIT09IHByZXZSZWZSZWN0LmhlaWdodCkpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgICBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWVMb29wKTtcbiAgfVxuICB1cGRhdGUoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgX29ic2VydmVyO1xuICAgIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSk7XG4gICAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICAgIH0pO1xuICAgIChfb2JzZXJ2ZXIgPSBvYnNlcnZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgb2JzZXJ2ZXIgPSBudWxsO1xuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSByZWZlcmVuY2UgZWxlbWVudCB3aGVuIGl0IGlzIGdpdmVuIGEgY2VydGFpbiBDU1MgcG9zaXRpb25pbmdcbiAqIHN0cmF0ZWd5LlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSAocmVmZXJlbmNlLCBmbG9hdGluZywgb3B0aW9ucykgPT4ge1xuICAvLyBUaGlzIGNhY2hlcyB0aGUgZXhwZW5zaXZlIGBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnNgIGZ1bmN0aW9uIHNvIHRoYXRcbiAgLy8gbXVsdGlwbGUgbGlmZWN5Y2xlIHJlc2V0cyByZS11c2UgdGhlIHNhbWUgcmVzdWx0LiBJdCBvbmx5IGxpdmVzIGZvciBhXG4gIC8vIHNpbmdsZSBjYWxsLiBJZiBvdGhlciBmdW5jdGlvbnMgYmVjb21lIGV4cGVuc2l2ZSwgd2UgY2FuIGFkZCB0aGVtIGFzIHdlbGwuXG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgIHBsYXRmb3JtLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgcGxhdGZvcm1XaXRoQ2FjaGUgPSB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucy5wbGF0Zm9ybSxcbiAgICBfYzogY2FjaGVcbiAgfTtcbiAgcmV0dXJuIGNvbXB1dGVQb3NpdGlvbiQxKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVdpdGhDYWNoZVxuICB9KTtcbn07XG5cbmV4cG9ydCB7IGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIHBsYXRmb3JtIH07XG4iLCJpbXBvcnQgbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCB7IHNob3VsZENlbnRlclN0ZXAgfSBmcm9tICcuL2dlbmVyYWwnO1xuaW1wb3J0IHtcbiAgYXV0b1VwZGF0ZSxcbiAgYXJyb3csXG4gIGNvbXB1dGVQb3NpdGlvbixcbiAgZmxpcCxcbiAgbGltaXRTaGlmdCxcbiAgc2hpZnRcbn0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5cbi8qKlxuICogRmxvYXRpbmcgVUkgT3B0aW9uc1xuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEZsb2F0aW5nVUlPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmVzIG9wdGlvbnMgZm9yIHRoZSB0b29sdGlwIGFuZCBpbml0aWFsaXplcyBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7RmxvYXRpbmdVSU9wdGlvbnN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFRvb2x0aXAoc3RlcCkge1xuICBpZiAoc3RlcC5jbGVhbnVwKSB7XG4gICAgc3RlcC5jbGVhbnVwKCk7XG4gIH1cblxuICBjb25zdCBhdHRhY2hUb09wdGlvbnMgPSBzdGVwLl9nZXRSZXNvbHZlZEF0dGFjaFRvT3B0aW9ucygpO1xuXG4gIGxldCB0YXJnZXQgPSBhdHRhY2hUb09wdGlvbnMuZWxlbWVudDtcbiAgY29uc3QgZmxvYXRpbmdVSU9wdGlvbnMgPSBnZXRGbG9hdGluZ1VJT3B0aW9ucyhhdHRhY2hUb09wdGlvbnMsIHN0ZXApO1xuICBjb25zdCBzaG91bGRDZW50ZXIgPSBzaG91bGRDZW50ZXJTdGVwKGF0dGFjaFRvT3B0aW9ucyk7XG5cbiAgaWYgKHNob3VsZENlbnRlcikge1xuICAgIHRhcmdldCA9IGRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgY29udGVudCA9IHN0ZXAuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3NoZXBoZXJkLWNlbnRlcmVkJyk7XG4gIH1cblxuICBzdGVwLmNsZWFudXAgPSBhdXRvVXBkYXRlKHRhcmdldCwgc3RlcC5lbCwgKCkgPT4ge1xuICAgIC8vIFRoZSBlbGVtZW50IG1pZ2h0IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYnkgdGhlIGVuZCBvZiB0aGUgdG91ci5cbiAgICBpZiAoIXN0ZXAuZWwpIHtcbiAgICAgIHN0ZXAuY2xlYW51cCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFBvc2l0aW9uKHRhcmdldCwgc3RlcCwgZmxvYXRpbmdVSU9wdGlvbnMsIHNob3VsZENlbnRlcik7XG4gIH0pO1xuXG4gIHN0ZXAudGFyZ2V0ID0gYXR0YWNoVG9PcHRpb25zLmVsZW1lbnQ7XG5cbiAgcmV0dXJuIGZsb2F0aW5nVUlPcHRpb25zO1xufVxuXG4vKipcbiAqIE1lcmdlIHRvb2x0aXAgb3B0aW9ucyBoYW5kbGluZyBuZXN0ZWQga2V5cy5cbiAqXG4gKiBAcGFyYW0gdG91ck9wdGlvbnMgLSBUaGUgZGVmYXVsdCB0b3VyIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFN0ZXAgc3BlY2lmaWMgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHtmbG9hdGluZ1VJT3B0aW9uczogRmxvYXRpbmdVSU9wdGlvbnN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVRvb2x0aXBDb25maWcodG91ck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBmbG9hdGluZ1VJT3B0aW9uczogbWVyZ2UoXG4gICAgICB0b3VyT3B0aW9ucy5mbG9hdGluZ1VJT3B0aW9ucyB8fCB7fSxcbiAgICAgIG9wdGlvbnMuZmxvYXRpbmdVSU9wdGlvbnMgfHwge31cbiAgICApXG4gIH07XG59XG5cbi8qKlxuICogQ2xlYW51cCBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgc3RlcCBpcyBjbG9zZWQvZGVzdHJveWVkLlxuICpcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveVRvb2x0aXAoc3RlcCkge1xuICBpZiAoc3RlcC5jbGVhbnVwKSB7XG4gICAgc3RlcC5jbGVhbnVwKCk7XG4gIH1cblxuICBzdGVwLmNsZWFudXAgPSBudWxsO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlPCo+fVxuICovXG5mdW5jdGlvbiBzZXRQb3NpdGlvbih0YXJnZXQsIHN0ZXAsIGZsb2F0aW5nVUlPcHRpb25zLCBzaG91bGRDZW50ZXIpIHtcbiAgcmV0dXJuIChcbiAgICBjb21wdXRlUG9zaXRpb24odGFyZ2V0LCBzdGVwLmVsLCBmbG9hdGluZ1VJT3B0aW9ucylcbiAgICAgIC50aGVuKGZsb2F0aW5nVUlwb3NpdGlvbihzdGVwLCBzaG91bGRDZW50ZXIpKVxuICAgICAgLy8gV2FpdCBiZWZvcmUgZm9yY2luZyBmb2N1cy5cbiAgICAgIC50aGVuKFxuICAgICAgICAoc3RlcCkgPT5cbiAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHN0ZXApLCAzMDApO1xuICAgICAgICAgIH0pXG4gICAgICApXG4gICAgICAvLyBSZXBsYWNlcyBmb2N1c0FmdGVyUmVuZGVyIG1vZGlmaWVyLlxuICAgICAgLnRoZW4oKHN0ZXApID0+IHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgc3RlcC5lbCkge1xuICAgICAgICAgIHN0ZXAuZWwuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICApO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gc3RlcFxuICogQHBhcmFtIHNob3VsZENlbnRlclxuICogQHJldHVybiB7ZnVuY3Rpb24oe3g6ICosIHk6ICosIHBsYWNlbWVudDogKiwgbWlkZGxld2FyZURhdGE6ICp9KTogUHJvbWlzZTx1bmtub3duPn1cbiAqL1xuZnVuY3Rpb24gZmxvYXRpbmdVSXBvc2l0aW9uKHN0ZXAsIHNob3VsZENlbnRlcikge1xuICByZXR1cm4gKHsgeCwgeSwgcGxhY2VtZW50LCBtaWRkbGV3YXJlRGF0YSB9KSA9PiB7XG4gICAgaWYgKCFzdGVwLmVsKSB7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkQ2VudGVyKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0ZXAuZWwuc3R5bGUsIHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICB0b3A6ICc1MCUnLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdGVwLmVsLnN0eWxlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBsZWZ0OiBgJHt4fXB4YCxcbiAgICAgICAgdG9wOiBgJHt5fXB4YFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RlcC5lbC5kYXRhc2V0LnBvcHBlclBsYWNlbWVudCA9IHBsYWNlbWVudDtcblxuICAgIHBsYWNlQXJyb3coc3RlcC5lbCwgbWlkZGxld2FyZURhdGEpO1xuXG4gICAgcmV0dXJuIHN0ZXA7XG4gIH07XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBlbFxuICogQHBhcmFtIG1pZGRsZXdhcmVEYXRhXG4gKi9cbmZ1bmN0aW9uIHBsYWNlQXJyb3coZWwsIG1pZGRsZXdhcmVEYXRhKSB7XG4gIGNvbnN0IGFycm93RWwgPSBlbC5xdWVyeVNlbGVjdG9yKCcuc2hlcGhlcmQtYXJyb3cnKTtcbiAgaWYgKGFycm93RWwgJiYgbWlkZGxld2FyZURhdGEuYXJyb3cpIHtcbiAgICBjb25zdCB7IHg6IGFycm93WCwgeTogYXJyb3dZIH0gPSBtaWRkbGV3YXJlRGF0YS5hcnJvdztcbiAgICBPYmplY3QuYXNzaWduKGFycm93RWwuc3R5bGUsIHtcbiAgICAgIGxlZnQ6IGFycm93WCAhPSBudWxsID8gYCR7YXJyb3dYfXB4YCA6ICcnLFxuICAgICAgdG9wOiBhcnJvd1kgIT0gbnVsbCA/IGAke2Fycm93WX1weGAgOiAnJ1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYEZsb2F0aW5nIFVJYCBvcHRpb25zIGZyb20gYSBzZXQgb2YgYmFzZSBgYXR0YWNoVG9gIG9wdGlvbnNcbiAqIEBwYXJhbSBhdHRhY2hUb09wdGlvbnNcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZsb2F0aW5nVUlPcHRpb25zKGF0dGFjaFRvT3B0aW9ucywgc3RlcCkge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmU6IFtdXG4gIH07XG5cbiAgY29uc3QgYXJyb3dFbCA9IGFkZEFycm93KHN0ZXApO1xuXG4gIGNvbnN0IHNob3VsZENlbnRlciA9IHNob3VsZENlbnRlclN0ZXAoYXR0YWNoVG9PcHRpb25zKTtcblxuICBpZiAoIXNob3VsZENlbnRlcikge1xuICAgIG9wdGlvbnMubWlkZGxld2FyZS5wdXNoKFxuICAgICAgZmxpcCgpLFxuICAgICAgLy8gUmVwbGljYXRlIFBvcHBlckpTIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICBzaGlmdCh7XG4gICAgICAgIGxpbWl0ZXI6IGxpbWl0U2hpZnQoKSxcbiAgICAgICAgY3Jvc3NBeGlzOiB0cnVlXG4gICAgICB9KVxuICAgICk7XG5cbiAgICBpZiAoYXJyb3dFbCkge1xuICAgICAgb3B0aW9ucy5taWRkbGV3YXJlLnB1c2goYXJyb3coeyBlbGVtZW50OiBhcnJvd0VsIH0pKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLnBsYWNlbWVudCA9IGF0dGFjaFRvT3B0aW9ucy5vbjtcbiAgfVxuXG4gIHJldHVybiBtZXJnZShzdGVwLm9wdGlvbnMuZmxvYXRpbmdVSU9wdGlvbnMgfHwge30sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR8ZmFsc2V8bnVsbH1cbiAqL1xuZnVuY3Rpb24gYWRkQXJyb3coc3RlcCkge1xuICBpZiAoc3RlcC5vcHRpb25zLmFycm93ICYmIHN0ZXAuZWwpIHtcbiAgICByZXR1cm4gc3RlcC5lbC5xdWVyeVNlbGVjdG9yKCcuc2hlcGhlcmQtYXJyb3cnKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImZ1bmN0aW9uIG5vb3AoKSB7IH1cbmNvbnN0IGlkZW50aXR5ID0geCA9PiB4O1xuZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAoY29uc3QgayBpbiBzcmMpXG4gICAgICAgIHRhcltrXSA9IHNyY1trXTtcbiAgICByZXR1cm4gdGFyO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvTElDRU5TRVxuZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG4gICAgZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuICAgICAgICBsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG59XG5mdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5mdW5jdGlvbiBydW5fYWxsKGZucykge1xuICAgIGZucy5mb3JFYWNoKHJ1bik7XG59XG5mdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbicpO1xufVxubGV0IHNyY191cmxfZXF1YWxfYW5jaG9yO1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG4gICAgaWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuICAgICAgICBzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB9XG4gICAgc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5mdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcbiAgICBpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmIChzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cbmZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBzdWJzY3JpYmUoc3RvcmUsIF8gPT4gdmFsdWUgPSBfKSgpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmblxuICAgICAgICA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKVxuICAgICAgICA6ICQkc2NvcGUuY3R4O1xufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuICAgICAgICBjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuICAgICAgICBpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcbiAgICB9XG4gICAgcmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgICAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90KHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG4gICAgdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbn1cbmZ1bmN0aW9uIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSgkJHNjb3BlKSB7XG4gICAgaWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXJ0eVtpXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcbiAgICBjb25zdCByZXN0ID0ge307XG4gICAga2V5cyA9IG5ldyBTZXQoa2V5cyk7XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3Rba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfc2xvdHMoc2xvdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgICByZXN1bHRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAocmFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICBmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBudWxsX3RvX2VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG4gICAgc3RvcmUuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmV0O1xufVxuY29uc3QgaGFzX3Byb3AgPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbmZ1bmN0aW9uIGFjdGlvbl9kZXN0cm95ZXIoYWN0aW9uX3Jlc3VsdCkge1xuICAgIHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuZnVuY3Rpb24gc3BsaXRfY3NzX3VuaXQodmFsdWUpIHtcbiAgICBjb25zdCBzcGxpdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubWF0Y2goL15cXHMqKC0/W1xcZC5dKykoW15cXHNdKilcXHMqJC8pO1xuICAgIHJldHVybiBzcGxpdCA/IFtwYXJzZUZsb2F0KHNwbGl0WzFdKSwgc3BsaXRbMl0gfHwgJ3B4J10gOiBbdmFsdWUsICdweCddO1xufVxuY29uc3QgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMgPSBbJycsIHRydWUsIDEsICd0cnVlJywgJ2NvbnRlbnRlZGl0YWJsZSddO1xuXG5jb25zdCBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmxldCBub3cgPSBpc19jbGllbnRcbiAgICA/ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIDogKCkgPT4gRGF0ZS5ub3coKTtcbmxldCByYWYgPSBpc19jbGllbnQgPyBjYiA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIDogbm9vcDtcbi8vIHVzZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gc2V0X25vdyhmbikge1xuICAgIG5vdyA9IGZuO1xufVxuZnVuY3Rpb24gc2V0X3JhZihmbikge1xuICAgIHJhZiA9IGZuO1xufVxuXG5jb25zdCB0YXNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcbiAgICB0YXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgICAgICBpZiAoIXRhc2suYyhub3cpKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgICAgICB0YXNrLmYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YXNrcy5zaXplICE9PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbn1cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSFcbiAqL1xuZnVuY3Rpb24gY2xlYXJfbG9vcHMoKSB7XG4gICAgdGFza3MuY2xlYXIoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqL1xuZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuICAgIGxldCB0YXNrO1xuICAgIGlmICh0YXNrcy5zaXplID09PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZShmdWxmaWxsID0+IHtcbiAgICAgICAgICAgIHRhc2tzLmFkZCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcbiAgICAvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgY29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcbiAgICAgICAgaWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xufVxuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KVxuICAgICAgICByZXR1cm47XG4gICAgdGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG4gICAgLy8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuICAgIGxldCBjaGlsZHJlbiA9IHRhcmdldC5jaGlsZE5vZGVzO1xuICAgIC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG4gICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgIGNvbnN0IG15Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG15Q2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IG15Q2hpbGRyZW47XG4gICAgfVxuICAgIC8qXG4gICAgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuICAgICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuICAgICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3RcbiAgICAqIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG4gICAgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuICAgICpcbiAgICAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuICAgICogcG9zc2libGUuXG4gICAgKlxuICAgICogUHJvb2Y6XG4gICAgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcbiAgICAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuICAgICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcbiAgICAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG4gICAgKi9cbiAgICAvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcbiAgICBjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG4gICAgLy8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcbiAgICBjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBtWzBdID0gLTE7XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuICAgICAgICAvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuICAgICAgICAvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuICAgICAgICBjb25zdCBzZXFMZW4gPSAoKGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnQpID8gbG9uZ2VzdCArIDEgOiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCBpZHggPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcbiAgICAgICAgcFtpXSA9IG1bc2VxTGVuXSArIDE7XG4gICAgICAgIGNvbnN0IG5ld0xlbiA9IHNlcUxlbiArIDE7XG4gICAgICAgIC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cbiAgICAgICAgbVtuZXdMZW5dID0gaTtcbiAgICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5ld0xlbiwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcbiAgICBjb25zdCBsaXMgPSBbXTtcbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuICAgIGNvbnN0IHRvTW92ZSA9IFtdO1xuICAgIGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcbiAgICAgICAgbGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuICAgICAgICBmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuICAgICAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QtLTtcbiAgICB9XG4gICAgZm9yICg7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG4gICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICB9XG4gICAgbGlzLnJldmVyc2UoKTtcbiAgICAvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcbiAgICB0b01vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuICAgIC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9Nb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b01vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvTW92ZVtpXSwgYW5jaG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcbiAgICBjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG4gICAgaWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICBjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICBpZiAocm9vdCAmJiByb290Lmhvc3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG4gICAgY29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgYXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcbiAgICByZXR1cm4gc3R5bGVfZWxlbWVudC5zaGVldDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG4gICAgYXBwZW5kKG5vZGUuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG4gICAgcmV0dXJuIHN0eWxlLnNoZWV0O1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nKSB7XG4gICAgICAgIGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuICAgICAgICBpZiAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQpIHx8ICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnROb2RlICE9PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuICAgICAgICB3aGlsZSAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQuY2xhaW1fb3JkZXIgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgIT09IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGluc2VydCBpZiB0aGUgb3JkZXJpbmcgb2YgdGhpcyBub2RlIHNob3VsZCBiZSBtb2RpZmllZCBvciB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRhcmdldFxuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCB8fCBub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGlmIChpc19oeWRyYXRpbmcgJiYgIWFuY2hvcikge1xuICAgICAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlcmF0aW9uc1tpXSlcbiAgICAgICAgICAgIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc19wcm9wKG9iaiwgaylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRhcmdldFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5mdW5jdGlvbiB0ZXh0KGRhdGEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5mdW5jdGlvbiBzcGFjZSgpIHtcbiAgICByZXR1cm4gdGV4dCgnICcpO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRleHQoJycpO1xufVxuZnVuY3Rpb24gY29tbWVudChjb250ZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzZWxmKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQuaXNUcnVzdGVkKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvcnNba2V5XSAmJiBkZXNjcmlwdG9yc1trZXldLnNldCkge1xuICAgICAgICAgICAgbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3ZnX2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwKG5vZGUsIGRhdGFfbWFwKSB7XG4gICAgT2JqZWN0LmtleXMoZGF0YV9tYXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBrZXksIGRhdGFfbWFwW2tleV0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBpZiAocHJvcCBpbiBub2RlKSB7XG4gICAgICAgIG5vZGVbcHJvcF0gPSB0eXBlb2Ygbm9kZVtwcm9wXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9keW5hbWljX2VsZW1lbnRfZGF0YSh0YWcpIHtcbiAgICByZXR1cm4gKC8tLy50ZXN0KHRhZykpID8gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwIDogc2V0X2F0dHJpYnV0ZXM7XG59XG5mdW5jdGlvbiB4bGlua19hdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGdyb3VwW2ldLmNoZWNrZWQpXG4gICAgICAgICAgICB2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG4gICAgfVxuICAgIGlmICghY2hlY2tlZCkge1xuICAgICAgICB2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cChncm91cCkge1xuICAgIGxldCBfaW5wdXRzO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qIHB1c2ggKi8gcCguLi5pbnB1dHMpIHtcbiAgICAgICAgICAgIF9pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgICBfaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gZ3JvdXAucHVzaChpbnB1dCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKiByZW1vdmUgKi8gcigpIHtcbiAgICAgICAgICAgIF9pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBncm91cC5zcGxpY2UoZ3JvdXAuaW5kZXhPZihpbnB1dCksIDEpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBpbml0X2JpbmRpbmdfZ3JvdXBfZHluYW1pYyhncm91cCwgaW5kZXhlcykge1xuICAgIGxldCBfZ3JvdXAgPSBnZXRfYmluZGluZ19ncm91cChncm91cCk7XG4gICAgbGV0IF9pbnB1dHM7XG4gICAgZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBncm91cCA9IGdyb3VwW2luZGV4ZXNbaV1dID0gZ3JvdXBbaW5kZXhlc1tpXV0gfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoKCkge1xuICAgICAgICBfaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gX2dyb3VwLnB1c2goaW5wdXQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBfaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gX2dyb3VwLnNwbGljZShfZ3JvdXAuaW5kZXhPZihpbnB1dCksIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyogdXBkYXRlICovIHUobmV3X2luZGV4ZXMpIHtcbiAgICAgICAgICAgIGluZGV4ZXMgPSBuZXdfaW5kZXhlcztcbiAgICAgICAgICAgIGNvbnN0IG5ld19ncm91cCA9IGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgIGlmIChuZXdfZ3JvdXAgIT09IF9ncm91cCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIF9ncm91cCA9IG5ld19ncm91cDtcbiAgICAgICAgICAgICAgICBwdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qIHB1c2ggKi8gcCguLi5pbnB1dHMpIHtcbiAgICAgICAgICAgIF9pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgICBwdXNoKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qIHJlbW92ZSAqLyByOiByZW1vdmVcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5mdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuZnVuY3Rpb24gaW5pdF9jbGFpbV9pbmZvKG5vZGVzKSB7XG4gICAgaWYgKG5vZGVzLmNsYWltX2luZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvID0geyBsYXN0X2luZGV4OiAwLCB0b3RhbF9jbGFpbWVkOiAwIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY2xhaW1fbm9kZShub2RlcywgcHJlZGljYXRlLCBwcm9jZXNzTm9kZSwgY3JlYXRlTm9kZSwgZG9udFVwZGF0ZUxhc3RJbmRleCA9IGZhbHNlKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgbm9kZXMgaW4gYW4gb3JkZXIgc3VjaCB0aGF0IHdlIGxlbmd0aGVuIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IHJlc3VsdE5vZGUgPSAoKCkgPT4ge1xuICAgICAgICAvLyBXZSBmaXJzdCB0cnkgdG8gZmluZCBhbiBlbGVtZW50IGFmdGVyIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZmluZCBvbmUgYmVmb3JlXG4gICAgICAgIC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBzbyB0aGF0IHdlIGRvbid0IGdvIHRvbyBmYXIgYmFja1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIHNwbGljZWQgYmVmb3JlIHRoZSBsYXN0X2luZGV4LCB3ZSBkZWNyZWFzZSBpdFxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZSwgd2UgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZSgpO1xuICAgIH0pKCk7XG4gICAgcmVzdWx0Tm9kZS5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICByZXR1cm4gcmVzdWx0Tm9kZTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgY3JlYXRlX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IG5hbWUsIChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1vdmUuZm9yRWFjaCh2ID0+IG5vZGUucmVtb3ZlQXR0cmlidXRlKHYpKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCAoKSA9PiBjcmVhdGVfZWxlbWVudChuYW1lKSk7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV9zdmdfZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIHN2Z19lbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDMsIChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSAnJyArIGRhdGE7XG4gICAgICAgIGlmIChub2RlLmRhdGEuc3RhcnRzV2l0aChkYXRhU3RyKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuZGF0YS5sZW5ndGggIT09IGRhdGFTdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3BsaXRUZXh0KGRhdGFTdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IGRhdGFTdHI7XG4gICAgICAgIH1cbiAgICB9LCAoKSA9PiB0ZXh0KGRhdGEpLCB0cnVlIC8vIFRleHQgbm9kZXMgc2hvdWxkIG5vdCB1cGRhdGUgbGFzdCBpbmRleCBzaW5jZSBpdCBpcyBsaWtlbHkgbm90IHdvcnRoIGl0IHRvIGVsaW1pbmF0ZSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGFjdHVhbCBlbGVtZW50c1xuICAgICk7XG59XG5mdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuICAgIHJldHVybiBjbGFpbV90ZXh0KG5vZGVzLCAnICcpO1xufVxuZnVuY3Rpb24gY2xhaW1fY29tbWVudChub2RlcywgZGF0YSkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCwgKG5vZGUpID0+IHtcbiAgICAgICAgbm9kZS5kYXRhID0gJycgKyBkYXRhO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sICgpID0+IGNvbW1lbnQoZGF0YSksIHRydWUpO1xufVxuZnVuY3Rpb24gZmluZF9jb21tZW50KG5vZGVzLCB0ZXh0LCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gY2xhaW1faHRtbF90YWcobm9kZXMsIGlzX3N2Zykge1xuICAgIC8vIGZpbmQgaHRtbCBvcGVuaW5nIHRhZ1xuICAgIGNvbnN0IHN0YXJ0X2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfU1RBUlQnLCAwKTtcbiAgICBjb25zdCBlbmRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19FTkQnLCBzdGFydF9pbmRleCk7XG4gICAgaWYgKHN0YXJ0X2luZGV4ID09PSBlbmRfaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKHVuZGVmaW5lZCwgaXNfc3ZnKTtcbiAgICB9XG4gICAgaW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcbiAgICBjb25zdCBodG1sX3RhZ19ub2RlcyA9IG5vZGVzLnNwbGljZShzdGFydF9pbmRleCwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbMF0pO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1todG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxXSk7XG4gICAgY29uc3QgY2xhaW1lZF9ub2RlcyA9IGh0bWxfdGFnX25vZGVzLnNsaWNlKDEsIGh0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDEpO1xuICAgIGZvciAoY29uc3QgbiBvZiBjbGFpbWVkX25vZGVzKSB7XG4gICAgICAgIG4uY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oY2xhaW1lZF9ub2RlcywgaXNfc3ZnKTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhKHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0LmRhdGEgPT09IGRhdGEpXG4gICAgICAgIHJldHVybjtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSwgYXR0cl92YWx1ZSkge1xuICAgIGlmICh+Y29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMuaW5kZXhPZihhdHRyX3ZhbHVlKSkge1xuICAgICAgICBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRfZGF0YSh0ZXh0LCBkYXRhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF90eXBlKGlucHV0LCB0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaW5wdXQudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtb3VudGluZyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcbiAgICBjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRfb3B0aW9uICYmIHNlbGVjdGVkX29wdGlvbi5fX3ZhbHVlO1xufVxuZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX3ZhbHVlKHNlbGVjdCkge1xuICAgIHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgb3B0aW9uID0+IG9wdGlvbi5fX3ZhbHVlKTtcbn1cbi8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4ndCBiZSBhIGNvbnN0YW50IGFzIHRoYXQgd291bGRuJ3QgYmUgdHJlZS1zaGFrZWFibGVcbi8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgaW5zdGVhZFxubGV0IGNyb3Nzb3JpZ2luO1xuZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3Jvc3NvcmlnaW4gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY3Jvc3NvcmlnaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcm9zc29yaWdpbjtcbn1cbmZ1bmN0aW9uIGFkZF9yZXNpemVfbGlzdGVuZXIobm9kZSwgZm4pIHtcbiAgICBjb25zdCBjb21wdXRlZF9zdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKGNvbXB1dGVkX3N0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgY29uc3QgaWZyYW1lID0gZWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyAnICtcbiAgICAgICAgJ292ZXJmbG93OiBoaWRkZW47IGJvcmRlcjogMDsgb3BhY2l0eTogMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6IC0xOycpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICBpZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICBjb25zdCBjcm9zc29yaWdpbiA9IGlzX2Nyb3Nzb3JpZ2luKCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlO1xuICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICBpZnJhbWUuc3JjID0gXCJkYXRhOnRleHQvaHRtbCw8c2NyaXB0Pm9ucmVzaXplPWZ1bmN0aW9uKCl7cGFyZW50LnBvc3RNZXNzYWdlKDAsJyonKX08L3NjcmlwdD5cIjtcbiAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4od2luZG93LCAnbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKGlmcmFtZS5jb250ZW50V2luZG93LCAncmVzaXplJywgZm4pO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGFuIGluaXRpYWwgcmVzaXplIGV2ZW50IGlzIGZpcmVkIF9hZnRlcl8gdGhlIGlmcmFtZSBpcyBsb2FkZWQgKHdoaWNoIGlzIGFzeW5jaHJvbm91cylcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy80MjMzXG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBlbmQobm9kZSwgaWZyYW1lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5zdWJzY3JpYmUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoKGlmcmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdFt0b2dnbGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbn1cbmZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCk7XG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxdWVyeV9zZWxlY3Rvcl9hbGwoc2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuZnVuY3Rpb24gaGVhZF9zZWxlY3Rvcihub2RlSWQsIGhlYWQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgc3RhcnRlZCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGhlYWQuY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSBub2RlLnRleHRDb250ZW50LnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fRU5EYCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWQgLT0gMTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9TVEFSVGApIHtcbiAgICAgICAgICAgICAgICBzdGFydGVkICs9IDE7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnRlZCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmlzX3N2ZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzX3N2ZyA9IGlzX3N2ZztcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICB9XG4gICAgbShodG1sLCB0YXJnZXQsIGFuY2hvciA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX3N2ZylcbiAgICAgICAgICAgICAgICB0aGlzLmUgPSBzdmdfZWxlbWVudCh0YXJnZXQubm9kZU5hbWUpO1xuICAgICAgICAgICAgLyoqICM3MzY0ICB0YXJnZXQgZm9yIDx0ZW1wbGF0ZT4gbWF5IGJlIHByb3ZpZGVkIGFzICNkb2N1bWVudC1mcmFnbWVudCgxMSkgKi9cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmUgPSBlbGVtZW50KCh0YXJnZXQubm9kZVR5cGUgPT09IDExID8gJ1RFTVBMQVRFJyA6IHRhcmdldC5ub2RlTmFtZSkpO1xuICAgICAgICAgICAgdGhpcy50ID0gdGFyZ2V0LnRhZ05hbWUgIT09ICdURU1QTEFURScgPyB0YXJnZXQgOiB0YXJnZXQuY29udGVudDtcbiAgICAgICAgICAgIHRoaXMuYyhodG1sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkoYW5jaG9yKTtcbiAgICB9XG4gICAgaChodG1sKSB7XG4gICAgICAgIHRoaXMuZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB0aGlzLm4gPSBBcnJheS5mcm9tKHRoaXMuZS5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJyA/IHRoaXMuZS5jb250ZW50LmNoaWxkTm9kZXMgOiB0aGlzLmUuY2hpbGROb2Rlcyk7XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnQodGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcChodG1sKSB7XG4gICAgICAgIHRoaXMuZCgpO1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgICAgIHRoaXMuaSh0aGlzLmEpO1xuICAgIH1cbiAgICBkKCkge1xuICAgICAgICB0aGlzLm4uZm9yRWFjaChkZXRhY2gpO1xuICAgIH1cbn1cbmNsYXNzIEh0bWxUYWdIeWRyYXRpb24gZXh0ZW5kcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3RvcihjbGFpbWVkX25vZGVzLCBpc19zdmcgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihpc19zdmcpO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgICAgICB0aGlzLmwgPSBjbGFpbWVkX25vZGVzO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMubCkge1xuICAgICAgICAgICAgdGhpcy5uID0gdGhpcy5sO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuYyhodG1sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0X2h5ZHJhdGlvbih0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dHJpYnV0ZV90b19vYmplY3QoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMoZWxlbWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIHJlc3VsdFtub2RlLnNsb3QgfHwgJ2RlZmF1bHQnXSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50KGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IGNvbXBvbmVudChwcm9wcyk7XG59XG5cbi8vIHdlIG5lZWQgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGZvciBtdWx0aXBsZSBkb2N1bWVudHMgYmVjYXVzZSBhIFN2ZWx0ZSBhcHBsaWNhdGlvbiBjb3VsZCBhbHNvIGNvbnRhaW4gaWZyYW1lc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMzYyNFxuY29uc3QgbWFuYWdlZF9zdHlsZXMgPSBuZXcgTWFwKCk7XG5sZXQgYWN0aXZlID0gMDtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIGxldCBoYXNoID0gNTM4MTtcbiAgICBsZXQgaSA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpIF4gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5mdW5jdGlvbiBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKSB7XG4gICAgY29uc3QgaW5mbyA9IHsgc3R5bGVzaGVldDogYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSksIHJ1bGVzOiB7fSB9O1xuICAgIG1hbmFnZWRfc3R5bGVzLnNldChkb2MsIGluZm8pO1xuICAgIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gY3JlYXRlX3J1bGUobm9kZSwgYSwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNlLCBmbiwgdWlkID0gMCkge1xuICAgIGNvbnN0IHN0ZXAgPSAxNi42NjYgLyBkdXJhdGlvbjtcbiAgICBsZXQga2V5ZnJhbWVzID0gJ3tcXG4nO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDw9IDE7IHAgKz0gc3RlcCkge1xuICAgICAgICBjb25zdCB0ID0gYSArIChiIC0gYSkgKiBlYXNlKHApO1xuICAgICAgICBrZXlmcmFtZXMgKz0gcCAqIDEwMCArIGAleyR7Zm4odCwgMSAtIHQpfX1cXG5gO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0ga2V5ZnJhbWVzICsgYDEwMCUgeyR7Zm4oYiwgMSAtIGIpfX1cXG59YDtcbiAgICBjb25zdCBuYW1lID0gYF9fc3ZlbHRlXyR7aGFzaChydWxlKX1fJHt1aWR9YDtcbiAgICBjb25zdCBkb2MgPSBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSk7XG4gICAgY29uc3QgeyBzdHlsZXNoZWV0LCBydWxlcyB9ID0gbWFuYWdlZF9zdHlsZXMuZ2V0KGRvYykgfHwgY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSk7XG4gICAgaWYgKCFydWxlc1tuYW1lXSkge1xuICAgICAgICBydWxlc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHN0eWxlc2hlZXQuaW5zZXJ0UnVsZShgQGtleWZyYW1lcyAke25hbWV9ICR7cnVsZX1gLCBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnO1xuICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gYCR7YW5pbWF0aW9uID8gYCR7YW5pbWF0aW9ufSwgYCA6ICcnfSR7bmFtZX0gJHtkdXJhdGlvbn1tcyBsaW5lYXIgJHtkZWxheX1tcyAxIGJvdGhgO1xuICAgIGFjdGl2ZSArPSAxO1xuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gZGVsZXRlX3J1bGUobm9kZSwgbmFtZSkge1xuICAgIGNvbnN0IHByZXZpb3VzID0gKG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICBjb25zdCBuZXh0ID0gcHJldmlvdXMuZmlsdGVyKG5hbWVcbiAgICAgICAgPyBhbmltID0+IGFuaW0uaW5kZXhPZihuYW1lKSA8IDAgLy8gcmVtb3ZlIHNwZWNpZmljIGFuaW1hdGlvblxuICAgICAgICA6IGFuaW0gPT4gYW5pbS5pbmRleE9mKCdfX3N2ZWx0ZScpID09PSAtMSAvLyByZW1vdmUgYWxsIFN2ZWx0ZSBhbmltYXRpb25zXG4gICAgKTtcbiAgICBjb25zdCBkZWxldGVkID0gcHJldmlvdXMubGVuZ3RoIC0gbmV4dC5sZW5ndGg7XG4gICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBuZXh0LmpvaW4oJywgJyk7XG4gICAgICAgIGFjdGl2ZSAtPSBkZWxldGVkO1xuICAgICAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgICAgIGNsZWFyX3J1bGVzKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xlYXJfcnVsZXMoKSB7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFuYWdlZF9zdHlsZXMuZm9yRWFjaChpbmZvID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3duZXJOb2RlIH0gPSBpbmZvLnN0eWxlc2hlZXQ7XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBvd25lck5vZGUgaWYgaXQgcnVucyBvbiBqc2RvbS5cbiAgICAgICAgICAgIGlmIChvd25lck5vZGUpXG4gICAgICAgICAgICAgICAgZGV0YWNoKG93bmVyTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtYW5hZ2VkX3N0eWxlcy5jbGVhcigpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfYW5pbWF0aW9uKG5vZGUsIGZyb20sIGZuLCBwYXJhbXMpIHtcbiAgICBpZiAoIWZyb20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoZnJvbS5sZWZ0ID09PSB0by5sZWZ0ICYmIGZyb20ucmlnaHQgPT09IHRvLnJpZ2h0ICYmIGZyb20udG9wID09PSB0by50b3AgJiYgZnJvbS5ib3R0b20gPT09IHRvLmJvdHRvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBzaG91bGQgdGhpcyBiZSBzZXBhcmF0ZWQgZnJvbSBkZXN0cnVjdHVyaW5nPyBPciBzdGFydC9lbmQgYWRkZWQgdG8gcHVibGljIGFwaSBhbmQgZG9jdW1lbnRhdGlvbj9cbiAgICBzdGFydDogc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzpcbiAgICBlbmQgPSBzdGFydF90aW1lICsgZHVyYXRpb24sIHRpY2sgPSBub29wLCBjc3MgfSA9IGZuKG5vZGUsIHsgZnJvbSwgdG8gfSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgbmFtZTtcbiAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXkpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBuYW1lKTtcbiAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgIGlmICghc3RhcnRlZCAmJiBub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQgJiYgbm93ID49IGVuZCkge1xuICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHN0YXJ0X3RpbWU7XG4gICAgICAgICAgICBjb25zdCB0ID0gMCArIDEgKiBlYXNpbmcocCAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHN0YXJ0KCk7XG4gICAgdGljaygwLCAxKTtcbiAgICByZXR1cm4gc3RvcDtcbn1cbmZ1bmN0aW9uIGZpeF9wb3NpdGlvbihub2RlKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChzdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHN0eWxlO1xuICAgICAgICBjb25zdCBhID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGFkZF90cmFuc2Zvcm0obm9kZSwgYSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkX3RyYW5zZm9ybShub2RlLCBhKSB7XG4gICAgY29uc3QgYiA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGEubGVmdCAhPT0gYi5sZWZ0IHx8IGEudG9wICE9PSBiLnRvcCkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gYCR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHthLmxlZnQgLSBiLmxlZnR9cHgsICR7YS50b3AgLSBiLnRvcH1weClgO1xuICAgIH1cbn1cblxubGV0IGN1cnJlbnRfY29tcG9uZW50O1xuZnVuY3Rpb24gc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkge1xuICAgIGlmICghY3VycmVudF9jb21wb25lbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uJyk7XG4gICAgcmV0dXJuIGN1cnJlbnRfY29tcG9uZW50O1xufVxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdXBkYXRlZCBhZnRlciBhbnkgc3RhdGUgY2hhbmdlLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYmVmb3JlIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1iZWZvcmV1cGRhdGVcbiAqL1xuZnVuY3Rpb24gYmVmb3JlVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYmVmb3JlX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbi8qKlxuICogVGhlIGBvbk1vdW50YCBmdW5jdGlvbiBzY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gYXMgc29vbiBhcyB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgdG8gdGhlIERPTS5cbiAqIEl0IG11c3QgYmUgY2FsbGVkIGR1cmluZyB0aGUgY29tcG9uZW50J3MgaW5pdGlhbGlzYXRpb24gKGJ1dCBkb2Vzbid0IG5lZWQgdG8gbGl2ZSAqaW5zaWRlKiB0aGUgY29tcG9uZW50O1xuICogaXQgY2FuIGJlIGNhbGxlZCBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZSkuXG4gKlxuICogYG9uTW91bnRgIGRvZXMgbm90IHJ1biBpbnNpZGUgYSBbc2VydmVyLXNpZGUgY29tcG9uZW50XSgvZG9jcyNydW4tdGltZS1zZXJ2ZXItc2lkZS1jb21wb25lbnQtYXBpKS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtb25tb3VudFxuICovXG5mdW5jdGlvbiBvbk1vdW50KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fbW91bnQucHVzaChmbik7XG59XG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIHVwZGF0ZWQuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBhZnRlciB0aGUgaW5pdGlhbCBgb25Nb3VudGBcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogT3V0IG9mIGBvbk1vdW50YCwgYGJlZm9yZVVwZGF0ZWAsIGBhZnRlclVwZGF0ZWAgYW5kIGBvbkRlc3Ryb3lgLCB0aGlzIGlzIHRoZVxuICogb25seSBvbmUgdGhhdCBydW5zIGluc2lkZSBhIHNlcnZlci1zaWRlIGNvbXBvbmVudC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtb25kZXN0cm95XG4gKi9cbmZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX2Rlc3Ryb3kucHVzaChmbik7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gZXZlbnQgZGlzcGF0Y2hlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGRpc3BhdGNoIFtjb21wb25lbnQgZXZlbnRzXSgvZG9jcyN0ZW1wbGF0ZS1zeW50YXgtY29tcG9uZW50LWRpcmVjdGl2ZXMtb24tZXZlbnRuYW1lKS5cbiAqIEV2ZW50IGRpc3BhdGNoZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gdGFrZSB0d28gYXJndW1lbnRzOiBgbmFtZWAgYW5kIGBkZXRhaWxgLlxuICpcbiAqIENvbXBvbmVudCBldmVudHMgY3JlYXRlZCB3aXRoIGBjcmVhdGVFdmVudERpc3BhdGNoZXJgIGNyZWF0ZSBhXG4gKiBbQ3VzdG9tRXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudCkuXG4gKiBUaGVzZSBldmVudHMgZG8gbm90IFtidWJibGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTGVhcm4vSmF2YVNjcmlwdC9CdWlsZGluZ19ibG9ja3MvRXZlbnRzI0V2ZW50X2J1YmJsaW5nX2FuZF9jYXB0dXJlKS5cbiAqIFRoZSBgZGV0YWlsYCBhcmd1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgW0N1c3RvbUV2ZW50LmRldGFpbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L2RldGFpbClcbiAqIHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhbnkgdHlwZSBvZiBkYXRhLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1jcmVhdGVldmVudGRpc3BhdGNoZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgIHJldHVybiAodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1t0eXBlXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgLy8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgLy8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgfSk7XG4gICAgICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGNvbXBvbmVudCwgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuICogQXNzb2NpYXRlcyBhbiBhcmJpdHJhcnkgYGNvbnRleHRgIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGNvbXBvbmVudCBhbmQgdGhlIHNwZWNpZmllZCBga2V5YFxuICogYW5kIHJldHVybnMgdGhhdCBvYmplY3QuIFRoZSBjb250ZXh0IGlzIHRoZW4gYXZhaWxhYmxlIHRvIGNoaWxkcmVuIG9mIHRoZSBjb21wb25lbnRcbiAqIChpbmNsdWRpbmcgc2xvdHRlZCBjb250ZW50KSB3aXRoIGBnZXRDb250ZXh0YC5cbiAqXG4gKiBMaWtlIGxpZmVjeWNsZSBmdW5jdGlvbnMsIHRoaXMgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtc2V0Y29udGV4dFxuICovXG5mdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuc2V0KGtleSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29udGV4dCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgYGtleWAuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1nZXRjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuZ2V0KGtleSk7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgd2hvbGUgY29udGV4dCBtYXAgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLiBVc2VmdWwsIGZvciBleGFtcGxlLCBpZiB5b3VcbiAqIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgY29tcG9uZW50IGFuZCB3YW50IHRvIHBhc3MgdGhlIGV4aXN0aW5nIGNvbnRleHQgdG8gaXQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWdldGFsbGNvbnRleHRzXG4gKi9cbmZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0O1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGBrZXlgIGhhcyBiZWVuIHNldCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1oYXNjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuaGFzKGtleSk7XG59XG4vLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0XG4vLyBzaG9ydGhhbmQgZXZlbnRzLCBvciBpZiB3ZSB3YW50IHRvIGltcGxlbWVudFxuLy8gYSByZWFsIGJ1YmJsaW5nIG1lY2hhbmlzbVxuZnVuY3Rpb24gYnViYmxlKGNvbXBvbmVudCwgZXZlbnQpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW2V2ZW50LnR5cGVdO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IGZuLmNhbGwodGhpcywgZXZlbnQpKTtcbiAgICB9XG59XG5cbmNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmNvbnN0IGludHJvcyA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbmNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG5sZXQgcmVuZGVyX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgZmx1c2hfY2FsbGJhY2tzID0gW107XG5jb25zdCByZXNvbHZlZF9wcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xubGV0IHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcbiAgICBpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcbiAgICAgICAgdXBkYXRlX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGljaygpIHtcbiAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcbiAgICByZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWRkX2ZsdXNoX2NhbGxiYWNrKGZuKSB7XG4gICAgZmx1c2hfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuLy8gZmx1c2goKSBjYWxscyBjYWxsYmFja3MgaW4gdGhpcyBvcmRlcjpcbi8vIDEuIEFsbCBiZWZvcmVVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW5cbi8vIDIuIEFsbCBiaW5kOnRoaXMgY2FsbGJhY2tzLCBpbiByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIDMuIEFsbCBhZnRlclVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlbi4gRVhDRVBUXG4vLyAgICBmb3IgYWZ0ZXJVcGRhdGVzIGNhbGxlZCBkdXJpbmcgdGhlIGluaXRpYWwgb25Nb3VudCwgd2hpY2ggYXJlIGNhbGxlZCBpblxuLy8gICAgcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyBTaW5jZSBjYWxsYmFja3MgbWlnaHQgdXBkYXRlIGNvbXBvbmVudCB2YWx1ZXMsIHdoaWNoIGNvdWxkIHRyaWdnZXIgYW5vdGhlclxuLy8gY2FsbCB0byBmbHVzaCgpLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGd1YXJkIGFnYWluc3QgdGhpczpcbi8vIDEuIER1cmluZyBiZWZvcmVVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vICAgIGRpcnR5X2NvbXBvbmVudHMgYXJyYXkgYW5kIHdpbGwgY2F1c2UgYSByZWVudHJhbnQgY2FsbCB0byBmbHVzaCgpLiBCZWNhdXNlXG4vLyAgICB0aGUgZmx1c2ggaW5kZXggaXMga2VwdCBvdXRzaWRlIHRoZSBmdW5jdGlvbiwgdGhlIHJlZW50cmFudCBjYWxsIHdpbGwgcGlja1xuLy8gICAgdXAgd2hlcmUgdGhlIGVhcmxpZXIgY2FsbCBsZWZ0IG9mZiBhbmQgZ28gdGhyb3VnaCBhbGwgZGlydHkgY29tcG9uZW50cy4gVGhlXG4vLyAgICBjdXJyZW50X2NvbXBvbmVudCB2YWx1ZSBpcyBzYXZlZCBhbmQgcmVzdG9yZWQgc28gdGhhdCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbFxuLy8gICAgbm90IGludGVyZmVyZSB3aXRoIHRoZSBcInBhcmVudFwiIGZsdXNoKCkgY2FsbC5cbi8vIDIuIGJpbmQ6dGhpcyBjYWxsYmFja3MgY2Fubm90IHRyaWdnZXIgbmV3IGZsdXNoKCkgY2FsbHMuXG4vLyAzLiBEdXJpbmcgYWZ0ZXJVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBOT1QgaGF2ZSB0aGVpciBhZnRlclVwZGF0ZVxuLy8gICAgY2FsbGJhY2sgY2FsbGVkIGEgc2Vjb25kIHRpbWU7IHRoZSBzZWVuX2NhbGxiYWNrcyBzZXQsIG91dHNpZGUgdGhlIGZsdXNoKClcbi8vICAgIGZ1bmN0aW9uLCBndWFyYW50ZWVzIHRoaXMgYmVoYXZpb3IuXG5jb25zdCBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmxldCBmbHVzaGlkeCA9IDA7IC8vIERvICpub3QqIG1vdmUgdGhpcyBpbnNpZGUgdGhlIGZsdXNoKCkgZnVuY3Rpb25cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIC8vIERvIG5vdCByZWVudGVyIGZsdXNoIHdoaWxlIGRpcnR5IGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGFzIHRoaXMgY2FuXG4gICAgLy8gcmVzdWx0IGluIGFuIGluZmluaXRlIGxvb3AuIEluc3RlYWQsIGxldCB0aGUgaW5uZXIgZmx1c2ggaGFuZGxlIGl0LlxuICAgIC8vIFJlZW50cmFuY3kgaXMgb2sgYWZ0ZXJ3YXJkcyBmb3IgYmluZGluZ3MgZXRjLlxuICAgIGlmIChmbHVzaGlkeCAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNhdmVkX2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIGRvIHtcbiAgICAgICAgLy8gZmlyc3QsIGNhbGwgYmVmb3JlVXBkYXRlIGZ1bmN0aW9uc1xuICAgICAgICAvLyBhbmQgdXBkYXRlIGNvbXBvbmVudHNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlIChmbHVzaGlkeCA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50c1tmbHVzaGlkeF07XG4gICAgICAgICAgICAgICAgZmx1c2hpZHgrKztcbiAgICAgICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB1cGRhdGUoY29tcG9uZW50LiQkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgZGlydHkgc3RhdGUgdG8gbm90IGVuZCB1cCBpbiBhIGRlYWRsb2NrZWQgc3RhdGUgYW5kIHRoZW4gcmV0aHJvd1xuICAgICAgICAgICAgZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgZmx1c2hpZHggPSAwO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgZmx1c2hpZHggPSAwO1xuICAgICAgICB3aGlsZSAoYmluZGluZ19jYWxsYmFja3MubGVuZ3RoKVxuICAgICAgICAgICAgYmluZGluZ19jYWxsYmFja3MucG9wKCkoKTtcbiAgICAgICAgLy8gdGhlbiwgb25jZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBjYWxsXG4gICAgICAgIC8vIGFmdGVyVXBkYXRlIGZ1bmN0aW9ucy4gVGhpcyBtYXkgY2F1c2VcbiAgICAgICAgLy8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSByZW5kZXJfY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWVuX2NhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAgICAgICAgIHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgfSB3aGlsZSAoZGlydHlfY29tcG9uZW50cy5sZW5ndGgpO1xuICAgIHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGZsdXNoX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgIH1cbiAgICB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgc2Vlbl9jYWxsYmFja3MuY2xlYXIoKTtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoc2F2ZWRfY29tcG9uZW50KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAkJC51cGRhdGUoKTtcbiAgICAgICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAgICAgY29uc3QgZGlydHkgPSAkJC5kaXJ0eTtcbiAgICAgICAgJCQuZGlydHkgPSBbLTFdO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuICAgICAgICAkJC5hZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbiAgICB9XG59XG4vKipcbiAqIFVzZWZ1bCBmb3IgZXhhbXBsZSB0byBleGVjdXRlIHJlbWFpbmluZyBgYWZ0ZXJVcGRhdGVgIGNhbGxiYWNrcyBiZWZvcmUgZXhlY3V0aW5nIGBkZXN0cm95YC5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcmVuZGVyX2NhbGxiYWNrcyhmbnMpIHtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IFtdO1xuICAgIGNvbnN0IHRhcmdldHMgPSBbXTtcbiAgICByZW5kZXJfY2FsbGJhY2tzLmZvckVhY2goKGMpID0+IGZucy5pbmRleE9mKGMpID09PSAtMSA/IGZpbHRlcmVkLnB1c2goYykgOiB0YXJnZXRzLnB1c2goYykpO1xuICAgIHRhcmdldHMuZm9yRWFjaCgoYykgPT4gYygpKTtcbiAgICByZW5kZXJfY2FsbGJhY2tzID0gZmlsdGVyZWQ7XG59XG5cbmxldCBwcm9taXNlO1xuZnVuY3Rpb24gd2FpdCgpIHtcbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoKG5vZGUsIGRpcmVjdGlvbiwga2luZCkge1xuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoYCR7ZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybyd9JHtraW5kfWApKTtcbn1cbmNvbnN0IG91dHJvaW5nID0gbmV3IFNldCgpO1xubGV0IG91dHJvcztcbmZ1bmN0aW9uIGdyb3VwX291dHJvcygpIHtcbiAgICBvdXRyb3MgPSB7XG4gICAgICAgIHI6IDAsXG4gICAgICAgIGM6IFtdLFxuICAgICAgICBwOiBvdXRyb3MgLy8gcGFyZW50IGdyb3VwXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrX291dHJvcygpIHtcbiAgICBpZiAoIW91dHJvcy5yKSB7XG4gICAgICAgIHJ1bl9hbGwob3V0cm9zLmMpO1xuICAgIH1cbiAgICBvdXRyb3MgPSBvdXRyb3MucDtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25faW4oYmxvY2ssIGxvY2FsKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcbiAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgYmxvY2suaShsb2NhbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLm8pIHtcbiAgICAgICAgaWYgKG91dHJvaW5nLmhhcyhibG9jaykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG91dHJvaW5nLmFkZChibG9jayk7XG4gICAgICAgIG91dHJvcy5jLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmQoMSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJsb2NrLm8obG9jYWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn1cbmNvbnN0IG51bGxfdHJhbnNpdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbmZ1bmN0aW9uIGNyZWF0ZV9pbl90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdpbicgfTtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBsZXQgdGFzaztcbiAgICBsZXQgdWlkID0gMDtcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzLCB1aWQrKyk7XG4gICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHRhc2spXG4gICAgICAgICAgICB0YXNrLmFib3J0KCk7XG4gICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIHRydWUsICdzdGFydCcpKTtcbiAgICAgICAgdGFzayA9IGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oZ28pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnb3V0JyB9O1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgY29uc3QgZ3JvdXAgPSBvdXRyb3M7XG4gICAgZ3JvdXAuciArPSAxO1xuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnc3RhcnQnKSk7XG4gICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tZ3JvdXAucikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHJlc3VsdCBpbiBgZW5kKClgIGJlaW5nIGNhbGxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gY2xlYW4gdXAgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxIC0gdCwgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdvKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuZChyZXNldCkge1xuICAgICAgICAgICAgaWYgKHJlc2V0ICYmIGNvbmZpZy50aWNrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnRpY2soMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnYm90aCcgfTtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICBsZXQgdCA9IGludHJvID8gMCA6IDE7XG4gICAgbGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcbiAgICBmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuICAgICAgICBjb25zdCBkID0gKHByb2dyYW0uYiAtIHQpO1xuICAgICAgICBkdXJhdGlvbiAqPSBNYXRoLmFicyhkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IHQsXG4gICAgICAgICAgICBiOiBwcm9ncmFtLmIsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydDogcHJvZ3JhbS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJvZ3JhbS5zdGFydCArIGR1cmF0aW9uLFxuICAgICAgICAgICAgZ3JvdXA6IHByb2dyYW0uZ3JvdXBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oYikge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0ge1xuICAgICAgICAgICAgc3RhcnQ6IG5vdygpICsgZGVsYXksXG4gICAgICAgICAgICBiXG4gICAgICAgIH07XG4gICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG4gICAgICAgICAgICBvdXRyb3MuciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBpbnRybywgYW5kIHRoZXJlJ3MgYSBkZWxheSwgd2UgbmVlZCB0byBkb1xuICAgICAgICAgICAgLy8gYW4gaW5pdGlhbCB0aWNrIGFuZC9vciBhcHBseSBDU1MgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHByb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgYiwgJ3N0YXJ0JykpO1xuICAgICAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nX3Byb2dyYW0gJiYgbm93ID4gcGVuZGluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocGVuZGluZ19wcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIHJ1bm5pbmdfcHJvZ3JhbS5iLCBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sIDAsIGVhc2luZywgY29uZmlnLmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCA9IHJ1bm5pbmdfcHJvZ3JhbS5iLCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludHJvIOKAlCB3ZSBjYW4gdGlkeSB1cCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91dHJvIOKAlCBuZWVkcyB0byBiZSBjb29yZGluYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcnVubmluZ19wcm9ncmFtLmdyb3VwLnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKHJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBydW5uaW5nX3Byb2dyYW0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gcnVubmluZ19wcm9ncmFtLmEgKyBydW5uaW5nX3Byb2dyYW0uZCAqIGVhc2luZyhwIC8gcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhIShydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJ1bihiKSB7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZV9wcm9taXNlKHByb21pc2UsIGluZm8pIHtcbiAgICBjb25zdCB0b2tlbiA9IGluZm8udG9rZW4gPSB7fTtcbiAgICBmdW5jdGlvbiB1cGRhdGUodHlwZSwgaW5kZXgsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZm8udG9rZW4gIT09IHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpbmZvLnJlc29sdmVkID0gdmFsdWU7XG4gICAgICAgIGxldCBjaGlsZF9jdHggPSBpbmZvLmN0eDtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZF9jdHggPSBjaGlsZF9jdHguc2xpY2UoKTtcbiAgICAgICAgICAgIGNoaWxkX2N0eFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0eXBlICYmIChpbmZvLmN1cnJlbnQgPSB0eXBlKShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgbmVlZHNfZmx1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uYmxvY2spIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzLmZvckVhY2goKGJsb2NrLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBpbmRleCAmJiBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrc1tpXSA9PT0gYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5ibG9ja3NbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2suZCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICAgICAgYmxvY2subShpbmZvLm1vdW50KCksIGluZm8uYW5jaG9yKTtcbiAgICAgICAgICAgIG5lZWRzX2ZsdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrcylcbiAgICAgICAgICAgIGluZm8uYmxvY2tzW2luZGV4XSA9IGJsb2NrO1xuICAgICAgICBpZiAobmVlZHNfZmx1c2gpIHtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzX3Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgY29uc3QgY3VycmVudF9jb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5jYXRjaCwgMiwgaW5mby5lcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICAgICAgaWYgKCFpbmZvLmhhc0NhdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBhIHRoZW4vY2F0Y2ggYmxvY2ssIGRlc3Ryb3kgaXRcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby5wZW5kaW5nKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5wZW5kaW5nLCAwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHByb21pc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaChpbmZvLCBjdHgsIGRpcnR5KSB7XG4gICAgY29uc3QgY2hpbGRfY3R4ID0gY3R4LnNsaWNlKCk7XG4gICAgY29uc3QgeyByZXNvbHZlZCB9ID0gaW5mbztcbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgY2hpbGRfY3R4W2luZm8udmFsdWVdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8uY2F0Y2gpIHtcbiAgICAgICAgY2hpbGRfY3R4W2luZm8uZXJyb3JdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIGluZm8uYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbn1cblxuY29uc3QgZ2xvYmFscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgIDogZ2xvYmFsKTtcblxuZnVuY3Rpb24gZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZCgxKTtcbiAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG59XG5mdW5jdGlvbiBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZml4X2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKG9sZF9ibG9ja3MsIGRpcnR5LCBnZXRfa2V5LCBkeW5hbWljLCBjdHgsIGxpc3QsIGxvb2t1cCwgbm9kZSwgZGVzdHJveSwgY3JlYXRlX2VhY2hfYmxvY2ssIG5leHQsIGdldF9jb250ZXh0KSB7XG4gICAgbGV0IG8gPSBvbGRfYmxvY2tzLmxlbmd0aDtcbiAgICBsZXQgbiA9IGxpc3QubGVuZ3RoO1xuICAgIGxldCBpID0gbztcbiAgICBjb25zdCBvbGRfaW5kZXhlcyA9IHt9O1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG4gICAgY29uc3QgbmV3X2Jsb2NrcyA9IFtdO1xuICAgIGNvbnN0IG5ld19sb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGVsdGFzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgICBpID0gbjtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2N0eCA9IGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgICBibG9jayA9IGNyZWF0ZV9lYWNoX2Jsb2NrKGtleSwgY2hpbGRfY3R4KTtcbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICAvLyBkZWZlciB1cGRhdGVzIHVudGlsIGFsbCB0aGUgRE9NIHNodWZmbGluZyBpcyBkb25lXG4gICAgICAgICAgICB1cGRhdGVzLnB1c2goKCkgPT4gYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3X2xvb2t1cC5zZXQoa2V5LCBuZXdfYmxvY2tzW2ldID0gYmxvY2spO1xuICAgICAgICBpZiAoa2V5IGluIG9sZF9pbmRleGVzKVxuICAgICAgICAgICAgZGVsdGFzLnNldChrZXksIE1hdGguYWJzKGkgLSBvbGRfaW5kZXhlc1trZXldKSk7XG4gICAgfVxuICAgIGNvbnN0IHdpbGxfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcbiAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgIGJsb2NrLm0obm9kZSwgbmV4dCk7XG4gICAgICAgIGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG4gICAgICAgIG5leHQgPSBibG9jay5maXJzdDtcbiAgICAgICAgbi0tO1xuICAgIH1cbiAgICB3aGlsZSAobyAmJiBuKSB7XG4gICAgICAgIGNvbnN0IG5ld19ibG9jayA9IG5ld19ibG9ja3NbbiAtIDFdO1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW28gLSAxXTtcbiAgICAgICAgY29uc3QgbmV3X2tleSA9IG5ld19ibG9jay5rZXk7XG4gICAgICAgIGNvbnN0IG9sZF9rZXkgPSBvbGRfYmxvY2sua2V5O1xuICAgICAgICBpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIGJsb2NrXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbG9va3VwLmhhcyhuZXdfa2V5KSB8fCB3aWxsX21vdmUuaGFzKG5ld19rZXkpKSB7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YXMuZ2V0KG5ld19rZXkpID4gZGVsdGFzLmdldChvbGRfa2V5KSkge1xuICAgICAgICAgICAgZGlkX21vdmUuYWRkKG5ld19rZXkpO1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aWxsX21vdmUuYWRkKG9sZF9rZXkpO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChvLS0pIHtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvXTtcbiAgICAgICAgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfYmxvY2sua2V5KSlcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgIH1cbiAgICB3aGlsZSAobilcbiAgICAgICAgaW5zZXJ0KG5ld19ibG9ja3NbbiAtIDFdKTtcbiAgICBydW5fYWxsKHVwZGF0ZXMpO1xuICAgIHJldHVybiBuZXdfYmxvY2tzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGN0eCwgbGlzdCwgZ2V0X2NvbnRleHQsIGdldF9rZXkpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSkpO1xuICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGF2ZSBkdXBsaWNhdGUga2V5cyBpbiBhIGtleWVkIGVhY2gnKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0X3NwcmVhZF91cGRhdGUobGV2ZWxzLCB1cGRhdGVzKSB7XG4gICAgY29uc3QgdXBkYXRlID0ge307XG4gICAgY29uc3QgdG9fbnVsbF9vdXQgPSB7fTtcbiAgICBjb25zdCBhY2NvdW50ZWRfZm9yID0geyAkJHNjb3BlOiAxIH07XG4gICAgbGV0IGkgPSBsZXZlbHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgbyA9IGxldmVsc1tpXTtcbiAgICAgICAgY29uc3QgbiA9IHVwZGF0ZXNbaV07XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG4pKVxuICAgICAgICAgICAgICAgICAgICB0b19udWxsX291dFtrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRlZF9mb3Jba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVba2V5XSA9IG5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbHNbaV0gPSBuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9fbnVsbF9vdXQpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHVwZGF0ZSkpXG4gICAgICAgICAgICB1cGRhdGVba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGdldF9zcHJlYWRfb2JqZWN0KHNwcmVhZF9wcm9wcykge1xuICAgIHJldHVybiB0eXBlb2Ygc3ByZWFkX3Byb3BzID09PSAnb2JqZWN0JyAmJiBzcHJlYWRfcHJvcHMgIT09IG51bGwgPyBzcHJlYWRfcHJvcHMgOiB7fTtcbn1cblxuY29uc3QgX2Jvb2xlYW5fYXR0cmlidXRlcyA9IFtcbiAgICAnYWxsb3dmdWxsc2NyZWVuJyxcbiAgICAnYWxsb3dwYXltZW50cmVxdWVzdCcsXG4gICAgJ2FzeW5jJyxcbiAgICAnYXV0b2ZvY3VzJyxcbiAgICAnYXV0b3BsYXknLFxuICAgICdjaGVja2VkJyxcbiAgICAnY29udHJvbHMnLFxuICAgICdkZWZhdWx0JyxcbiAgICAnZGVmZXInLFxuICAgICdkaXNhYmxlZCcsXG4gICAgJ2Zvcm1ub3ZhbGlkYXRlJyxcbiAgICAnaGlkZGVuJyxcbiAgICAnaW5lcnQnLFxuICAgICdpc21hcCcsXG4gICAgJ2xvb3AnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ211dGVkJyxcbiAgICAnbm9tb2R1bGUnLFxuICAgICdub3ZhbGlkYXRlJyxcbiAgICAnb3BlbicsXG4gICAgJ3BsYXlzaW5saW5lJyxcbiAgICAncmVhZG9ubHknLFxuICAgICdyZXF1aXJlZCcsXG4gICAgJ3JldmVyc2VkJyxcbiAgICAnc2VsZWN0ZWQnXG5dO1xuLyoqXG4gKiBMaXN0IG9mIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzIChlLmcuIGA8aW5wdXQgZGlzYWJsZWQ+YCkuXG4gKiBTb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuICovXG5jb25zdCBib29sZWFuX2F0dHJpYnV0ZXMgPSBuZXcgU2V0KFsuLi5fYm9vbGVhbl9hdHRyaWJ1dGVzXSk7XG5cbi8qKiByZWdleCBvZiBhbGwgaHRtbCB2b2lkIGVsZW1lbnQgbmFtZXMgKi9cbmNvbnN0IHZvaWRfZWxlbWVudF9uYW1lcyA9IC9eKD86YXJlYXxiYXNlfGJyfGNvbHxjb21tYW5kfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC87XG5mdW5jdGlvbiBpc192b2lkKG5hbWUpIHtcbiAgICByZXR1cm4gdm9pZF9lbGVtZW50X25hbWVzLnRlc3QobmFtZSkgfHwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAnIWRvY3R5cGUnO1xufVxuXG5jb25zdCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciA9IC9bXFxzJ1wiPi89XFx1e0ZERDB9LVxcdXtGREVGfVxcdXtGRkZFfVxcdXtGRkZGfVxcdXsxRkZGRX1cXHV7MUZGRkZ9XFx1ezJGRkZFfVxcdXsyRkZGRn1cXHV7M0ZGRkV9XFx1ezNGRkZGfVxcdXs0RkZGRX1cXHV7NEZGRkZ9XFx1ezVGRkZFfVxcdXs1RkZGRn1cXHV7NkZGRkV9XFx1ezZGRkZGfVxcdXs3RkZGRX1cXHV7N0ZGRkZ9XFx1ezhGRkZFfVxcdXs4RkZGRn1cXHV7OUZGRkV9XFx1ezlGRkZGfVxcdXtBRkZGRX1cXHV7QUZGRkZ9XFx1e0JGRkZFfVxcdXtCRkZGRn1cXHV7Q0ZGRkV9XFx1e0NGRkZGfVxcdXtERkZGRX1cXHV7REZGRkZ9XFx1e0VGRkZFfVxcdXtFRkZGRn1cXHV7RkZGRkV9XFx1e0ZGRkZGfVxcdXsxMEZGRkV9XFx1ezEwRkZGRn1dL3U7XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNub25jaGFyYWN0ZXJcbmZ1bmN0aW9uIHNwcmVhZChhcmdzLCBhdHRyc190b19hZGQpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uYXJncyk7XG4gICAgaWYgKGF0dHJzX3RvX2FkZCkge1xuICAgICAgICBjb25zdCBjbGFzc2VzX3RvX2FkZCA9IGF0dHJzX3RvX2FkZC5jbGFzc2VzO1xuICAgICAgICBjb25zdCBzdHlsZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLnN0eWxlcztcbiAgICAgICAgaWYgKGNsYXNzZXNfdG9fYWRkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5jbGFzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyArPSAnICcgKyBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGVzX3RvX2FkZCkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuc3R5bGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlc190b19hZGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcobWVyZ2Vfc3NyX3N0eWxlcyhhdHRyaWJ1dGVzLnN0eWxlLCBzdHlsZXNfdG9fYWRkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGlmIChpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3Rlci50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICBlbHNlIGlmIChib29sZWFuX2F0dHJpYnV0ZXMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gYCAke25hbWV9PVwiJHt2YWx1ZX1cImA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gbWVyZ2Vfc3NyX3N0eWxlcyhzdHlsZV9hdHRyaWJ1dGUsIHN0eWxlX2RpcmVjdGl2ZSkge1xuICAgIGNvbnN0IHN0eWxlX29iamVjdCA9IHt9O1xuICAgIGZvciAoY29uc3QgaW5kaXZpZHVhbF9zdHlsZSBvZiBzdHlsZV9hdHRyaWJ1dGUuc3BsaXQoJzsnKSkge1xuICAgICAgICBjb25zdCBjb2xvbl9pbmRleCA9IGluZGl2aWR1YWxfc3R5bGUuaW5kZXhPZignOicpO1xuICAgICAgICBjb25zdCBuYW1lID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZSgwLCBjb2xvbl9pbmRleCkudHJpbSgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoY29sb25faW5kZXggKyAxKS50cmltKCk7XG4gICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzdHlsZV9vYmplY3RbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHN0eWxlX2RpcmVjdGl2ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlX2RpcmVjdGl2ZVtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBzdHlsZV9vYmplY3RbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZV9vYmplY3RbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlX29iamVjdDtcbn1cbmNvbnN0IEFUVFJfUkVHRVggPSAvWyZcIl0vZztcbmNvbnN0IENPTlRFTlRfUkVHRVggPSAvWyY8XS9nO1xuLyoqXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBwZXJmb3JtYW5jZSBzZW5zaXRpdmUgYW5kIGhhcyBiZWVuIG9wdGltaXplZFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzU3MDFcbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHZhbHVlLCBpc19hdHRyID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdHIgPSBTdHJpbmcodmFsdWUpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBpc19hdHRyID8gQVRUUl9SRUdFWCA6IENPTlRFTlRfUkVHRVg7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgIGxldCBlc2NhcGVkID0gJyc7XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIHdoaWxlIChwYXR0ZXJuLnRlc3Qoc3RyKSkge1xuICAgICAgICBjb25zdCBpID0gcGF0dGVybi5sYXN0SW5kZXggLSAxO1xuICAgICAgICBjb25zdCBjaCA9IHN0cltpXTtcbiAgICAgICAgZXNjYXBlZCArPSBzdHIuc3Vic3RyaW5nKGxhc3QsIGkpICsgKGNoID09PSAnJicgPyAnJmFtcDsnIDogKGNoID09PSAnXCInID8gJyZxdW90OycgOiAnJmx0OycpKTtcbiAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gZXNjYXBlZCArIHN0ci5zdWJzdHJpbmcobGFzdCk7XG59XG5mdW5jdGlvbiBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKHZhbHVlKSB7XG4gICAgLy8ga2VlcCBib29sZWFucywgbnVsbCwgYW5kIHVuZGVmaW5lZCBmb3IgdGhlIHNha2Ugb2YgYHNwcmVhZGBcbiAgICBjb25zdCBzaG91bGRfZXNjYXBlID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jyk7XG4gICAgcmV0dXJuIHNob3VsZF9lc2NhcGUgPyBlc2NhcGUodmFsdWUsIHRydWUpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBlc2NhcGVfb2JqZWN0KG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICByZXN1bHRba2V5XSA9IGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZWFjaChpdGVtcywgZm4pIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gZm4oaXRlbXNbaV0sIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuY29uc3QgbWlzc2luZ19jb21wb25lbnQgPSB7XG4gICAgJCRyZW5kZXI6ICgpID0+ICcnXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVfY29tcG9uZW50KGNvbXBvbmVudCwgbmFtZSkge1xuICAgIGlmICghY29tcG9uZW50IHx8ICFjb21wb25lbnQuJCRyZW5kZXIpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzdmVsdGU6Y29tcG9uZW50JylcbiAgICAgICAgICAgIG5hbWUgKz0gJyB0aGlzPXsuLi59JztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGA8JHtuYW1lfT4gaXMgbm90IGEgdmFsaWQgU1NSIGNvbXBvbmVudC4gWW91IG1heSBuZWVkIHRvIHJldmlldyB5b3VyIGJ1aWxkIGNvbmZpZyB0byBlbnN1cmUgdGhhdCBkZXBlbmRlbmNpZXMgYXJlIGNvbXBpbGVkLCByYXRoZXIgdGhhbiBpbXBvcnRlZCBhcyBwcmUtY29tcGlsZWQgbW9kdWxlcy4gT3RoZXJ3aXNlIHlvdSBtYXkgbmVlZCB0byBmaXggYSA8JHtuYW1lfT4uYCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBkZWJ1ZyhmaWxlLCBsaW5lLCBjb2x1bW4sIHZhbHVlcykge1xuICAgIGNvbnNvbGUubG9nKGB7QGRlYnVnfSAke2ZpbGUgPyBmaWxlICsgJyAnIDogJyd9KCR7bGluZX06JHtjb2x1bW59KWApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyh2YWx1ZXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICByZXR1cm4gJyc7XG59XG5sZXQgb25fZGVzdHJveTtcbmZ1bmN0aW9uIGNyZWF0ZV9zc3JfY29tcG9uZW50KGZuKSB7XG4gICAgZnVuY3Rpb24gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICAgICAgY29uc3QgJCQgPSB7XG4gICAgICAgICAgICBvbl9kZXN0cm95LFxuICAgICAgICAgICAgY29udGV4dDogbmV3IE1hcChjb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgICAgIC8vIHRoZXNlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZGlzY2FyZGVkXG4gICAgICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpXG4gICAgICAgIH07XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudCh7ICQkIH0pO1xuICAgICAgICBjb25zdCBodG1sID0gZm4ocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzKTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyOiAocHJvcHMgPSB7fSwgeyAkJHNsb3RzID0ge30sIGNvbnRleHQgPSBuZXcgTWFwKCkgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBvbl9kZXN0cm95ID0gW107XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHRpdGxlOiAnJywgaGVhZDogJycsIGNzczogbmV3IFNldCgpIH07XG4gICAgICAgICAgICBjb25zdCBodG1sID0gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywge30sICQkc2xvdHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgcnVuX2FsbChvbl9kZXN0cm95KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaHRtbCxcbiAgICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogQXJyYXkuZnJvbShyZXN1bHQuY3NzKS5tYXAoY3NzID0+IGNzcy5jb2RlKS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBudWxsIC8vIFRPRE9cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWQ6IHJlc3VsdC50aXRsZSArIHJlc3VsdC5oZWFkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAkJHJlbmRlclxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRfYXR0cmlidXRlKG5hbWUsIHZhbHVlLCBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGJvb2xlYW4gJiYgIXZhbHVlKSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IGFzc2lnbm1lbnQgPSAoYm9vbGVhbiAmJiB2YWx1ZSA9PT0gdHJ1ZSkgPyAnJyA6IGA9XCIke2VzY2FwZSh2YWx1ZSwgdHJ1ZSl9XCJgO1xuICAgIHJldHVybiBgICR7bmFtZX0ke2Fzc2lnbm1lbnR9YDtcbn1cbmZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gY2xhc3NlcyA/IGAgY2xhc3M9XCIke2NsYXNzZXN9XCJgIDogJyc7XG59XG5mdW5jdGlvbiBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZV9vYmplY3QpXG4gICAgICAgIC5maWx0ZXIoa2V5ID0+IHN0eWxlX29iamVjdFtrZXldKVxuICAgICAgICAubWFwKGtleSA9PiBgJHtrZXl9OiAke2VzY2FwZV9hdHRyaWJ1dGVfdmFsdWUoc3R5bGVfb2JqZWN0W2tleV0pfTtgKVxuICAgICAgICAuam9pbignICcpO1xufVxuZnVuY3Rpb24gYWRkX3N0eWxlcyhzdHlsZV9vYmplY3QpIHtcbiAgICBjb25zdCBzdHlsZXMgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCk7XG4gICAgcmV0dXJuIHN0eWxlcyA/IGAgc3R5bGU9XCIke3N0eWxlc31cImAgOiAnJztcbn1cblxuZnVuY3Rpb24gYmluZChjb21wb25lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5kZXggPSBjb21wb25lbnQuJCQucHJvcHNbbmFtZV07XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcG9uZW50LiQkLmJvdW5kW2luZGV4XSA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayhjb21wb25lbnQuJCQuY3R4W2luZGV4XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlX2NvbXBvbmVudChibG9jaykge1xuICAgIGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG4gICAgYmxvY2sgJiYgYmxvY2subChwYXJlbnRfbm9kZXMpO1xufVxuZnVuY3Rpb24gbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgdGFyZ2V0LCBhbmNob3IsIGN1c3RvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IGZyYWdtZW50LCBhZnRlcl91cGRhdGUgfSA9IGNvbXBvbmVudC4kJDtcbiAgICBmcmFnbWVudCAmJiBmcmFnbWVudC5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICBpZiAoIWN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgLy8gb25Nb3VudCBoYXBwZW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBhZnRlclVwZGF0ZVxuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld19vbl9kZXN0cm95ID0gY29tcG9uZW50LiQkLm9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG4gICAgICAgICAgICAvLyBpZiB0aGUgY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIC8vIGl0IHdpbGwgdXBkYXRlIHRoZSBgJCQub25fZGVzdHJveWAgcmVmZXJlbmNlIHRvIGBudWxsYC5cbiAgICAgICAgICAgIC8vIHRoZSBkZXN0cnVjdHVyZWQgb25fZGVzdHJveSBtYXkgc3RpbGwgcmVmZXJlbmNlIHRvIHRoZSBvbGQgYXJyYXlcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuJCQub25fZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuICAgICAgICAgICAgICAgIHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGZsdXNoX3JlbmRlcl9jYWxsYmFja3MoJCQuYWZ0ZXJfdXBkYXRlKTtcbiAgICAgICAgcnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuZChkZXRhY2hpbmcpO1xuICAgICAgICAvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG4gICAgICAgIC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcbiAgICAgICAgJCQub25fZGVzdHJveSA9ICQkLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgJCQuY3R4ID0gW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcbiAgICBpZiAoY29tcG9uZW50LiQkLmRpcnR5WzBdID09PSAtMSkge1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgICAgIGNvbXBvbmVudC4kJC5kaXJ0eS5maWxsKDApO1xuICAgIH1cbiAgICBjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAoMSA8PCAoaSAlIDMxKSk7XG59XG5mdW5jdGlvbiBpbml0KGNvbXBvbmVudCwgb3B0aW9ucywgaW5zdGFuY2UsIGNyZWF0ZV9mcmFnbWVudCwgbm90X2VxdWFsLCBwcm9wcywgYXBwZW5kX3N0eWxlcywgZGlydHkgPSBbLTFdKSB7XG4gICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkID0ge1xuICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgY3R4OiBbXSxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHVwZGF0ZTogbm9vcCxcbiAgICAgICAgbm90X2VxdWFsLFxuICAgICAgICBib3VuZDogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIC8vIGxpZmVjeWNsZVxuICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgIG9uX2Rlc3Ryb3k6IFtdLFxuICAgICAgICBvbl9kaXNjb25uZWN0OiBbXSxcbiAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgIGNvbnRleHQ6IG5ldyBNYXAob3B0aW9ucy5jb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBza2lwX2JvdW5kOiBmYWxzZSxcbiAgICAgICAgcm9vdDogb3B0aW9ucy50YXJnZXQgfHwgcGFyZW50X2NvbXBvbmVudC4kJC5yb290XG4gICAgfTtcbiAgICBhcHBlbmRfc3R5bGVzICYmIGFwcGVuZF9zdHlsZXMoJCQucm9vdCk7XG4gICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgJCQuY3R4ID0gaW5zdGFuY2VcbiAgICAgICAgPyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuICAgICAgICAgICAgaWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAkJC5jdHhbaV0gPSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pXG4gICAgICAgICAgICAgICAgICAgICQkLmJvdW5kW2ldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhZHkpXG4gICAgICAgICAgICAgICAgICAgIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pXG4gICAgICAgIDogW107XG4gICAgJCQudXBkYXRlKCk7XG4gICAgcmVhZHkgPSB0cnVlO1xuICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgLy8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG4gICAgJCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgICAgICBzdGFydF9oeWRyYXRpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnRybylcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcbiAgICAgICAgbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yLCBvcHRpb25zLmN1c3RvbUVsZW1lbnQpO1xuICAgICAgICBlbmRfaHlkcmF0aW5nKCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cbmxldCBTdmVsdGVFbGVtZW50O1xuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uX21vdW50IH0gPSB0aGlzLiQkO1xuICAgICAgICAgICAgdGhpcy4kJC5vbl9kaXNjb25uZWN0ID0gb25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkLnNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy4kJC5zbG90dGVkW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBydW5fYWxsKHRoaXMuJCQub25fZGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgJGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBkZWxlZ2F0ZSB0byBhZGRFdmVudExpc3RlbmVyP1xuICAgICAgICAgICAgaWYgKCFpc19mdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgJHNldCgkJHByb3BzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuJCRzZXQoJCRwcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cy4gVXNlZCB3aGVuIGRldj1mYWxzZS5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgIH1cbiAgICAkb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFpc19mdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoX2Rldih0eXBlLCBkZXRhaWwpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudCh0eXBlLCBPYmplY3QuYXNzaWduKHsgdmVyc2lvbjogJzMuNTguMCcgfSwgZGV0YWlsKSwgeyBidWJibGVzOiB0cnVlIH0pKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBkZXRhY2hfZGV2KG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZScsIHsgbm9kZSB9KTtcbiAgICBkZXRhY2gobm9kZSk7XG59XG5mdW5jdGlvbiBkZXRhY2hfYmV0d2Vlbl9kZXYoYmVmb3JlLCBhZnRlcikge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcgJiYgYmVmb3JlLm5leHRTaWJsaW5nICE9PSBhZnRlcikge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2JlZm9yZV9kZXYoYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYWZ0ZXJfZGV2KGJlZm9yZSkge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3Rlbl9kZXYobm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMsIGhhc19wcmV2ZW50X2RlZmF1bHQsIGhhc19zdG9wX3Byb3BhZ2F0aW9uLCBoYXNfc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24pIHtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBvcHRpb25zID09PSB0cnVlID8gWydjYXB0dXJlJ10gOiBvcHRpb25zID8gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvcHRpb25zKSkgOiBbXTtcbiAgICBpZiAoaGFzX3ByZXZlbnRfZGVmYXVsdClcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3ByZXZlbnREZWZhdWx0Jyk7XG4gICAgaWYgKGhhc19zdG9wX3Byb3BhZ2F0aW9uKVxuICAgICAgICBtb2RpZmllcnMucHVzaCgnc3RvcFByb3BhZ2F0aW9uJyk7XG4gICAgaWYgKGhhc19zdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbicpO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NQWRkRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICBjb25zdCBkaXNwb3NlID0gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cl9kZXYobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlQXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUgfSk7XG4gICAgZWxzZVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldEF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlLCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHByb3BfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRQcm9wZXJ0eScsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gZGF0YXNldF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZS5kYXRhc2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YXNldCcsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0LmRhdGEgPT09IGRhdGEpXG4gICAgICAgIHJldHVybjtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGEnLCB7IG5vZGU6IHRleHQsIGRhdGEgfSk7XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZV9kZXYodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGVfZGV2KHRleHQsIGRhdGEsIGF0dHJfdmFsdWUpIHtcbiAgICBpZiAofmNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLmluZGV4T2YoYXR0cl92YWx1ZSkpIHtcbiAgICAgICAgc2V0X2RhdGFfY29udGVudGVkaXRhYmxlX2Rldih0ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldF9kYXRhX2Rldih0ZXh0LCBkYXRhKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50KGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnc3RyaW5nJyAmJiAhKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBhcmcpKSB7XG4gICAgICAgIGxldCBtc2cgPSAneyNlYWNofSBvbmx5IGl0ZXJhdGVzIG92ZXIgYXJyYXktbGlrZSBvYmplY3RzLic7XG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGFyZyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gYXJnKSB7XG4gICAgICAgICAgICBtc2cgKz0gJyBZb3UgY2FuIHVzZSBhIHNwcmVhZCB0byBjb252ZXJ0IHRoaXMgaXRlcmFibGUgaW50byBhbiBhcnJheS4nO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3Nsb3RzKG5hbWUsIHNsb3QsIGtleXMpIHtcbiAgICBmb3IgKGNvbnN0IHNsb3Rfa2V5IG9mIE9iamVjdC5rZXlzKHNsb3QpKSB7XG4gICAgICAgIGlmICghfmtleXMuaW5kZXhPZihzbG90X2tleSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgPCR7bmFtZX0+IHJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgc2xvdCBcIiR7c2xvdF9rZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQodGFnKSB7XG4gICAgY29uc3QgaXNfc3RyaW5nID0gdHlwZW9mIHRhZyA9PT0gJ3N0cmluZyc7XG4gICAgaWYgKHRhZyAmJiAhaXNfc3RyaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignPHN2ZWx0ZTplbGVtZW50PiBleHBlY3RzIFwidGhpc1wiIGF0dHJpYnV0ZSB0byBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCh0YWcpIHtcbiAgICBpZiAodGFnICYmIGlzX3ZvaWQodGFnKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJHt0YWd9XCI+IGlzIHNlbGYtY2xvc2luZyBhbmQgY2Fubm90IGhhdmUgY29udGVudC5gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudF9kZXYoY29tcG9uZW50LCBwcm9wcykge1xuICAgIGNvbnN0IGVycm9yX21lc3NhZ2UgPSAndGhpcz17Li4ufSBvZiA8c3ZlbHRlOmNvbXBvbmVudD4gc2hvdWxkIHNwZWNpZnkgYSBTdmVsdGUgY29tcG9uZW50Lic7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgY29tcG9uZW50KHByb3BzKTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZS4kJCB8fCAhaW5zdGFuY2UuJHNldCB8fCAhaW5zdGFuY2UuJG9uIHx8ICFpbnN0YW5jZS4kZGVzdHJveSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yX21lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IGVycjtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyAmJiBtZXNzYWdlLmluZGV4T2YoJ2lzIG5vdCBhIGNvbnN0cnVjdG9yJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JfbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzIHdpdGggc29tZSBtaW5vciBkZXYtZW5oYW5jZW1lbnRzLiBVc2VkIHdoZW4gZGV2PXRydWUuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudERldiBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgKCFvcHRpb25zLnRhcmdldCAmJiAhb3B0aW9ucy4kJGlubGluZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIid0YXJnZXQnIGlzIGEgcmVxdWlyZWQgb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgICRkZXN0cm95KCkge1xuICAgICAgICBzdXBlci4kZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb21wb25lbnQgd2FzIGFscmVhZHkgZGVzdHJveWVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAkY2FwdHVyZV9zdGF0ZSgpIHsgfVxuICAgICRpbmplY3Rfc3RhdGUoKSB7IH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyB0byBjcmVhdGUgc3Ryb25nbHkgdHlwZWQgU3ZlbHRlIGNvbXBvbmVudHMuXG4gKiBUaGlzIG9ubHkgZXhpc3RzIGZvciB0eXBpbmcgcHVycG9zZXMgYW5kIHNob3VsZCBiZSB1c2VkIGluIGAuZC50c2AgZmlsZXMuXG4gKlxuICogIyMjIEV4YW1wbGU6XG4gKlxuICogWW91IGhhdmUgY29tcG9uZW50IGxpYnJhcnkgb24gbnBtIGNhbGxlZCBgY29tcG9uZW50LWxpYnJhcnlgLCBmcm9tIHdoaWNoXG4gKiB5b3UgZXhwb3J0IGEgY29tcG9uZW50IGNhbGxlZCBgTXlDb21wb25lbnRgLiBGb3IgU3ZlbHRlK1R5cGVTY3JpcHQgdXNlcnMsXG4gKiB5b3Ugd2FudCB0byBwcm92aWRlIHR5cGluZ3MuIFRoZXJlZm9yZSB5b3UgY3JlYXRlIGEgYGluZGV4LmQudHNgOlxuICogYGBgdHNcbiAqIGltcG9ydCB7IFN2ZWx0ZUNvbXBvbmVudFR5cGVkIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50VHlwZWQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGBgYFxuICogVHlwaW5nIHRoaXMgbWFrZXMgaXQgcG9zc2libGUgZm9yIElERXMgbGlrZSBWUyBDb2RlIHdpdGggdGhlIFN2ZWx0ZSBleHRlbnNpb25cbiAqIHRvIHByb3ZpZGUgaW50ZWxsaXNlbnNlIGFuZCB0byB1c2UgdGhlIGNvbXBvbmVudCBsaWtlIHRoaXMgaW4gYSBTdmVsdGUgZmlsZVxuICogd2l0aCBUeXBlU2NyaXB0OlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICogXHRpbXBvcnQgeyBNeUNvbXBvbmVudCB9IGZyb20gXCJjb21wb25lbnQtbGlicmFyeVwiO1xuICogPC9zY3JpcHQ+XG4gKiA8TXlDb21wb25lbnQgZm9vPXsnYmFyJ30gLz5cbiAqIGBgYFxuICpcbiAqICMjIyMgV2h5IG5vdCBtYWtlIHRoaXMgcGFydCBvZiBgU3ZlbHRlQ29tcG9uZW50KERldilgP1xuICogQmVjYXVzZVxuICogYGBgdHNcbiAqIGNsYXNzIEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50PHtmb286IHN0cmluZ30+IHt9XG4gKiBjb25zdCBjb21wb25lbnQ6IHR5cGVvZiBTdmVsdGVDb21wb25lbnQgPSBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudDtcbiAqIGBgYFxuICogd2lsbCB0aHJvdyBhIHR5cGUgZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2VwYXJhdGUgdGhlIG1vcmUgc3RyaWN0bHkgdHlwZWQgY2xhc3MuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkIGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50RGV2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvb3BfZ3VhcmQodGltZW91dCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIGRldGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgeyBIdG1sVGFnLCBIdG1sVGFnSHlkcmF0aW9uLCBTdmVsdGVDb21wb25lbnQsIFN2ZWx0ZUNvbXBvbmVudERldiwgU3ZlbHRlQ29tcG9uZW50VHlwZWQsIFN2ZWx0ZUVsZW1lbnQsIGFjdGlvbl9kZXN0cm95ZXIsIGFkZF9hdHRyaWJ1dGUsIGFkZF9jbGFzc2VzLCBhZGRfZmx1c2hfY2FsbGJhY2ssIGFkZF9sb2NhdGlvbiwgYWRkX3JlbmRlcl9jYWxsYmFjaywgYWRkX3Jlc2l6ZV9saXN0ZW5lciwgYWRkX3N0eWxlcywgYWRkX3RyYW5zZm9ybSwgYWZ0ZXJVcGRhdGUsIGFwcGVuZCwgYXBwZW5kX2RldiwgYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQsIGFwcGVuZF9oeWRyYXRpb24sIGFwcGVuZF9oeWRyYXRpb25fZGV2LCBhcHBlbmRfc3R5bGVzLCBhc3NpZ24sIGF0dHIsIGF0dHJfZGV2LCBhdHRyaWJ1dGVfdG9fb2JqZWN0LCBiZWZvcmVVcGRhdGUsIGJpbmQsIGJpbmRpbmdfY2FsbGJhY2tzLCBibGFua19vYmplY3QsIGJ1YmJsZSwgY2hlY2tfb3V0cm9zLCBjaGlsZHJlbiwgY2xhaW1fY29tbWVudCwgY2xhaW1fY29tcG9uZW50LCBjbGFpbV9lbGVtZW50LCBjbGFpbV9odG1sX3RhZywgY2xhaW1fc3BhY2UsIGNsYWltX3N2Z19lbGVtZW50LCBjbGFpbV90ZXh0LCBjbGVhcl9sb29wcywgY29tbWVudCwgY29tcG9uZW50X3N1YnNjcmliZSwgY29tcHV0ZV9yZXN0X3Byb3BzLCBjb21wdXRlX3Nsb3RzLCBjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudCwgY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnRfZGV2LCBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcywgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlbmRfaHlkcmF0aW5nLCBlc2NhcGUsIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUsIGVzY2FwZV9vYmplY3QsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZmx1c2hfcmVuZGVyX2NhbGxiYWNrcywgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQsIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Jvb3RfZm9yX3N0eWxlLCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzQ29udGV4dCwgaGFzX3Byb3AsIGhlYWRfc2VsZWN0b3IsIGlkZW50aXR5LCBpbml0LCBpbml0X2JpbmRpbmdfZ3JvdXAsIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljLCBpbnNlcnQsIGluc2VydF9kZXYsIGluc2VydF9oeWRyYXRpb24sIGluc2VydF9oeWRyYXRpb25fZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGlzX3ZvaWQsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWVyZ2Vfc3NyX3N0eWxlcywgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCwgc2V0X2RhdGEsIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSwgc2V0X2RhdGFfY29udGVudGVkaXRhYmxlX2Rldiwgc2V0X2RhdGFfZGV2LCBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGUsIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZV9kZXYsIHNldF9keW5hbWljX2VsZW1lbnRfZGF0YSwgc2V0X2lucHV0X3R5cGUsIHNldF9pbnB1dF92YWx1ZSwgc2V0X25vdywgc2V0X3JhZiwgc2V0X3N0b3JlX3ZhbHVlLCBzZXRfc3R5bGUsIHNldF9zdmdfYXR0cmlidXRlcywgc3BhY2UsIHNwbGl0X2Nzc191bml0LCBzcHJlYWQsIHNyY191cmxfZXF1YWwsIHN0YXJ0X2h5ZHJhdGluZywgc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24sIHN0b3BfcHJvcGFnYXRpb24sIHN1YnNjcmliZSwgc3ZnX2VsZW1lbnQsIHRleHQsIHRpY2ssIHRpbWVfcmFuZ2VzX3RvX2FycmF5LCB0b19udW1iZXIsIHRvZ2dsZV9jbGFzcywgdHJhbnNpdGlvbl9pbiwgdHJhbnNpdGlvbl9vdXQsIHRydXN0ZWQsIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2gsIHVwZGF0ZV9rZXllZF9lYWNoLCB1cGRhdGVfc2xvdCwgdXBkYXRlX3Nsb3RfYmFzZSwgdmFsaWRhdGVfY29tcG9uZW50LCB2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQsIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQsIHZhbGlkYXRlX2VhY2hfa2V5cywgdmFsaWRhdGVfc2xvdHMsIHZhbGlkYXRlX3N0b3JlLCB2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCwgeGxpbmtfYXR0ciB9O1xuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2snO1xuXG4gIGV4cG9ydCBsZXQgY29uZmlnLCBzdGVwO1xuICBsZXQgYWN0aW9uLCBjbGFzc2VzLCBkaXNhYmxlZCwgbGFiZWwsIHNlY29uZGFyeSwgdGV4dDtcblxuICAkOiB7XG4gICAgYWN0aW9uID0gY29uZmlnLmFjdGlvbiA/IGNvbmZpZy5hY3Rpb24uYmluZChzdGVwLnRvdXIpIDogbnVsbDtcbiAgICBjbGFzc2VzID0gY29uZmlnLmNsYXNzZXM7XG4gICAgZGlzYWJsZWQgPSBjb25maWcuZGlzYWJsZWQgPyBnZXRDb25maWdPcHRpb24oY29uZmlnLmRpc2FibGVkKSA6IGZhbHNlO1xuICAgIGxhYmVsID0gY29uZmlnLmxhYmVsID8gZ2V0Q29uZmlnT3B0aW9uKGNvbmZpZy5sYWJlbCkgOiBudWxsO1xuICAgIHNlY29uZGFyeSA9IGNvbmZpZy5zZWNvbmRhcnk7XG4gICAgdGV4dCA9IGNvbmZpZy50ZXh0ID8gZ2V0Q29uZmlnT3B0aW9uKGNvbmZpZy50ZXh0KSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb25maWdPcHRpb24ob3B0aW9uKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9uKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbiA9IG9wdGlvbi5jYWxsKHN0ZXApO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtYnV0dG9uIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoNTAsIDEzNiwgMjMwKTtcbiAgICBib3JkZXI6IDA7XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTtcbiAgICBwYWRkaW5nOiAwLjVyZW0gMS41cmVtO1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2U7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uOm5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjUsIDExMSwgMjA0KTtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b24uc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeSB7XG4gICAgYmFja2dyb3VuZDogcmdiKDI0MSwgMjQyLCAyNDMpO1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbi5zaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5Om5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjE0LCAyMTcsIDIxOSk7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uOmRpc2FibGVkIHtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xuICB9XG48L3N0eWxlPlxuXG48YnV0dG9uXG4gIGFyaWEtbGFiZWw9XCJ7bGFiZWwgPyBsYWJlbCA6IG51bGx9XCJcbiAgY2xhc3M9XCJ7YCR7KGNsYXNzZXMgfHwgJycpfSBzaGVwaGVyZC1idXR0b24gJHsoc2Vjb25kYXJ5ID8gJ3NoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnknIDogJycpfWB9XCJcbiAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICBvbjpjbGljaz17YWN0aW9ufVxuICB0YWJpbmRleD1cIjBcIlxuPlxuICAgIHtAaHRtbCB0ZXh0fVxuPC9idXR0b24+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgU2hlcGhlcmRCdXR0b24gZnJvbSAnLi9zaGVwaGVyZC1idXR0b24uc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IHN0ZXA7XG5cbiAgJDogYnV0dG9ucyA9IHN0ZXAub3B0aW9ucy5idXR0b25zO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1mb290ZXIge1xuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDVweDtcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNXB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICBwYWRkaW5nOiAwIDAuNzVyZW0gMC43NXJlbTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1mb290ZXIgLnNoZXBoZXJkLWJ1dHRvbjpsYXN0LWNoaWxkIHtcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxmb290ZXIgY2xhc3M9XCJzaGVwaGVyZC1mb290ZXJcIj5cbiAgICB7I2lmIGJ1dHRvbnN9XG4gICAgICAgIHsjZWFjaCBidXR0b25zIGFzIGNvbmZpZ31cbiAgICAgICAgICA8U2hlcGhlcmRCdXR0b25cbiAgICAgICAgICAgIHtjb25maWd9XG4gICAgICAgICAgICB7c3RlcH1cbiAgICAgICAgICAvPlxuICAgICAgICB7L2VhY2h9XG4gICAgey9pZn1cbjwvZm9vdGVyPlxuIiwiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCBjYW5jZWxJY29uLCBzdGVwO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjbGljayBsaXN0ZW5lciB0byB0aGUgY2FuY2VsIGxpbmsgdGhhdCBjYW5jZWxzIHRoZSB0b3VyXG4gICAqL1xuICBjb25zdCBoYW5kbGVDYW5jZWxDbGljayA9IChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHN0ZXAuY2FuY2VsKCk7XG4gIH07XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWNhbmNlbC1pY29uIHtcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgY29sb3I6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC43NSk7XG4gICAgZm9udC1zaXplOiAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgdHJhbnNpdGlvbjogY29sb3IgMC41cyBlYXNlO1xuICB9XG5cbiAgLnNoZXBoZXJkLWNhbmNlbC1pY29uOmhvdmVyIHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1oYXMtdGl0bGUgLnNoZXBoZXJkLWNvbnRlbnQgLnNoZXBoZXJkLWNhbmNlbC1pY29uIHtcbiAgICBjb2xvcjogcmdiYSgxMjgsIDEyOCwgMTI4LCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1oYXMtdGl0bGUgLnNoZXBoZXJkLWNvbnRlbnQgLnNoZXBoZXJkLWNhbmNlbC1pY29uOmhvdmVyIHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuPC9zdHlsZT5cblxuPGJ1dHRvblxuICBhcmlhLWxhYmVsPVwie2NhbmNlbEljb24ubGFiZWwgPyBjYW5jZWxJY29uLmxhYmVsIDogJ0Nsb3NlIFRvdXInfVwiXG4gIGNsYXNzPVwic2hlcGhlcmQtY2FuY2VsLWljb25cIlxuICBvbjpjbGljaz17aGFuZGxlQ2FuY2VsQ2xpY2t9XG4gIHR5cGU9XCJidXR0b25cIlxuPlxuICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuPC9idXR0b24+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrJztcbiAgXG4gIGV4cG9ydCBsZXQgbGFiZWxJZCwgZWxlbWVudCwgdGl0bGU7XG4gIFxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYgKGlzRnVuY3Rpb24odGl0bGUpKSB7XG4gICAgICB0aXRsZSA9IHRpdGxlKCk7XG4gICAgfVxuICAgIFxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdGl0bGU7XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC10aXRsZSB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmb250LXNpemU6IDFyZW07XG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgICBmbGV4OiAxIDAgYXV0bztcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGgzXG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgaWQ9XCJ7bGFiZWxJZH1cIlxuICBjbGFzcz1cInNoZXBoZXJkLXRpdGxlXCJcbj5cbjwvaDM+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgU2hlcGhlcmRDYW5jZWxJY29uIGZyb20gJy4vc2hlcGhlcmQtY2FuY2VsLWljb24uc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkVGl0bGUgZnJvbSAnLi9zaGVwaGVyZC10aXRsZS5zdmVsdGUnO1xuXG4gIGV4cG9ydCBsZXQgbGFiZWxJZCwgc3RlcDtcbiAgbGV0IHRpdGxlLCBjYW5jZWxJY29uO1xuXG4gICQ6IHtcbiAgICAgIHRpdGxlID0gc3RlcC5vcHRpb25zLnRpdGxlO1xuICAgICAgY2FuY2VsSWNvbiA9IHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWhlYWRlciB7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA1cHg7XG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDVweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgbGluZS1oZWlnaHQ6IDJlbTtcbiAgICBwYWRkaW5nOiAwLjc1cmVtIDAuNzVyZW0gMDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1oYXMtdGl0bGUgLnNoZXBoZXJkLWNvbnRlbnQgLnNoZXBoZXJkLWhlYWRlciB7XG4gICAgYmFja2dyb3VuZDogI2U2ZTZlNjtcbiAgICBwYWRkaW5nOiAxZW07XG4gIH1cbjwvc3R5bGU+XG5cbjxoZWFkZXIgY2xhc3M9XCJzaGVwaGVyZC1oZWFkZXJcIj5cbiAgICB7I2lmIHRpdGxlfVxuICAgICAgPFNoZXBoZXJkVGl0bGVcbiAgICAgICAge2xhYmVsSWR9XG4gICAgICAgIHt0aXRsZX1cbiAgICAgIC8+XG4gICAgey9pZn1cblxuICAgIHsjaWYgY2FuY2VsSWNvbiAmJiBjYW5jZWxJY29uLmVuYWJsZWR9XG4gICAgICA8U2hlcGhlcmRDYW5jZWxJY29uXG4gICAgICAgIHtjYW5jZWxJY29ufVxuICAgICAgICB7c3RlcH1cbiAgICAgIC8+XG4gICAgey9pZn1cbjwvaGVhZGVyPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjayc7XG5cbiAgZXhwb3J0IGxldCBkZXNjcmlwdGlvbklkLCBlbGVtZW50LCBzdGVwO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBsZXQgeyB0ZXh0IH0gPSBzdGVwLm9wdGlvbnM7XG5cbiAgICBpZiAoaXNGdW5jdGlvbih0ZXh0KSkge1xuICAgICAgdGV4dCA9IHRleHQuY2FsbChzdGVwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudCh0ZXh0KSkge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB0ZXh0O1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLXRleHQge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICAgIGZvbnQtc2l6ZTogMXJlbTtcbiAgICBsaW5lLWhlaWdodDogMS4zZW07XG4gICAgcGFkZGluZzogMC43NWVtO1xuICB9XG5cbiAgLnNoZXBoZXJkLXRleHQgcCB7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgfVxuXG4gIC5zaGVwaGVyZC10ZXh0IHA6bGFzdC1jaGlsZCB7XG4gICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdlxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGNsYXNzPVwic2hlcGhlcmQtdGV4dFwiXG4gIGlkPVwie2Rlc2NyaXB0aW9uSWR9XCJcbj5cbjwvZGl2PlxuXG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgU2hlcGhlcmRGb290ZXIgZnJvbSAnLi9zaGVwaGVyZC1mb290ZXIuc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkSGVhZGVyIGZyb20gJy4vc2hlcGhlcmQtaGVhZGVyLnN2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZFRleHQgZnJvbSAnLi9zaGVwaGVyZC10ZXh0LnN2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5cbiAgZXhwb3J0IGxldCBkZXNjcmlwdGlvbklkLCBsYWJlbElkLCBzdGVwO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1jb250ZW50IHtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2XG4gIGNsYXNzPVwic2hlcGhlcmQtY29udGVudFwiXG4+XG4gIHsjaWYgIWlzVW5kZWZpbmVkKHN0ZXAub3B0aW9ucy50aXRsZSkgfHwgKHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uICYmIHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uLmVuYWJsZWQpfVxuICAgIDxTaGVwaGVyZEhlYWRlclxuICAgICAge2xhYmVsSWR9XG4gICAgICB7c3RlcH1cbiAgICAvPlxuICB7L2lmfVxuXG4gIHsjaWYgIWlzVW5kZWZpbmVkKHN0ZXAub3B0aW9ucy50ZXh0KX1cbiAgICA8U2hlcGhlcmRUZXh0XG4gICAgICB7ZGVzY3JpcHRpb25JZH1cbiAgICAgIHtzdGVwfVxuICAgIC8+XG4gIHsvaWZ9XG5cbiAgeyNpZiBBcnJheS5pc0FycmF5KHN0ZXAub3B0aW9ucy5idXR0b25zKSAmJiBzdGVwLm9wdGlvbnMuYnV0dG9ucy5sZW5ndGh9XG4gICAgPFNoZXBoZXJkRm9vdGVyXG4gICAgICB7c3RlcH1cbiAgICAvPlxuICB7L2lmfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50LCBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZENvbnRlbnQgZnJvbSAnLi9zaGVwaGVyZC1jb250ZW50LnN2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzVW5kZWZpbmVkLCBpc1N0cmluZyB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuXG4gIGNvbnN0IEtFWV9UQUIgPSA5O1xuICBjb25zdCBLRVlfRVNDID0gMjc7XG4gIGNvbnN0IExFRlRfQVJST1cgPSAzNztcbiAgY29uc3QgUklHSFRfQVJST1cgPSAzOTtcblxuICBleHBvcnQgbGV0IGNsYXNzUHJlZml4LCBlbGVtZW50LCBkZXNjcmlwdGlvbklkLCBmaXJzdEZvY3VzYWJsZUVsZW1lbnQsXG4gICAgZm9jdXNhYmxlRWxlbWVudHMsIGxhYmVsSWQsIGxhc3RGb2N1c2FibGVFbGVtZW50LCBzdGVwLCBkYXRhU3RlcElkO1xuXG4gIGxldCBoYXNDYW5jZWxJY29uLCBoYXNUaXRsZSwgY2xhc3NlcztcblxuICAkOiB7XG4gICAgaGFzQ2FuY2VsSWNvbiA9IHN0ZXAub3B0aW9ucyAmJiBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbiAmJiBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbi5lbmFibGVkO1xuICAgIGhhc1RpdGxlID0gc3RlcC5vcHRpb25zICYmIHN0ZXAub3B0aW9ucy50aXRsZTtcbiAgfVxuXG4gIGV4cG9ydCBjb25zdCBnZXRFbGVtZW50ID0gKCkgPT4gZWxlbWVudDtcblxuICBvbk1vdW50KCgpID0+IHtcbiAgICAvLyBHZXQgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIGZvY3VzYWJsZVxuICAgIGRhdGFTdGVwSWQgPSB7IFtgZGF0YS0ke2NsYXNzUHJlZml4fXNoZXBoZXJkLXN0ZXAtaWRgXTogc3RlcC5pZCB9O1xuICAgIGZvY3VzYWJsZUVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgW3RhYmluZGV4PVwiMFwiXScpO1xuICAgIGZpcnN0Rm9jdXNhYmxlRWxlbWVudCA9IGZvY3VzYWJsZUVsZW1lbnRzWzBdO1xuICAgIGxhc3RGb2N1c2FibGVFbGVtZW50ID0gZm9jdXNhYmxlRWxlbWVudHNbZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMV07XG4gIH0pO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZihjbGFzc2VzICE9PSBzdGVwLm9wdGlvbnMuY2xhc3Nlcykge1xuICAgICAgdXBkYXRlRHluYW1pY0NsYXNzZXMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUR5bmFtaWNDbGFzc2VzKCkge1xuICAgICAgcmVtb3ZlQ2xhc3NlcyhjbGFzc2VzKTtcbiAgICAgIGNsYXNzZXMgPSBzdGVwLm9wdGlvbnMuY2xhc3NlcztcbiAgICAgIGFkZENsYXNzZXMoY2xhc3Nlcyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKGNsYXNzZXMpIHtcbiAgICBpZiAoaXNTdHJpbmcoY2xhc3NlcykpIHtcbiAgICAgIGNvbnN0IG9sZENsYXNzZXMgPSBnZXRDbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG4gICAgICBpZiAob2xkQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLm9sZENsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENsYXNzZXMoY2xhc3Nlcykge1xuICAgIGlmKGlzU3RyaW5nKGNsYXNzZXMpKSB7XG4gICAgICBjb25zdCBuZXdDbGFzc2VzID0gZ2V0Q2xhc3Nlc0FycmF5KGNsYXNzZXMpO1xuICAgICAgaWYgKG5ld0NsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5uZXdDbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc2VzQXJyYXkoY2xhc3Nlcykge1xuICAgICByZXR1cm4gY2xhc3Nlcy5zcGxpdCgnICcpLmZpbHRlcihjbGFzc05hbWUgPT4gISFjbGFzc05hbWUubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBrZXlkb3duIGV2ZW50cyB0byBhbGxvdyBjbG9zaW5nIHRoZSBtb2RhbCB3aXRoIEVTQ1xuICAgKlxuICAgKiBCb3Jyb3dlZCBmcm9tIHRoaXMgZ3JlYXQgcG9zdCEgaHR0cHM6Ly9iaXRzb2Zjby5kZS9hY2Nlc3NpYmxlLW1vZGFsLWRpYWxvZy9cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZSkgPT4ge1xuICAgIGNvbnN0IHsgdG91ciB9ID0gc3RlcDtcbiAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgY2FzZSBLRVlfVEFCOlxuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhY2t3YXJkIHRhYlxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmaXJzdEZvY3VzYWJsZUVsZW1lbnQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3NoZXBoZXJkLWVsZW1lbnQnKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbGFzdEZvY3VzYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGxhc3RGb2N1c2FibGVFbGVtZW50KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBmaXJzdEZvY3VzYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtFWV9FU0M6XG4gICAgICAgIGlmICh0b3VyLm9wdGlvbnMuZXhpdE9uRXNjKSB7XG4gICAgICAgICAgc3RlcC5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5rZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICB0b3VyLmJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgIGlmICh0b3VyLm9wdGlvbnMua2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgdG91ci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWVsZW1lbnQge1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDRweCByZ2JhKDAsIDAsIDAsIDAuMik7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBvcGFjaXR5OiAwO1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzLCB2aXNpYmlsaXR5IDAuM3M7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHotaW5kZXg6IDk5OTk7XG4gIH1cblxuICAuc2hlcGhlcmQtZW5hYmxlZC5zaGVwaGVyZC1lbGVtZW50IHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuXTpub3QoLnNoZXBoZXJkLWNlbnRlcmVkKSB7XG4gICAgb3BhY2l0eTogMDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudCwgLnNoZXBoZXJkLWVsZW1lbnQgKixcbiAgLnNoZXBoZXJkLWVsZW1lbnQgKjphZnRlcixcbiAgLnNoZXBoZXJkLWVsZW1lbnQgKjpiZWZvcmUge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cblxuICAuc2hlcGhlcmQtYXJyb3csXG4gIC5zaGVwaGVyZC1hcnJvdzo6YmVmb3JlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDE2cHg7XG4gICAgaGVpZ2h0OiAxNnB4O1xuICAgIHotaW5kZXg6IC0xO1xuICB9XG5cbiAgLnNoZXBoZXJkLWFycm93OmJlZm9yZSB7XG4gICAgY29udGVudDogJyc7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xuICAgIGJhY2tncm91bmQ6ICNmZmYgIDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J3RvcCddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICBib3R0b206IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdib3R0b20nXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgdG9wOiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0nbGVmdCddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICByaWdodDogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J3JpZ2h0J10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIGxlZnQ6IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudC5zaGVwaGVyZC1jZW50ZXJlZCA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgb3BhY2l0eTogMDtcbiAgfVxuXG5cbiAgLyoqXG4gICogQXJyb3cgb24gdG9wIG9mIHRvb2x0aXAgY2VudGVyZWQgaG9yaXpvbnRhbGx5LCB3aXRoIHRpdGxlIGNvbG9yXG4gICovXG4gIC5zaGVwaGVyZC1lbGVtZW50LnNoZXBoZXJkLWhhcy10aXRsZVtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdib3R0b20nXSA+IC5zaGVwaGVyZC1hcnJvdzo6YmVmb3JlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTZlNmU2O1xuICB9XG5cbiAgLnNoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZC5zaGVwaGVyZC1lbmFibGVkLnNoZXBoZXJkLXRhcmdldCxcbiAgLnNoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZC5zaGVwaGVyZC1lbmFibGVkLnNoZXBoZXJkLXRhcmdldCAqIHtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdlxuICBhcmlhLWRlc2NyaWJlZGJ5PXshaXNVbmRlZmluZWQoc3RlcC5vcHRpb25zLnRleHQpID8gZGVzY3JpcHRpb25JZCA6IG51bGx9XG4gIGFyaWEtbGFiZWxsZWRieT17c3RlcC5vcHRpb25zLnRpdGxlID8gbGFiZWxJZCA6IG51bGx9XG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgY2xhc3M6c2hlcGhlcmQtaGFzLWNhbmNlbC1pY29uPVwie2hhc0NhbmNlbEljb259XCJcbiAgY2xhc3M6c2hlcGhlcmQtaGFzLXRpdGxlPVwie2hhc1RpdGxlfVwiXG4gIGNsYXNzOnNoZXBoZXJkLWVsZW1lbnQ9XCJ7dHJ1ZX1cIlxuICB7Li4uZGF0YVN0ZXBJZH1cbiAgb246a2V5ZG93bj17aGFuZGxlS2V5RG93bn1cbiAgcm9sZT1cImRpYWxvZ1wiXG4gIHRhYmluZGV4PVwiMFwiXG4+XG4gICAgeyNpZiBzdGVwLm9wdGlvbnMuYXJyb3cgJiYgc3RlcC5vcHRpb25zLmF0dGFjaFRvICYmIHN0ZXAub3B0aW9ucy5hdHRhY2hUby5lbGVtZW50ICYmIHN0ZXAub3B0aW9ucy5hdHRhY2hUby5vbn1cbiAgICAgIDxkaXYgY2xhc3M9XCJzaGVwaGVyZC1hcnJvd1wiIGRhdGEtcG9wcGVyLWFycm93PjwvZGl2PlxuICAgIHsvaWZ9XG4gIDxTaGVwaGVyZENvbnRlbnRcbiAgICB7ZGVzY3JpcHRpb25JZH1cbiAgICB7bGFiZWxJZH1cbiAgICB7c3RlcH1cbiAgLz5cbjwvZGl2PlxuIiwiaW1wb3J0IG1lcmdlIGZyb20gJ2RlZXBtZXJnZSc7XG5pbXBvcnQgeyBFdmVudGVkIH0gZnJvbSAnLi9ldmVudGVkLmpzJztcbmltcG9ydCBhdXRvQmluZCBmcm9tICcuL3V0aWxzL2F1dG8tYmluZC5qcyc7XG5pbXBvcnQge1xuICBpc0VsZW1lbnQsXG4gIGlzSFRNTEVsZW1lbnQsXG4gIGlzRnVuY3Rpb24sXG4gIGlzVW5kZWZpbmVkXG59IGZyb20gJy4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5pbXBvcnQgeyBiaW5kQWR2YW5jZSB9IGZyb20gJy4vdXRpbHMvYmluZC5qcyc7XG5pbXBvcnQgeyBwYXJzZUF0dGFjaFRvLCBub3JtYWxpemVQcmVmaXgsIHV1aWQgfSBmcm9tICcuL3V0aWxzL2dlbmVyYWwuanMnO1xuaW1wb3J0IHtcbiAgc2V0dXBUb29sdGlwLFxuICBkZXN0cm95VG9vbHRpcCxcbiAgbWVyZ2VUb29sdGlwQ29uZmlnXG59IGZyb20gJy4vdXRpbHMvZmxvYXRpbmctdWkuanMnO1xuaW1wb3J0IFNoZXBoZXJkRWxlbWVudCBmcm9tICcuL2NvbXBvbmVudHMvc2hlcGhlcmQtZWxlbWVudC5zdmVsdGUnO1xuXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIHN0ZXBzIHRvIGJlIGFkZGVkIHRvIGEgdG91ci5cbiAqIEBleHRlbmRzIHtFdmVudGVkfVxuICovXG5leHBvcnQgY2xhc3MgU3RlcCBleHRlbmRzIEV2ZW50ZWQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgc3RlcFxuICAgKiBAcGFyYW0ge1RvdXJ9IHRvdXIgVGhlIHRvdXIgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYXJyb3cgV2hldGhlciB0byBkaXNwbGF5IHRoZSBhcnJvdyBmb3IgdGhlIHRvb2x0aXAgb3Igbm90LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmF0dGFjaFRvIFRoZSBlbGVtZW50IHRoZSBzdGVwIHNob3VsZCBiZSBhdHRhY2hlZCB0byBvbiB0aGUgcGFnZS5cbiAgICogQW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyBgZWxlbWVudGAgYW5kIGBvbmAuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHN0ZXAgPSBuZXcgU3RlcCh0b3VyLCB7XG4gICAqICAgYXR0YWNoVG86IHsgZWxlbWVudDogJy5zb21lIC5zZWxlY3Rvci1wYXRoJywgb246ICdsZWZ0JyB9LFxuICAgKiAgIC4uLm1vcmVPcHRpb25zXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogSWYgeW91IGRvbuKAmXQgc3BlY2lmeSBhbiBgYXR0YWNoVG9gIHRoZSBlbGVtZW50IHdpbGwgYXBwZWFyIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbi4gVGhlIHNhbWUgd2lsbCBoYXBwZW4gaWYgeW91ciBgYXR0YWNoVG8uZWxlbWVudGAgY2FsbGJhY2sgcmV0dXJucyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvciBhIHNlbGVjdG9yIHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIERPTS5cbiAgICogSWYgeW91IG9taXQgdGhlIGBvbmAgcG9ydGlvbiBvZiBgYXR0YWNoVG9gLCB0aGUgZWxlbWVudCB3aWxsIHN0aWxsIGJlIGhpZ2hsaWdodGVkLCBidXQgdGhlIHRvb2x0aXAgd2lsbCBhcHBlYXJcbiAgICogaW4gdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLCB3aXRob3V0IGFuIGFycm93IHBvaW50aW5nIHRvIHRoZSB0YXJnZXQuXG4gICAqIElmIHRoZSBlbGVtZW50IHRvIGhpZ2hsaWdodCBkb2VzIG5vdCB5ZXQgZXhpc3Qgd2hpbGUgaW5zdGFudGlhdGluZyB0b3VyIHN0ZXBzLCB5b3UgbWF5IHVzZSBsYXp5IGV2YWx1YXRpb24gYnkgc3VwcGx5aW5nIGEgZnVuY3Rpb24gdG8gYGF0dGFjaFRvLmVsZW1lbnRgLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGBiZWZvcmUtc2hvd2AgcGhhc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxFbGVtZW50fGZ1bmN0aW9ufSBvcHRpb25zLmF0dGFjaFRvLmVsZW1lbnQgQW4gZWxlbWVudCBzZWxlY3RvciBzdHJpbmcsIERPTSBlbGVtZW50LCBvciBhIGZ1bmN0aW9uIChyZXR1cm5pbmcgYSBzZWxlY3RvciwgYSBET00gZWxlbWVudCwgYG51bGxgIG9yIGB1bmRlZmluZWRgKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYXR0YWNoVG8ub24gVGhlIG9wdGlvbmFsIGRpcmVjdGlvbiB0byBwbGFjZSB0aGUgRmxvYXRpbmdVSSB0b29sdGlwIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50LlxuICAgKiAgIC0gUG9zc2libGUgc3RyaW5nIHZhbHVlczogJ3RvcCcsICd0b3Atc3RhcnQnLCAndG9wLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2JvdHRvbS1lbmQnLCAncmlnaHQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCcsICdsZWZ0LWVuZCdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYWR2YW5jZU9uIEFuIGFjdGlvbiBvbiB0aGUgcGFnZSB3aGljaCBzaG91bGQgYWR2YW5jZSBzaGVwaGVyZCB0byB0aGUgbmV4dCBzdGVwLlxuICAgKiBJdCBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggYSBzdHJpbmcgYHNlbGVjdG9yYCBhbmQgYW4gYGV2ZW50YCBuYW1lXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHN0ZXAgPSBuZXcgU3RlcCh0b3VyLCB7XG4gICAqICAgYWR2YW5jZU9uOiB7IHNlbGVjdG9yOiAnLnNvbWUgLnNlbGVjdG9yLXBhdGgnLCBldmVudDogJ2NsaWNrJyB9LFxuICAgKiAgIC4uLm1vcmVPcHRpb25zXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogYGV2ZW50YCBkb2VzbuKAmXQgaGF2ZSB0byBiZSBhbiBldmVudCBpbnNpZGUgdGhlIHRvdXIsIGl0IGNhbiBiZSBhbnkgZXZlbnQgZmlyZWQgb24gYW55IGVsZW1lbnQgb24gdGhlIHBhZ2UuXG4gICAqIFlvdSBjYW4gYWxzbyBhbHdheXMgbWFudWFsbHkgYWR2YW5jZSB0aGUgVG91ciBieSBjYWxsaW5nIGBteVRvdXIubmV4dCgpYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5iZWZvcmVTaG93UHJvbWlzZSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UuXG4gICAqIFdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMsIHRoZSByZXN0IG9mIHRoZSBgc2hvd2AgY29kZSBmb3IgdGhlIHN0ZXAgd2lsbCBleGVjdXRlLlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBvcHRpb25zLmJ1dHRvbnMgQW4gYXJyYXkgb2YgYnV0dG9ucyB0byBhZGQgdG8gdGhlIHN0ZXAuIFRoZXNlIHdpbGwgYmUgcmVuZGVyZWQgaW4gYVxuICAgKiBmb290ZXIgYmVsb3cgdGhlIG1haW4gYm9keSB0ZXh0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmFjdGlvbiBBIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIG9uLlxuICAgKiBJdCBpcyBhdXRvbWF0aWNhbGx5IGJvdW5kIHRvIHRoZSBgdG91cmAgdGhlIHN0ZXAgaXMgYXNzb2NpYXRlZCB3aXRoLCBzbyB0aGluZ3MgbGlrZSBgdGhpcy5uZXh0YCB3aWxsXG4gICAqIHdvcmsgaW5zaWRlIHRoZSBhY3Rpb24uXG4gICAqIFlvdSBjYW4gdXNlIGFjdGlvbiB0byBza2lwIHN0ZXBzIG9yIG5hdmlnYXRlIHRvIHNwZWNpZmljIHN0ZXBzLCB3aXRoIHNvbWV0aGluZyBsaWtlOlxuICAgKiBgYGBqc1xuICAgKiBhY3Rpb24oKSB7XG4gICAqICAgcmV0dXJuIHRoaXMuc2hvdygnc29tZV9zdGVwX25hbWUnKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uY2xhc3NlcyBFeHRyYSBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBgPGE+YFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uZGlzYWJsZWQgU2hvdWxkIHRoZSBidXR0b24gYmUgZGlzYWJsZWQ/XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmxhYmVsIFRoZSBhcmlhLWxhYmVsIHRleHQgb2YgdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uc2Vjb25kYXJ5IElmIHRydWUsIGEgc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeSBjbGFzcyBpcyBhcHBsaWVkIHRvIHRoZSBidXR0b25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYnV0dG9ucy5idXR0b24udGV4dCBUaGUgSFRNTCB0ZXh0IG9mIHRoZSBidXR0b25cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNhbkNsaWNrVGFyZ2V0IEEgYm9vbGVhbiwgdGhhdCB3aGVuIHNldCB0byBmYWxzZSwgd2lsbCBzZXQgYHBvaW50ZXItZXZlbnRzOiBub25lYCBvbiB0aGUgdGFyZ2V0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNhbmNlbEljb24gT3B0aW9ucyBmb3IgdGhlIGNhbmNlbCBpY29uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jYW5jZWxJY29uLmVuYWJsZWQgU2hvdWxkIGEgY2FuY2VsIOKAnOKcleKAnSBiZSBzaG93biBpbiB0aGUgaGVhZGVyIG9mIHRoZSBzdGVwP1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jYW5jZWxJY29uLmxhYmVsIFRoZSBsYWJlbCB0byBhZGQgZm9yIGBhcmlhLWxhYmVsYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jbGFzc2VzIEEgc3RyaW5nIG9mIGV4dHJhIGNsYXNzZXMgdG8gYWRkIHRvIHRoZSBzdGVwJ3MgY29udGVudCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5oaWdobGlnaHRDbGFzcyBBbiBleHRyYSBjbGFzcyB0byBhcHBseSB0byB0aGUgYGF0dGFjaFRvYCBlbGVtZW50IHdoZW4gaXQgaXNcbiAgICogaGlnaGxpZ2h0ZWQgKHRoYXQgaXMsIHdoZW4gaXRzIHN0ZXAgaXMgYWN0aXZlKS4gWW91IGNhbiB0aGVuIHRhcmdldCB0aGF0IHNlbGVjdG9yIGluIHlvdXIgQ1NTLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5pZCBUaGUgc3RyaW5nIHRvIHVzZSBhcyB0aGUgYGlkYCBmb3IgdGhlIHN0ZXAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nIEFuIGFtb3VudCBvZiBwYWRkaW5nIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge251bWJlciB8IHsgdG9wTGVmdDogbnVtYmVyLCBib3R0b21MZWZ0OiBudW1iZXIsIGJvdHRvbVJpZ2h0OiBudW1iZXIsIHRvcFJpZ2h0OiBudW1iZXIgfX0gb3B0aW9ucy5tb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzIEFuIGFtb3VudCBvZiBib3JkZXIgcmFkaXVzIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5mbG9hdGluZ1VJT3B0aW9ucyBFeHRyYSBvcHRpb25zIHRvIHBhc3MgdG8gRmxvYXRpbmdVSVxuICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBvcHRpb25zLnNjcm9sbFRvIFNob3VsZCB0aGUgZWxlbWVudCBiZSBzY3JvbGxlZCB0byB3aGVuIHRoaXMgc3RlcCBpcyBzaG93bj8gSWYgdHJ1ZSwgdXNlcyB0aGUgZGVmYXVsdCBgc2Nyb2xsSW50b1ZpZXdgLFxuICAgKiBpZiBhbiBvYmplY3QsIHBhc3NlcyB0aGF0IG9iamVjdCBhcyB0aGUgcGFyYW1zIHRvIGBzY3JvbGxJbnRvVmlld2AgaS5lLiBge2JlaGF2aW9yOiAnc21vb3RoJywgYmxvY2s6ICdjZW50ZXInfWBcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zY3JvbGxUb0hhbmRsZXIgQSBmdW5jdGlvbiB0aGF0IGxldHMgeW91IG92ZXJyaWRlIHRoZSBkZWZhdWx0IHNjcm9sbFRvIGJlaGF2aW9yIGFuZFxuICAgKiBkZWZpbmUgYSBjdXN0b20gYWN0aW9uIHRvIGRvIHRoZSBzY3JvbGxpbmcsIGFuZCBwb3NzaWJseSBvdGhlciBsb2dpYy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zaG93T24gQSBmdW5jdGlvbiB0aGF0LCB3aGVuIGl0IHJldHVybnMgYHRydWVgLCB3aWxsIHNob3cgdGhlIHN0ZXAuXG4gICAqIElmIGl0IHJldHVybnMgZmFsc2UsIHRoZSBzdGVwIHdpbGwgYmUgc2tpcHBlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGV4dCBUaGUgdGV4dCBpbiB0aGUgYm9keSBvZiB0aGUgc3RlcC4gSXQgY2FuIGJlIG9uZSBvZiB0aHJlZSB0eXBlczpcbiAgICogYGBgXG4gICAqIC0gSFRNTCBzdHJpbmdcbiAgICogLSBgSFRNTEVsZW1lbnRgIG9iamVjdFxuICAgKiAtIGBGdW5jdGlvbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgc3RlcCBpcyBidWlsdC4gSXQgbXVzdCByZXR1cm4gb25lIHRoZSB0d28gb3B0aW9ucyBhYm92ZS5cbiAgICogYGBgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIFRoZSBzdGVwJ3MgdGl0bGUuIEl0IGJlY29tZXMgYW4gYGgzYCBhdCB0aGUgdG9wIG9mIHRoZSBzdGVwLiBJdCBjYW4gYmUgb25lIG9mIHR3byB0eXBlczpcbiAgICogYGBgXG4gICAqIC0gSFRNTCBzdHJpbmdcbiAgICogLSBgRnVuY3Rpb25gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHN0ZXAgaXMgYnVpbHQuIEl0IG11c3QgcmV0dXJuIEhUTUwgc3RyaW5nLlxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMud2hlbiBZb3UgY2FuIGRlZmluZSBgc2hvd2AsIGBoaWRlYCwgZXRjIGV2ZW50cyBpbnNpZGUgYHdoZW5gLiBGb3IgZXhhbXBsZTpcbiAgICogYGBganNcbiAgICogd2hlbjoge1xuICAgKiAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICogQHJldHVybiB7U3RlcH0gVGhlIG5ld2x5IGNyZWF0ZWQgU3RlcCBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IodG91ciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodG91ciwgb3B0aW9ucyk7XG4gICAgdGhpcy50b3VyID0gdG91cjtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gdGhpcy50b3VyLm9wdGlvbnNcbiAgICAgID8gbm9ybWFsaXplUHJlZml4KHRoaXMudG91ci5vcHRpb25zLmNsYXNzUHJlZml4KVxuICAgICAgOiAnJztcbiAgICB0aGlzLnN0eWxlcyA9IHRvdXIuc3R5bGVzO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgYXR0YWNoVG8gb3B0aW9ucy4gRHVlIHRvIGxhenkgZXZhbHVhdGlvbiwgd2Ugb25seSByZXNvbHZlIHRoZSBvcHRpb25zIGR1cmluZyBgYmVmb3JlLXNob3dgIHBoYXNlLlxuICAgICAqIERvIG5vdCB1c2UgdGhpcyBkaXJlY3RseSwgdXNlIHRoZSBfZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMgbWV0aG9kIGluc3RlYWQuXG4gICAgICogQHR5cGUge251bGx8e318e2VsZW1lbnQsIHRvfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG8gPSBudWxsO1xuXG4gICAgYXV0b0JpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIHRoZSB0b3VyXG4gICAqIFRyaWdnZXJzIHRoZSBgY2FuY2VsYCBldmVudFxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMudG91ci5jYW5jZWwoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NhbmNlbCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIHRoZSB0b3VyXG4gICAqIFRyaWdnZXJzIHRoZSBgY29tcGxldGVgIGV2ZW50XG4gICAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLnRvdXIuY29tcGxldGUoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBzdGVwLCBkZWxldGUgdGhlIHN0ZXAncyBlbGVtZW50LCBhbmQgZGVzdHJveSB0aGUgRmxvYXRpbmdVSSBpbnN0YW5jZSBmb3IgdGhlIHN0ZXAuXG4gICAqIFRyaWdnZXJzIGBkZXN0cm95YCBldmVudFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBkZXN0cm95VG9vbHRpcCh0aGlzKTtcblxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRoaXMuZWwpKSB7XG4gICAgICB0aGlzLmVsLnJlbW92ZSgpO1xuICAgICAgdGhpcy5lbCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlU3RlcFRhcmdldE9uSGlkZSgpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG91ciBmb3IgdGhlIHN0ZXBcbiAgICogQHJldHVybiB7VG91cn0gVGhlIHRvdXIgaW5zdGFuY2VcbiAgICovXG4gIGdldFRvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudG91cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBzdGVwXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMudG91ci5tb2RhbC5oaWRlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZS1oaWRlJyk7XG5cbiAgICBpZiAodGhpcy5lbCkge1xuICAgICAgdGhpcy5lbC5oaWRkZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUoKTtcblxuICAgIHRoaXMudHJpZ2dlcignaGlkZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGF0dGFjaFRvIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHt7fXx7ZWxlbWVudCwgb259fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc29sdmVBdHRhY2hUb09wdGlvbnMoKSB7XG4gICAgdGhpcy5fcmVzb2x2ZWRBdHRhY2hUbyA9IHBhcnNlQXR0YWNoVG8odGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG87XG4gIH1cblxuICAvKipcbiAgICogQSBzZWxlY3RvciBmb3IgcmVzb2x2ZWQgYXR0YWNoVG8gb3B0aW9ucy5cbiAgICogQHJldHVybnMge3t9fHtlbGVtZW50LCBvbn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMoKSB7XG4gICAgaWYgKHRoaXMuX3Jlc29sdmVkQXR0YWNoVG8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlQXR0YWNoVG9PcHRpb25zKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG87XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHN0ZXAgaXMgb3BlbiBhbmQgdmlzaWJsZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdGVwIGlzIG9wZW4gYW5kIHZpc2libGVcbiAgICovXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmVsICYmICF0aGlzLmVsLmhpZGRlbik7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgYF9zaG93YCBhbmQgZW5zdXJlcyBgYmVmb3JlU2hvd1Byb21pc2VgIHJlc29sdmVzIGJlZm9yZSBjYWxsaW5nIHNob3dcbiAgICogQHJldHVybiB7KnxQcm9taXNlfVxuICAgKi9cbiAgc2hvdygpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuYmVmb3JlU2hvd1Byb21pc2UpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMub3B0aW9ucy5iZWZvcmVTaG93UHJvbWlzZSgpKS50aGVuKCgpID0+XG4gICAgICAgIHRoaXMuX3Nob3coKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9zaG93KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIG9wdGlvbnMgb2YgdGhlIHN0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc3RlcFxuICAgKi9cbiAgdXBkYXRlU3RlcE9wdGlvbnMob3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudCkge1xuICAgICAgdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuJHNldCh7IHN0ZXA6IHRoaXMgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkfSBUaGUgZWxlbWVudCBpbnN0YW5jZS4gdW5kZWZpbmVkIGlmIGl0IGhhcyBuZXZlciBiZWVuIHNob3duLCBudWxsIGlmIGl0IGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YXJnZXQgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkfSBUaGUgZWxlbWVudCBpbnN0YW5jZS4gdW5kZWZpbmVkIGlmIGl0IGhhcyBuZXZlciBiZWVuIHNob3duLCBudWxsIGlmIHF1ZXJ5IHN0cmluZyBoYXMgbm90IGJlZW4gZm91bmRcbiAgICovXG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBTaGVwaGVyZCBlbGVtZW50IGZvciBzdGVwIGJhc2VkIG9uIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIERPTSBlbGVtZW50IGZvciB0aGUgc3RlcCB0b29sdGlwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlVG9vbHRpcENvbnRlbnQoKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb25JZCA9IGAke3RoaXMuaWR9LWRlc2NyaXB0aW9uYDtcbiAgICBjb25zdCBsYWJlbElkID0gYCR7dGhpcy5pZH0tbGFiZWxgO1xuXG4gICAgdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQgPSBuZXcgU2hlcGhlcmRFbGVtZW50KHtcbiAgICAgIHRhcmdldDogdGhpcy50b3VyLm9wdGlvbnMuc3RlcHNDb250YWluZXIgfHwgZG9jdW1lbnQuYm9keSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsYXNzUHJlZml4OiB0aGlzLmNsYXNzUHJlZml4LFxuICAgICAgICBkZXNjcmlwdGlvbklkLFxuICAgICAgICBsYWJlbElkLFxuICAgICAgICBzdGVwOiB0aGlzLFxuICAgICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuZ2V0RWxlbWVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGEgY3VzdG9tIHNjcm9sbFRvSGFuZGxlciBpcyBkZWZpbmVkLCBjYWxsIHRoYXQsIG90aGVyd2lzZSBkbyB0aGUgZ2VuZXJpY1xuICAgKiBzY3JvbGxJbnRvVmlldyBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBzY3JvbGxUb09wdGlvbnMgSWYgdHJ1ZSwgdXNlcyB0aGUgZGVmYXVsdCBgc2Nyb2xsSW50b1ZpZXdgLFxuICAgKiBpZiBhbiBvYmplY3QsIHBhc3NlcyB0aGF0IG9iamVjdCBhcyB0aGUgcGFyYW1zIHRvIGBzY3JvbGxJbnRvVmlld2AgaS5lLiBgeyBiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrOiAnY2VudGVyJyB9YFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Njcm9sbFRvKHNjcm9sbFRvT3B0aW9ucykge1xuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdGhpcy5fZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMoKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5zY3JvbGxUb0hhbmRsZXIpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2Nyb2xsVG9IYW5kbGVyKGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpc0VsZW1lbnQoZWxlbWVudCkgJiZcbiAgICAgIHR5cGVvZiBlbGVtZW50LnNjcm9sbEludG9WaWV3ID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbEludG9WaWV3KHNjcm9sbFRvT3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIF9nZXRDbGFzc09wdGlvbnMgZ2V0cyBhbGwgcG9zc2libGUgY2xhc3NlcyBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0ZXBPcHRpb25zIFRoZSBzdGVwIHNwZWNpZmljIG9wdGlvbnNcbiAgICogQHJldHVybnMge1N0cmluZ30gdW5pcXVlIHN0cmluZyBmcm9tIGFycmF5IG9mIGNsYXNzZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDbGFzc09wdGlvbnMoc3RlcE9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0U3RlcE9wdGlvbnMgPVxuICAgICAgdGhpcy50b3VyICYmIHRoaXMudG91ci5vcHRpb25zICYmIHRoaXMudG91ci5vcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucztcbiAgICBjb25zdCBzdGVwQ2xhc3NlcyA9IHN0ZXBPcHRpb25zLmNsYXNzZXMgPyBzdGVwT3B0aW9ucy5jbGFzc2VzIDogJyc7XG4gICAgY29uc3QgZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3NlcyA9XG4gICAgICBkZWZhdWx0U3RlcE9wdGlvbnMgJiYgZGVmYXVsdFN0ZXBPcHRpb25zLmNsYXNzZXNcbiAgICAgICAgPyBkZWZhdWx0U3RlcE9wdGlvbnMuY2xhc3Nlc1xuICAgICAgICA6ICcnO1xuICAgIGNvbnN0IGFsbENsYXNzZXMgPSBbXG4gICAgICAuLi5zdGVwQ2xhc3Nlcy5zcGxpdCgnICcpLFxuICAgICAgLi4uZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3Nlcy5zcGxpdCgnICcpXG4gICAgXTtcbiAgICBjb25zdCB1bmlxQ2xhc3NlcyA9IG5ldyBTZXQoYWxsQ2xhc3Nlcyk7XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxQ2xhc3Nlcykuam9pbignICcpLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcHRpb25zIGZvciB0aGUgc3RlcCwgbWFwcyBgd2hlbmAgdG8gZXZlbnRzLCBzZXRzIHVwIGJ1dHRvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0T3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgdG91ck9wdGlvbnMgPVxuICAgICAgdGhpcy50b3VyICYmIHRoaXMudG91ci5vcHRpb25zICYmIHRoaXMudG91ci5vcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucztcblxuICAgIHRvdXJPcHRpb25zID0gbWVyZ2Uoe30sIHRvdXJPcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIGFycm93OiB0cnVlXG4gICAgICB9LFxuICAgICAgdG91ck9wdGlvbnMsXG4gICAgICBvcHRpb25zLFxuICAgICAgbWVyZ2VUb29sdGlwQ29uZmlnKHRvdXJPcHRpb25zLCBvcHRpb25zKVxuICAgICk7XG5cbiAgICBjb25zdCB7IHdoZW4gfSA9IHRoaXMub3B0aW9ucztcblxuICAgIHRoaXMub3B0aW9ucy5jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZCB8fCBgc3RlcC0ke3V1aWQoKX1gO1xuXG4gICAgaWYgKHdoZW4pIHtcbiAgICAgIE9iamVjdC5rZXlzKHdoZW4pLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMub24oZXZlbnQsIHdoZW5bZXZlbnRdLCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGVsZW1lbnQgYW5kIHNldCB1cCB0aGUgRmxvYXRpbmdVSSBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwRWxlbWVudHMoKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLmVsKSkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbCA9IHRoaXMuX2NyZWF0ZVRvb2x0aXBDb250ZW50KCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmFkdmFuY2VPbikge1xuICAgICAgYmluZEFkdmFuY2UodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhcmUgaGFuZGxlZCBvdXRzaWRlIG9mIHRoZSBTdGVwXG4gICAgLy8gb2JqZWN0LlxuICAgIHNldHVwVG9vbHRpcCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBgYmVmb3JlLXNob3dgLCBnZW5lcmF0ZXMgdGhlIHRvb2x0aXAgRE9NIGNvbnRlbnQsXG4gICAqIHNldHMgdXAgYSBGbG9hdGluZ1VJIGluc3RhbmNlIGZvciB0aGUgdG9vbHRpcCwgdGhlbiB0cmlnZ2VycyBgc2hvd2AuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2hvdygpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZS1zaG93Jyk7XG5cbiAgICAvLyBGb3JjZSByZXNvbHZlIHRvIG1ha2Ugc3VyZSB0aGUgb3B0aW9ucyBhcmUgdXBkYXRlZCBvbiBzdWJzZXF1ZW50IHNob3dzLlxuICAgIHRoaXMuX3Jlc29sdmVBdHRhY2hUb09wdGlvbnMoKTtcbiAgICB0aGlzLl9zZXR1cEVsZW1lbnRzKCk7XG5cbiAgICBpZiAoIXRoaXMudG91ci5tb2RhbCkge1xuICAgICAgdGhpcy50b3VyLl9zZXR1cE1vZGFsKCk7XG4gICAgfVxuXG4gICAgdGhpcy50b3VyLm1vZGFsLnNldHVwRm9yU3RlcCh0aGlzKTtcbiAgICB0aGlzLl9zdHlsZVRhcmdldEVsZW1lbnRGb3JTdGVwKHRoaXMpO1xuICAgIHRoaXMuZWwuaGlkZGVuID0gZmFsc2U7XG5cbiAgICAvLyBzdGFydCBzY3JvbGxpbmcgdG8gdGFyZ2V0IGJlZm9yZSBzaG93aW5nIHRoZSBzdGVwXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxUbykge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMub3B0aW9ucy5zY3JvbGxUbyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmVsLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldCB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtZW5hYmxlZGApO1xuICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtdGFyZ2V0YCk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdzaGVwaGVyZC1lbmFibGVkJyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3Nob3cnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2R1bGF0ZXMgdGhlIHN0eWxlcyBvZiB0aGUgcGFzc2VkIHN0ZXAncyB0YXJnZXQgZWxlbWVudCwgYmFzZWQgb24gdGhlIHN0ZXAncyBvcHRpb25zIGFuZFxuICAgKiB0aGUgdG91cidzIGBtb2RhbGAgb3B0aW9uLCB0byB2aXN1YWxseSBlbXBoYXNpemUgdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHN0ZXAgVGhlIHN0ZXAgb2JqZWN0IHRoYXQgYXR0YWNoZXMgdG8gdGhlIGVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdHlsZVRhcmdldEVsZW1lbnRGb3JTdGVwKHN0ZXApIHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gc3RlcC50YXJnZXQ7XG5cbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5vcHRpb25zLmhpZ2hsaWdodENsYXNzKSB7XG4gICAgICB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5hZGQoc3RlcC5vcHRpb25zLmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG5cbiAgICB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcpO1xuXG4gICAgaWYgKHN0ZXAub3B0aW9ucy5jYW5DbGlja1RhcmdldCA9PT0gZmFsc2UpIHtcbiAgICAgIHRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBzdGVwIGlzIGhpZGRlbiwgcmVtb3ZlIHRoZSBoaWdobGlnaHRDbGFzcyBhbmQgJ3NoZXBoZXJkLWVuYWJsZWQnXG4gICAqIGFuZCAnc2hlcGhlcmQtdGFyZ2V0JyBjbGFzc2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU3RlcFRhcmdldE9uSGlkZSgpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldCB8fCBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHRDbGFzcykge1xuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnLFxuICAgICAgYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC1lbmFibGVkYCxcbiAgICAgIGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtdGFyZ2V0YFxuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ2xlYW51cCB0aGUgc3RlcHMgYW5kIHNldCBwb2ludGVyRXZlbnRzIGJhY2sgdG8gJ2F1dG8nXG4gKiBAcGFyYW0gdG91ciBUaGUgdG91ciBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBTdGVwcyh0b3VyKSB7XG4gIGlmICh0b3VyKSB7XG4gICAgY29uc3QgeyBzdGVwcyB9ID0gdG91cjtcblxuICAgIHN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgc3RlcC5vcHRpb25zICYmXG4gICAgICAgIHN0ZXAub3B0aW9ucy5jYW5DbGlja1RhcmdldCA9PT0gZmFsc2UgJiZcbiAgICAgICAgc3RlcC5vcHRpb25zLmF0dGFjaFRvXG4gICAgICApIHtcbiAgICAgICAgaWYgKHN0ZXAudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICBzdGVwLnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKipcbiAqIEdlbmVyYXRlcyB0aGUgc3ZnIHBhdGggZGF0YSBmb3IgYSByb3VuZGVkIHJlY3RhbmdsZSBvdmVybGF5XG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9uIC0gRGltZW5zaW9ucyBvZiByZWN0YW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBPZmZzZXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIgaW4geCBheGlzLiBkZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBPZmZzZXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIgaW4geSBheGlzLiBkZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlciB8IHsgdG9wTGVmdDogbnVtYmVyLCB0b3BSaWdodDogbnVtYmVyLCBib3R0b21SaWdodDogbnVtYmVyLCBib3R0b21MZWZ0OiBudW1iZXIgfX0gW3I9MF0gLSBDb3JuZXIgUmFkaXVzLiBLZWVwIHRoaXMgc21hbGxlciB0aGFuIGhhbGYgb2Ygd2lkdGggb3IgaGVpZ2h0LlxuICogQHJldHVybnMge3N0cmluZ30gLSBSb3VuZGVkIHJlY3RhbmdsZSBvdmVybGF5IHBhdGggZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VPdmVybGF5UGF0aCh7IHdpZHRoLCBoZWlnaHQsIHggPSAwLCB5ID0gMCwgciA9IDAgfSkge1xuICBjb25zdCB7IGlubmVyV2lkdGg6IHcsIGlubmVySGVpZ2h0OiBoIH0gPSB3aW5kb3c7XG4gIGNvbnN0IHtcbiAgICB0b3BMZWZ0ID0gMCxcbiAgICB0b3BSaWdodCA9IDAsXG4gICAgYm90dG9tUmlnaHQgPSAwLFxuICAgIGJvdHRvbUxlZnQgPSAwXG4gIH0gPSB0eXBlb2YgciA9PT0gJ251bWJlcidcbiAgICA/IHsgdG9wTGVmdDogciwgdG9wUmlnaHQ6IHIsIGJvdHRvbVJpZ2h0OiByLCBib3R0b21MZWZ0OiByIH1cbiAgICA6IHI7XG5cbiAgcmV0dXJuIGBNJHt3fSwke2h9XFxcbkgwXFxcblYwXFxcbkgke3d9XFxcblYke2h9XFxcblpcXFxuTSR7eCArIHRvcExlZnR9LCR7eX1cXFxuYSR7dG9wTGVmdH0sJHt0b3BMZWZ0fSwwLDAsMC0ke3RvcExlZnR9LCR7dG9wTGVmdH1cXFxuViR7aGVpZ2h0ICsgeSAtIGJvdHRvbUxlZnR9XFxcbmEke2JvdHRvbUxlZnR9LCR7Ym90dG9tTGVmdH0sMCwwLDAsJHtib3R0b21MZWZ0fSwke2JvdHRvbUxlZnR9XFxcbkgke3dpZHRoICsgeCAtIGJvdHRvbVJpZ2h0fVxcXG5hJHtib3R0b21SaWdodH0sJHtib3R0b21SaWdodH0sMCwwLDAsJHtib3R0b21SaWdodH0tJHtib3R0b21SaWdodH1cXFxuViR7eSArIHRvcFJpZ2h0fVxcXG5hJHt0b3BSaWdodH0sJHt0b3BSaWdodH0sMCwwLDAtJHt0b3BSaWdodH0tJHt0b3BSaWdodH1cXFxuWmA7XG59XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyB1dWlkIH0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJhbC5qcyc7XG4gIGltcG9ydCB7IG1ha2VPdmVybGF5UGF0aCB9IGZyb20gJy4uL3V0aWxzL292ZXJsYXktcGF0aC5qcyc7XG5cbiAgZXhwb3J0IGxldCBlbGVtZW50LCBvcGVuaW5nUHJvcGVydGllcztcbiAgY29uc3QgZ3VpZCA9IHV1aWQoKTtcbiAgbGV0IG1vZGFsSXNWaXNpYmxlID0gZmFsc2U7XG4gIGxldCByYWZJZCA9IHVuZGVmaW5lZDtcbiAgbGV0IHBhdGhEZWZpbml0aW9uO1xuXG4gICQ6IHBhdGhEZWZpbml0aW9uID0gbWFrZU92ZXJsYXlQYXRoKG9wZW5pbmdQcm9wZXJ0aWVzKTtcblxuICBjbG9zZU1vZGFsT3BlbmluZygpO1xuXG4gIGV4cG9ydCBjb25zdCBnZXRFbGVtZW50ID0gKCkgPT4gZWxlbWVudDtcblxuICBleHBvcnQgZnVuY3Rpb24gY2xvc2VNb2RhbE9wZW5pbmcoKSB7XG4gICAgb3BlbmluZ1Byb3BlcnRpZXMgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgcjogMFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgbW9kYWwgb3ZlcmxheVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgbW9kYWxJc1Zpc2libGUgPSBmYWxzZTtcblxuICAgIC8vIEVuc3VyZSB3ZSBjbGVhbnVwIGFsbCBldmVudCBsaXN0ZW5lcnMgd2hlbiB3ZSBoaWRlIHRoZSBtb2RhbFxuICAgIF9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50IHdlIHdhbnQgdGhlIG9wZW5pbmcgb3ZlcnRvcCBvZiB0byBzZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9wZW5pbmcgYW5kIHBvc2l0aW9uIGl0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyBBbiBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtOdW1iZXIgfCB7IHRvcExlZnQ6IE51bWJlciwgYm90dG9tTGVmdDogTnVtYmVyLCBib3R0b21SaWdodDogTnVtYmVyLCB0b3BSaWdodDogTnVtYmVyIH19IG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMgQW4gYW1vdW50IG9mIGJvcmRlciByYWRpdXMgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNjcm9sbFBhcmVudCBUaGUgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgdGhlIHRhcmdldCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldEVsZW1lbnQgVGhlIGVsZW1lbnQgdGhlIG9wZW5pbmcgd2lsbCBleHBvc2VcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBwb3NpdGlvbk1vZGFsKFxuICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nID0gMCxcbiAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzID0gMCxcbiAgICBzY3JvbGxQYXJlbnQsXG4gICAgdGFyZ2V0RWxlbWVudFxuICApIHtcbiAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgY29uc3QgeyB5LCBoZWlnaHQgfSA9IF9nZXRWaXNpYmxlSGVpZ2h0KHRhcmdldEVsZW1lbnQsIHNjcm9sbFBhcmVudCk7XG4gICAgICBjb25zdCB7IHgsIHdpZHRoLCBsZWZ0IH0gPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgbm90IGNvbnNpc3RlbnQuIFNvbWUgYnJvd3NlcnMgdXNlIHggYW5kIHksIHdoaWxlIG90aGVycyB1c2UgbGVmdCBhbmQgdG9wXG4gICAgICBvcGVuaW5nUHJvcGVydGllcyA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgKiAyLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nICogMixcbiAgICAgICAgeDogKHggfHwgbGVmdCkgLSBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgICAgeTogeSAtIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICByOiBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZU1vZGFsT3BlbmluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBtb2RhbCBpcyBlbmFibGVkLCBzZXR1cCB0aGUgc3ZnIG1hc2sgb3BlbmluZyBhbmQgbW9kYWwgb3ZlcmxheSBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gc2V0dXBGb3JTdGVwKHN0ZXApIHtcbiAgICAvLyBFbnN1cmUgd2UgbW92ZSBsaXN0ZW5lcnMgZnJvbSB0aGUgcHJldmlvdXMgc3RlcCwgYmVmb3JlIHdlIHNldHVwIG5ldyBvbmVzXG4gICAgX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIGlmIChzdGVwLnRvdXIub3B0aW9ucy51c2VNb2RhbE92ZXJsYXkpIHtcbiAgICAgIF9zdHlsZUZvclN0ZXAoc3RlcCk7XG4gICAgICBzaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aGUgbW9kYWwgb3ZlcmxheVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgbW9kYWxJc1Zpc2libGUgPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgX3ByZXZlbnRNb2RhbEJvZHlUb3VjaCA9IChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIGNvbnN0IF9wcmV2ZW50TW9kYWxPdmVybGF5VG91Y2ggPSAoZSkgPT4ge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0b3VjaG1vdmUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgLy8gUHJldmVudHMgd2luZG93IGZyb20gbW92aW5nIG9uIHRvdWNoLlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfcHJldmVudE1vZGFsQm9keVRvdWNoLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AgYW5kIHJlbW92ZSB0b3VjaG1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfY2xlYW51cFN0ZXBFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAocmFmSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgICAgIHJhZklkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfcHJldmVudE1vZGFsQm9keVRvdWNoLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlIHRoZSBtb2RhbCBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIHRvIHN0eWxlIHRoZSBvcGVuaW5nIGZvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3N0eWxlRm9yU3RlcChzdGVwKSB7XG4gICAgY29uc3Qge1xuICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzXG4gICAgfSA9IHN0ZXAub3B0aW9ucztcblxuICAgIGNvbnN0IHNjcm9sbFBhcmVudCA9IF9nZXRTY3JvbGxQYXJlbnQoc3RlcC50YXJnZXQpO1xuXG4gICAgLy8gU2V0dXAgcmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGNhbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIHVwZGF0ZSB0aGUgbW9kYWwgb3BlbmluZyBwb3NpdGlvblxuICAgIGNvbnN0IHJhZkxvb3AgPSAoKSA9PiB7XG4gICAgICByYWZJZCA9IHVuZGVmaW5lZDtcbiAgICAgIHBvc2l0aW9uTW9kYWwoXG4gICAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzLFxuICAgICAgICBzY3JvbGxQYXJlbnQsXG4gICAgICAgIHN0ZXAudGFyZ2V0XG4gICAgICApO1xuICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmTG9vcCk7XG4gICAgfTtcblxuICAgIHJhZkxvb3AoKTtcblxuICAgIF9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBpc0h0bWxFbGVtZW50ID0gZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIGNvbnN0IG92ZXJmbG93WSA9XG4gICAgICBpc0h0bWxFbGVtZW50ICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLm92ZXJmbG93WTtcbiAgICBjb25zdCBpc1Njcm9sbGFibGUgPSBvdmVyZmxvd1kgIT09ICdoaWRkZW4nICYmIG92ZXJmbG93WSAhPT0gJ3Zpc2libGUnO1xuXG4gICAgaWYgKGlzU2Nyb2xsYWJsZSAmJiBlbGVtZW50LnNjcm9sbEhlaWdodCA+PSBlbGVtZW50LmNsaWVudEhlaWdodCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRTY3JvbGxQYXJlbnQoZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpc2libGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgc2Nyb2xsUGFyZW50LlxuICAgKiBJZiB0aGVyZSBpcyBubyBzY3JvbGwgcGFyZW50LCB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSB0YXJnZXQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbc2Nyb2xsUGFyZW50XSBUaGUgc2Nyb2xsYWJsZSBwYXJlbnQgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7e3k6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFZpc2libGVIZWlnaHQoZWxlbWVudCwgc2Nyb2xsUGFyZW50KSB7XG4gICAgY29uc3QgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB0b3AgPSBlbGVtZW50UmVjdC55IHx8IGVsZW1lbnRSZWN0LnRvcDtcbiAgICBsZXQgYm90dG9tID0gZWxlbWVudFJlY3QuYm90dG9tIHx8IHRvcCArIGVsZW1lbnRSZWN0LmhlaWdodDtcblxuICAgIGlmIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIGNvbnN0IHNjcm9sbFJlY3QgPSBzY3JvbGxQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBzY3JvbGxSZWN0LnkgfHwgc2Nyb2xsUmVjdC50b3A7XG4gICAgICBjb25zdCBzY3JvbGxCb3R0b20gPSBzY3JvbGxSZWN0LmJvdHRvbSB8fCBzY3JvbGxUb3AgKyBzY3JvbGxSZWN0LmhlaWdodDtcblxuICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBzY3JvbGxUb3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCBzY3JvbGxCb3R0b20pO1xuICAgIH1cblxuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KGJvdHRvbSAtIHRvcCwgMCk7IC8vIERlZmF1bHQgdG8gMCBpZiBoZWlnaHQgaXMgbmVnYXRpdmVcblxuICAgIHJldHVybiB7IHk6IHRvcCwgaGVpZ2h0IH07XG4gIH1cbjwvc2NyaXB0PlxuXG48c3ZnXG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgY2xhc3M9e2Ake1xuICAgIG1vZGFsSXNWaXNpYmxlID8gJ3NoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUnIDogJydcbiAgfSBzaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lcmB9XG4gIG9uOnRvdWNobW92ZT17X3ByZXZlbnRNb2RhbE92ZXJsYXlUb3VjaH1cbj5cbiAgPHBhdGggZD17cGF0aERlZmluaXRpb259IC8+XG48L3N2Zz5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyIHtcbiAgICBoZWlnaHQ6IDA7XG4gICAgbGVmdDogMDtcbiAgICBvcGFjaXR5OiAwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlLW91dCwgaGVpZ2h0IDBtcyAwLjNzLCBvcGFjaXR5IDAuM3MgMG1zO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICB6LWluZGV4OiA5OTk3O1xuICB9XG5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyLnNoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUge1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgb3BhY2l0eTogMC41O1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2Utb3V0LCBoZWlnaHQgMHMgMHMsIG9wYWNpdHkgMC4zcyAwcztcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gIH1cblxuICAuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXIuc2hlcGhlcmQtbW9kYWwtaXMtdmlzaWJsZSBwYXRoIHtcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICB9XG48L3N0eWxlPlxuIiwiaW1wb3J0IHsgRXZlbnRlZCB9IGZyb20gJy4vZXZlbnRlZC5qcyc7XG5pbXBvcnQgeyBTdGVwIH0gZnJvbSAnLi9zdGVwLmpzJztcbmltcG9ydCBhdXRvQmluZCBmcm9tICcuL3V0aWxzL2F1dG8tYmluZC5qcyc7XG5pbXBvcnQge1xuICBpc0hUTUxFbGVtZW50LFxuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmluZyxcbiAgaXNVbmRlZmluZWRcbn0gZnJvbSAnLi91dGlscy90eXBlLWNoZWNrLmpzJztcbmltcG9ydCB7IGNsZWFudXBTdGVwcyB9IGZyb20gJy4vdXRpbHMvY2xlYW51cC5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVQcmVmaXgsIHV1aWQgfSBmcm9tICcuL3V0aWxzL2dlbmVyYWwuanMnO1xuaW1wb3J0IFNoZXBoZXJkTW9kYWwgZnJvbSAnLi9jb21wb25lbnRzL3NoZXBoZXJkLW1vZGFsLnN2ZWx0ZSc7XG5cbmNvbnN0IFNoZXBoZXJkID0gbmV3IEV2ZW50ZWQoKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgdGhlIHNpdGUgdG91clxuICogQGV4dGVuZHMge0V2ZW50ZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBUb3VyIGV4dGVuZHMgRXZlbnRlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHRvdXJcbiAgICogQHBhcmFtIHtib29sZWFuIHwgZnVuY3Rpb24oKTogYm9vbGVhbiB8IFByb21pc2U8Ym9vbGVhbj4gfCBmdW5jdGlvbigpOiBQcm9taXNlPGJvb2xlYW4+fSBvcHRpb25zLmNvbmZpcm1DYW5jZWwgSWYgdHJ1ZSwgd2lsbCBpc3N1ZSBhIGB3aW5kb3cuY29uZmlybWAgYmVmb3JlIGNhbmNlbGxpbmcuXG4gICAqIElmIGl0IGlzIGEgZnVuY3Rpb24oc3VwcG9ydCBBc3luYyBGdW5jdGlvbiksIGl0IHdpbGwgYmUgY2FsbGVkIGFuZCB3YWl0IGZvciB0aGUgcmV0dXJuIHZhbHVlLCBhbmQgd2lsbCBvbmx5IGJlIGNhbmNlbGxlZCBpZiB0aGUgdmFsdWUgcmV0dXJuZWQgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jb25maXJtQ2FuY2VsTWVzc2FnZSBUaGUgbWVzc2FnZSB0byBkaXNwbGF5IGluIHRoZSBgd2luZG93LmNvbmZpcm1gIGRpYWxvZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jbGFzc1ByZWZpeCBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgYHNoZXBoZXJkLWVuYWJsZWRgIGFuZCBgc2hlcGhlcmQtdGFyZ2V0YCBjbGFzcyBuYW1lcyBhcyB3ZWxsIGFzIHRoZSBgZGF0YS1zaGVwaGVyZC1zdGVwLWlkYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGVmYXVsdFN0ZXBPcHRpb25zIERlZmF1bHQgb3B0aW9ucyBmb3IgU3RlcHMgKHtAbGluayBTdGVwI2NvbnN0cnVjdG9yfSksIGNyZWF0ZWQgdGhyb3VnaCBgYWRkU3RlcGBcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmV4aXRPbkVzYyBFeGl0aW5nIHRoZSB0b3VyIHdpdGggdGhlIGVzY2FwZSBrZXkgd2lsbCBiZSBlbmFibGVkIHVubGVzcyB0aGlzIGlzIGV4cGxpY2l0bHlcbiAgICogc2V0IHRvIGZhbHNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMua2V5Ym9hcmROYXZpZ2F0aW9uIE5hdmlnYXRpbmcgdGhlIHRvdXIgdmlhIGxlZnQgYW5kIHJpZ2h0IGFycm93IGtleXMgd2lsbCBiZSBlbmFibGVkXG4gICAqIHVubGVzcyB0aGlzIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLnN0ZXBzQ29udGFpbmVyIEFuIG9wdGlvbmFsIGNvbnRhaW5lciBlbGVtZW50IGZvciB0aGUgc3RlcHMuXG4gICAqIElmIG5vdCBzZXQsIHRoZSBzdGVwcyB3aWxsIGJlIGFwcGVuZGVkIHRvIGBkb2N1bWVudC5ib2R5YC5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5tb2RhbENvbnRhaW5lciBBbiBvcHRpb25hbCBjb250YWluZXIgZWxlbWVudCBmb3IgdGhlIG1vZGFsLlxuICAgKiBJZiBub3Qgc2V0LCB0aGUgbW9kYWwgd2lsbCBiZSBhcHBlbmRlZCB0byBgZG9jdW1lbnQuYm9keWAuXG4gICAqIEBwYXJhbSB7b2JqZWN0W10gfCBTdGVwW119IG9wdGlvbnMuc3RlcHMgQW4gYXJyYXkgb2Ygc3RlcCBvcHRpb25zIG9iamVjdHMgb3IgU3RlcCBpbnN0YW5jZXMgdG8gaW5pdGlhbGl6ZSB0aGUgdG91ciB3aXRoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvdXJOYW1lIEFuIG9wdGlvbmFsIFwibmFtZVwiIGZvciB0aGUgdG91ci4gVGhpcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSB0aGUgdG91cidzXG4gICAqIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBgaWRgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMudXNlTW9kYWxPdmVybGF5IFdoZXRoZXIgb3Igbm90IHN0ZXBzIHNob3VsZCBiZSBwbGFjZWQgYWJvdmUgYSBkYXJrZW5lZFxuICAgKiBtb2RhbCBvdmVybGF5LiBJZiB0cnVlLCB0aGUgb3ZlcmxheSB3aWxsIGNyZWF0ZSBhbiBvcGVuaW5nIGFyb3VuZCB0aGUgdGFyZ2V0IGVsZW1lbnQgc28gdGhhdCBpdFxuICAgKiBjYW4gcmVtYWluIGludGVyYWN0aXZlXG4gICAqIEByZXR1cm5zIHtUb3VyfVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICBhdXRvQmluZCh0aGlzKTtcblxuICAgIGNvbnN0IGRlZmF1bHRUb3VyT3B0aW9ucyA9IHtcbiAgICAgIGV4aXRPbkVzYzogdHJ1ZSxcbiAgICAgIGtleWJvYXJkTmF2aWdhdGlvbjogdHJ1ZVxuICAgIH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0VG91ck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2xhc3NQcmVmaXggPSBub3JtYWxpemVQcmVmaXgodGhpcy5vcHRpb25zLmNsYXNzUHJlZml4KTtcbiAgICB0aGlzLnN0ZXBzID0gW107XG4gICAgdGhpcy5hZGRTdGVwcyh0aGlzLm9wdGlvbnMuc3RlcHMpO1xuXG4gICAgLy8gUGFzcyB0aGVzZSBldmVudHMgb250byB0aGUgZ2xvYmFsIFNoZXBoZXJkIG9iamVjdFxuICAgIGNvbnN0IGV2ZW50cyA9IFtcbiAgICAgICdhY3RpdmUnLFxuICAgICAgJ2NhbmNlbCcsXG4gICAgICAnY29tcGxldGUnLFxuICAgICAgJ2luYWN0aXZlJyxcbiAgICAgICdzaG93JyxcbiAgICAgICdzdGFydCdcbiAgICBdO1xuICAgIGV2ZW50cy5tYXAoKGV2ZW50KSA9PiB7XG4gICAgICAoKGUpID0+IHtcbiAgICAgICAgdGhpcy5vbihlLCAob3B0cykgPT4ge1xuICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAgIG9wdHMudG91ciA9IHRoaXM7XG4gICAgICAgICAgU2hlcGhlcmQudHJpZ2dlcihlLCBvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KShldmVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZXRUb3VySUQoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgc3RlcCB0byB0aGUgdG91clxuICAgKiBAcGFyYW0ge09iamVjdHxTdGVwfSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHN0ZXAgb3B0aW9ucyBvciBhIFN0ZXAgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBvcHRpb25hbCBpbmRleCB0byBpbnNlcnQgdGhlIHN0ZXAgYXQuIElmIHVuZGVmaW5lZCwgdGhlIHN0ZXBcbiAgICogaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAqIEByZXR1cm4ge1N0ZXB9IFRoZSBuZXdseSBhZGRlZCBzdGVwXG4gICAqL1xuICBhZGRTdGVwKG9wdGlvbnMsIGluZGV4KSB7XG4gICAgbGV0IHN0ZXAgPSBvcHRpb25zO1xuXG4gICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFN0ZXApKSB7XG4gICAgICBzdGVwID0gbmV3IFN0ZXAodGhpcywgc3RlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZXAudG91ciA9IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFpc1VuZGVmaW5lZChpbmRleCkpIHtcbiAgICAgIHRoaXMuc3RlcHMuc3BsaWNlKGluZGV4LCAwLCBzdGVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGVwcy5wdXNoKHN0ZXApO1xuICAgIH1cblxuICAgIHJldHVybiBzdGVwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBtdWx0aXBsZSBzdGVwcyB0byB0aGUgdG91clxuICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdD4gfCBBcnJheTxTdGVwPn0gc3RlcHMgVGhlIHN0ZXBzIHRvIGFkZCB0byB0aGUgdG91clxuICAgKi9cbiAgYWRkU3RlcHMoc3RlcHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdGVwcykpIHtcbiAgICAgIHN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHtcbiAgICAgICAgdGhpcy5hZGRTdGVwKHN0ZXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR28gdG8gdGhlIHByZXZpb3VzIHN0ZXAgaW4gdGhlIHRvdXJcbiAgICovXG4gIGJhY2soKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2YodGhpcy5jdXJyZW50U3RlcCk7XG4gICAgdGhpcy5zaG93KGluZGV4IC0gMSwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIF9kb25lKCkgdHJpZ2dlcmluZyB0aGUgJ2NhbmNlbCcgZXZlbnRcbiAgICogSWYgYGNvbmZpcm1DYW5jZWxgIGlzIHRydWUsIHdpbGwgc2hvdyBhIHdpbmRvdy5jb25maXJtIGJlZm9yZSBjYW5jZWxsaW5nXG4gICAqIElmIGBjb25maXJtQ2FuY2VsYCBpcyBhIGZ1bmN0aW9uLCB3aWxsIGNhbGwgaXQgYW5kIHdhaXQgZm9yIHRoZSByZXR1cm4gdmFsdWUsXG4gICAqIGFuZCBvbmx5IGNhbmNlbCB3aGVuIHRoZSB2YWx1ZSByZXR1cm5lZCBpcyB0cnVlXG4gICAqL1xuICBhc3luYyBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25maXJtQ2FuY2VsKSB7XG4gICAgICBjb25zdCBjb25maXJtQ2FuY2VsSXNGdW5jdGlvbiA9XG4gICAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMuY29uZmlybUNhbmNlbCA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGNvbnN0IGNhbmNlbE1lc3NhZ2UgPVxuICAgICAgICB0aGlzLm9wdGlvbnMuY29uZmlybUNhbmNlbE1lc3NhZ2UgfHxcbiAgICAgICAgJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBzdG9wIHRoZSB0b3VyPyc7XG4gICAgICBjb25zdCBzdG9wVG91ciA9IGNvbmZpcm1DYW5jZWxJc0Z1bmN0aW9uXG4gICAgICAgID8gYXdhaXQgdGhpcy5vcHRpb25zLmNvbmZpcm1DYW5jZWwoKVxuICAgICAgICA6IHdpbmRvdy5jb25maXJtKGNhbmNlbE1lc3NhZ2UpO1xuICAgICAgaWYgKHN0b3BUb3VyKSB7XG4gICAgICAgIHRoaXMuX2RvbmUoJ2NhbmNlbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kb25lKCdjYW5jZWwnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgX2RvbmUoKSB0cmlnZ2VyaW5nIHRoZSBgY29tcGxldGVgIGV2ZW50XG4gICAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLl9kb25lKCdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0ZXAgZnJvbSBhIGdpdmVuIGlkXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBzdGVwIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm4ge1N0ZXB9IFRoZSBzdGVwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGBpZGBcbiAgICovXG4gIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwcy5maW5kKChzdGVwKSA9PiB7XG4gICAgICByZXR1cm4gc3RlcC5pZCA9PT0gaWQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzdGVwXG4gICAqIEByZXR1cm5zIHtTdGVwfG51bGx9XG4gICAqL1xuICBnZXRDdXJyZW50U3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBjdXJyZW50IHN0ZXBcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgY29uc3QgY3VycmVudFN0ZXAgPSB0aGlzLmdldEN1cnJlbnRTdGVwKCk7XG5cbiAgICBpZiAoY3VycmVudFN0ZXApIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3RlcC5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0b3VyIGlzIGFjdGl2ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIFNoZXBoZXJkLmFjdGl2ZVRvdXIgPT09IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR28gdG8gdGhlIG5leHQgc3RlcCBpbiB0aGUgdG91clxuICAgKiBJZiB3ZSBhcmUgYXQgdGhlIGVuZCwgY2FsbCBgY29tcGxldGVgXG4gICAqL1xuICBuZXh0KCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KGluZGV4ICsgMSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHN0ZXAgZnJvbSB0aGUgdG91clxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaWQgZm9yIHRoZSBzdGVwIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlU3RlcChuYW1lKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKTtcblxuICAgIC8vIEZpbmQgdGhlIHN0ZXAsIGRlc3Ryb3kgaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoaXMuc3RlcHNcbiAgICB0aGlzLnN0ZXBzLnNvbWUoKHN0ZXAsIGkpID0+IHtcbiAgICAgIGlmIChzdGVwLmlkID09PSBuYW1lKSB7XG4gICAgICAgIGlmIChzdGVwLmlzT3BlbigpKSB7XG4gICAgICAgICAgc3RlcC5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGVwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdGVwcy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmlkID09PSBuYW1lKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIHN0ZXBzIGxlZnQsIHNob3cgdGhlIGZpcnN0IG9uZSwgb3RoZXJ3aXNlIGp1c3QgY2FuY2VsIHRoZSB0b3VyXG4gICAgICB0aGlzLnN0ZXBzLmxlbmd0aCA/IHRoaXMuc2hvdygwKSA6IHRoaXMuY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgYSBzcGVjaWZpYyBzdGVwIGluIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5IFRoZSBrZXkgdG8gbG9vayB1cCB0aGUgc3RlcCBieVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcndhcmQgVHJ1ZSBpZiB3ZSBhcmUgZ29pbmcgZm9yd2FyZCwgZmFsc2UgaWYgYmFja3dhcmRcbiAgICovXG4gIHNob3coa2V5ID0gMCwgZm9yd2FyZCA9IHRydWUpIHtcbiAgICBjb25zdCBzdGVwID0gaXNTdHJpbmcoa2V5KSA/IHRoaXMuZ2V0QnlJZChrZXkpIDogdGhpcy5zdGVwc1trZXldO1xuXG4gICAgaWYgKHN0ZXApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdygpO1xuXG4gICAgICBjb25zdCBzaG91bGRTa2lwU3RlcCA9XG4gICAgICAgIGlzRnVuY3Rpb24oc3RlcC5vcHRpb25zLnNob3dPbikgJiYgIXN0ZXAub3B0aW9ucy5zaG93T24oKTtcblxuICAgICAgLy8gSWYgYHNob3dPbmAgcmV0dXJucyBmYWxzZSwgd2Ugd2FudCB0byBza2lwIHRoZSBzdGVwLCBvdGhlcndpc2UsIHNob3cgdGhlIHN0ZXAgbGlrZSBub3JtYWxcbiAgICAgIGlmIChzaG91bGRTa2lwU3RlcCkge1xuICAgICAgICB0aGlzLl9za2lwU3RlcChzdGVwLCBmb3J3YXJkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignc2hvdycsIHtcbiAgICAgICAgICBzdGVwLFxuICAgICAgICAgIHByZXZpb3VzOiB0aGlzLmN1cnJlbnRTdGVwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBzdGVwO1xuICAgICAgICBzdGVwLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIHRvdXJcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMudHJpZ2dlcignc3RhcnQnKTtcblxuICAgIC8vIFNhdmUgdGhlIGZvY3VzZWQgZWxlbWVudCBiZWZvcmUgdGhlIHRvdXIgb3BlbnNcbiAgICB0aGlzLmZvY3VzZWRFbEJlZm9yZU9wZW4gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IG51bGw7XG5cbiAgICB0aGlzLl9zZXR1cE1vZGFsKCk7XG5cbiAgICB0aGlzLl9zZXR1cEFjdGl2ZVRvdXIoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHRvdXIgaXMgY2FuY2VsbGVkIG9yIGNvbXBsZXRlZCwgYmFzaWNhbGx5IGFueXRpbWUgd2UgZXhpdCB0aGUgdG91clxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUgdG8gdHJpZ2dlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RvbmUoZXZlbnQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGVwKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnN0ZXBzKSkge1xuICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwKSA9PiBzdGVwLmRlc3Ryb3koKSk7XG4gICAgfVxuXG4gICAgY2xlYW51cFN0ZXBzKHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKGV2ZW50LCB7IGluZGV4IH0pO1xuXG4gICAgU2hlcGhlcmQuYWN0aXZlVG91ciA9IG51bGw7XG4gICAgdGhpcy50cmlnZ2VyKCdpbmFjdGl2ZScsIHsgdG91cjogdGhpcyB9KTtcblxuICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICB0aGlzLm1vZGFsLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgPT09ICdjYW5jZWwnIHx8IGV2ZW50ID09PSAnY29tcGxldGUnKSB7XG4gICAgICBpZiAodGhpcy5tb2RhbCkge1xuICAgICAgICBjb25zdCBtb2RhbENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgJy5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lcidcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobW9kYWxDb250YWluZXIpIHtcbiAgICAgICAgICBtb2RhbENvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvY3VzIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSB0b3VyIHN0YXJ0ZWRcbiAgICBpZiAoaXNIVE1MRWxlbWVudCh0aGlzLmZvY3VzZWRFbEJlZm9yZU9wZW4pKSB7XG4gICAgICB0aGlzLmZvY3VzZWRFbEJlZm9yZU9wZW4uZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIHRvdXIgXCJhY3RpdmVcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwQWN0aXZlVG91cigpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2FjdGl2ZScsIHsgdG91cjogdGhpcyB9KTtcblxuICAgIFNoZXBoZXJkLmFjdGl2ZVRvdXIgPSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIF9zZXR1cE1vZGFsIGNyZWF0ZSB0aGUgbW9kYWwgY29udGFpbmVyIGFuZCBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwTW9kYWwoKSB7XG4gICAgdGhpcy5tb2RhbCA9IG5ldyBTaGVwaGVyZE1vZGFsKHtcbiAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLm1vZGFsQ29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHksXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbGFzc1ByZWZpeDogdGhpcy5jbGFzc1ByZWZpeCxcbiAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGBzaG93T25gIGV2YWx1YXRlcyB0byBmYWxzZSwgdG8gc2tpcCB0aGUgc3RlcCBvciBjb21wbGV0ZSB0aGUgdG91ciBpZiBpdCdzIHRoZSBsYXN0IHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIHRvIHNraXBcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3J3YXJkIFRydWUgaWYgd2UgYXJlIGdvaW5nIGZvcndhcmQsIGZhbHNlIGlmIGJhY2t3YXJkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2tpcFN0ZXAoc3RlcCwgZm9yd2FyZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHN0ZXApO1xuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV4dEluZGV4ID0gZm9yd2FyZCA/IGluZGV4ICsgMSA6IGluZGV4IC0gMTtcbiAgICAgIHRoaXMuc2hvdyhuZXh0SW5kZXgsIGZvcndhcmQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgc2hvd2luZywgaGlkZSB0aGUgY3VycmVudCBzdGVwIGFuZCBpZiB0aGUgdG91ciBpcyBub3RcbiAgICogYWxyZWFkeSBhY3RpdmUsIGNhbGwgYHRoaXMuX3NldHVwQWN0aXZlVG91cmAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU3RhdGVCZWZvcmVTaG93KCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTdGVwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fc2V0dXBBY3RpdmVUb3VyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcy5pZCB0byBgJHt0b3VyTmFtZX0tLSR7dXVpZH1gXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0VG91cklEKCkge1xuICAgIGNvbnN0IHRvdXJOYW1lID0gdGhpcy5vcHRpb25zLnRvdXJOYW1lIHx8ICd0b3VyJztcblxuICAgIHRoaXMuaWQgPSBgJHt0b3VyTmFtZX0tLSR7dXVpZCgpfWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgU2hlcGhlcmQgfTtcbiIsImltcG9ydCB7IFN0ZXAgfSBmcm9tICcuL3N0ZXAuanMnO1xuaW1wb3J0IHsgU2hlcGhlcmQsIFRvdXIgfSBmcm9tICcuL3RvdXIuanMnO1xuXG5jb25zdCBpc1NlcnZlclNpZGUgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcblxuY2xhc3MgTm9PcCB7XG4gIGNvbnN0cnVjdG9yKCkge31cbn1cblxuaWYgKGlzU2VydmVyU2lkZSkge1xuICBPYmplY3QuYXNzaWduKFNoZXBoZXJkLCB7IFRvdXI6IE5vT3AsIFN0ZXA6IE5vT3AgfSk7XG59IGVsc2Uge1xuICBPYmplY3QuYXNzaWduKFNoZXBoZXJkLCB7IFRvdXIsIFN0ZXAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNoZXBoZXJkO1xuIl0sIm5hbWVzIjpbImlzTWVyZ2VhYmxlT2JqZWN0IiwidmFsdWUiLCJpc05vbk51bGxPYmplY3QiLCJpc1NwZWNpYWwiLCJfdHlwZW9mIiwic3RyaW5nVmFsdWUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1JlYWN0RWxlbWVudCIsImNhblVzZVN5bWJvbCIsIlN5bWJvbCIsImZvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIiQkdHlwZW9mIiwiZW1wdHlUYXJnZXQiLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCIsIm9wdGlvbnMiLCJjbG9uZSIsImRlZXBtZXJnZSIsImRlZmF1bHRBcnJheU1lcmdlIiwidGFyZ2V0Iiwic291cmNlIiwiY29uY2F0IiwibWFwIiwiZWxlbWVudCIsImdldE1lcmdlRnVuY3Rpb24iLCJrZXkiLCJjdXN0b21NZXJnZSIsImdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJzeW1ib2wiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImdldEtleXMiLCJrZXlzIiwicHJvcGVydHlJc09uT2JqZWN0Iiwib2JqZWN0IiwicHJvcGVydHkiLCJfIiwicHJvcGVydHlJc1Vuc2FmZSIsImhhc093blByb3BlcnR5IiwibWVyZ2VPYmplY3QiLCJkZXN0aW5hdGlvbiIsImZvckVhY2giLCJhcnJheU1lcmdlIiwic291cmNlSXNBcnJheSIsInRhcmdldElzQXJyYXkiLCJzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoIiwiYWxsIiwiZGVlcG1lcmdlQWxsIiwiYXJyYXkiLCJFcnJvciIsInJlZHVjZSIsInByZXYiLCJuZXh0IiwiZGVlcG1lcmdlXzEiLCJjanMiLCJpc0VsZW1lbnQkMSIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50JDEiLCJIVE1MRWxlbWVudCIsImlzRnVuY3Rpb24iLCJpc1N0cmluZyIsImlzVW5kZWZpbmVkIiwidW5kZWZpbmVkIiwiRXZlbnRlZCIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsIm9uIiwiZXZlbnQiLCJoYW5kbGVyIiwiY3R4Iiwib25jZSIsImJpbmRpbmdzIiwicHVzaCIsIm9mZiIsIl90aGlzIiwiYmluZGluZyIsImluZGV4Iiwic3BsaWNlIiwidHJpZ2dlciIsIl90aGlzMiIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiX2tleSIsImNvbnRleHQiLCJhcHBseSIsImF1dG9CaW5kIiwic2VsZiIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25zdHJ1Y3RvciIsImkiLCJiaW5kIiwiX3NldHVwQWR2YW5jZU9uSGFuZGxlciIsInNlbGVjdG9yIiwic3RlcCIsImlzT3BlbiIsInRhcmdldElzRWwiLCJlbCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXRJc1NlbGVjdG9yIiwibWF0Y2hlcyIsInRvdXIiLCJiaW5kQWR2YW5jZSIsIl9yZWYyIiwiYWR2YW5jZU9uIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYm9keSIsIm5vcm1hbGl6ZVByZWZpeCIsInByZWZpeCIsImNoYXJBdCIsInBhcnNlQXR0YWNoVG8iLCJhdHRhY2hUbyIsInJldHVybk9wdHMiLCJhc3NpZ24iLCJzaG91bGRDZW50ZXJTdGVwIiwicmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMiLCJ1dWlkIiwiZCIsIkRhdGUiLCJub3ciLCJyZXBsYWNlIiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwiZmxvb3IiLCJnZXRBbGlnbm1lbnQiLCJwbGFjZW1lbnQiLCJzcGxpdCIsImdldExlbmd0aEZyb21BeGlzIiwiYXhpcyIsImdldFNpZGUiLCJnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQiLCJpbmNsdWRlcyIsImNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50IiwiX3JlZiIsInJ0bCIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwiY29tbW9uWCIsIngiLCJ3aWR0aCIsImNvbW1vblkiLCJ5IiwiaGVpZ2h0IiwibWFpbkF4aXMiLCJjb21tb25BbGlnbiIsInNpZGUiLCJpc1ZlcnRpY2FsIiwiY29vcmRzIiwiY29tcHV0ZVBvc2l0aW9uJDEiLCJfcmVmMyIsIl9hc3luY1RvR2VuZXJhdG9yIiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsIm1hcmsiLCJfY2FsbGVlIiwiY29uZmlnIiwiX2NvbmZpZyRwbGFjZW1lbnQiLCJfY29uZmlnJHN0cmF0ZWd5Iiwic3RyYXRlZ3kiLCJfY29uZmlnJG1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlIiwicGxhdGZvcm0iLCJ2YWxpZE1pZGRsZXdhcmUiLCJyZWN0cyIsIl9jb21wdXRlQ29vcmRzRnJvbVBsYSIsInN0YXRlZnVsUGxhY2VtZW50IiwibWlkZGxld2FyZURhdGEiLCJyZXNldENvdW50IiwiX3ZhbGlkTWlkZGxld2FyZSRpIiwibmFtZSIsImZuIiwiX3lpZWxkJGZuIiwibmV4dFgiLCJuZXh0WSIsImRhdGEiLCJyZXNldCIsIl9jb21wdXRlQ29vcmRzRnJvbVBsYTIiLCJ3cmFwIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsIkJvb2xlYW4iLCJpc1JUTCIsInNlbnQiLCJnZXRFbGVtZW50UmVjdHMiLCJpbml0aWFsUGxhY2VtZW50IiwiZWxlbWVudHMiLCJfZXh0ZW5kcyIsIl9kZWZpbmVQcm9wZXJ0eSIsInQwIiwiYWJydXB0Iiwic3RvcCIsImNvbXB1dGVQb3NpdGlvbiIsIl94IiwiX3gyIiwiX3gzIiwiZXhwYW5kUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJnZXRTaWRlT2JqZWN0RnJvbVBhZGRpbmciLCJyZWN0VG9DbGllbnRSZWN0IiwicmVjdCIsImRldGVjdE92ZXJmbG93IiwiX3g0IiwiX3g1IiwiX2RldGVjdE92ZXJmbG93IiwiX2NhbGxlZTciLCJzdGF0ZSIsIl9hd2FpdCRwbGF0Zm9ybSRpc0VsZSIsIl9vcHRpb25zNSIsIl9vcHRpb25zNSRib3VuZGFyeSIsImJvdW5kYXJ5IiwiX29wdGlvbnM1JHJvb3RCb3VuZGFyIiwicm9vdEJvdW5kYXJ5IiwiX29wdGlvbnM1JGVsZW1lbnRDb250IiwiZWxlbWVudENvbnRleHQiLCJfb3B0aW9uczUkYWx0Qm91bmRhcnkiLCJhbHRCb3VuZGFyeSIsIl9vcHRpb25zNSRwYWRkaW5nIiwicGFkZGluZ09iamVjdCIsImFsdENvbnRleHQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJvZmZzZXRQYXJlbnQiLCJvZmZzZXRTY2FsZSIsImVsZW1lbnRDbGllbnRSZWN0IiwiX2NhbGxlZTckIiwiX2NvbnRleHQ3IiwidDEiLCJpc0VsZW1lbnQiLCJ0MiIsInQzIiwidDQiLCJ0NSIsImNvbnRleHRFbGVtZW50IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwidDYiLCJ0NyIsInQ4IiwidDkiLCJ0MTAiLCJnZXRDbGlwcGluZ1JlY3QiLCJ0MTEiLCJnZXRPZmZzZXRQYXJlbnQiLCJnZXRTY2FsZSIsInQxMyIsInQxMiIsInQxNCIsImNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0IiwidDE1IiwidDE2IiwibWluJDEiLCJtaW4iLCJtYXgkMSIsIm1heCIsIndpdGhpbiIsIm1pbiQxJDEiLCJtYXgkMSQxIiwiYXJyb3ciLCJfY2FsbGVlMiIsIl9kYXRhIiwiX3JlZjUiLCJfcmVmNCIsIl9yZWY0JHBhZGRpbmciLCJhcnJvd0RpbWVuc2lvbnMiLCJpc1lBeGlzIiwibWluUHJvcCIsIm1heFByb3AiLCJjbGllbnRQcm9wIiwiZW5kRGlmZiIsInN0YXJ0RGlmZiIsImFycm93T2Zmc2V0UGFyZW50IiwiY2xpZW50U2l6ZSIsImNlbnRlclRvUmVmZXJlbmNlIiwiY2VudGVyIiwib2Zmc2V0Iiwic2hvdWxkQWRkT2Zmc2V0IiwiYWxpZ25tZW50T2Zmc2V0IiwiX2NhbGxlZTIkIiwiX2NvbnRleHQyIiwiZ2V0RGltZW5zaW9ucyIsIm9wcG9zaXRlU2lkZU1hcCIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJhbGlnbm1lbnQiLCJtYWluQWxpZ25tZW50U2lkZSIsIm1haW4iLCJjcm9zcyIsIm9wcG9zaXRlQWxpZ25tZW50TWFwIiwic3RhcnQiLCJlbmQiLCJnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCIsImdldEV4cGFuZGVkUGxhY2VtZW50cyIsIm9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0U2lkZUxpc3QiLCJpc1N0YXJ0IiwibHIiLCJybCIsInRiIiwiYnQiLCJnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzIiwiZmxpcEFsaWdubWVudCIsImRpcmVjdGlvbiIsImxpc3QiLCJmbGlwIiwiX2NhbGxlZTMiLCJfbWlkZGxld2FyZURhdGEkZmxpcCIsIl9vcHRpb25zIiwiX29wdGlvbnMkbWFpbkF4aXMiLCJjaGVja01haW5BeGlzIiwiX29wdGlvbnMkY3Jvc3NBeGlzIiwiY2hlY2tDcm9zc0F4aXMiLCJzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMiLCJfb3B0aW9ucyRmYWxsYmFja1N0cmEiLCJmYWxsYmFja1N0cmF0ZWd5IiwiX29wdGlvbnMkZmFsbGJhY2tBeGlzIiwiZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiIsIl9vcHRpb25zJGZsaXBBbGlnbm1lbiIsImRldGVjdE92ZXJmbG93T3B0aW9ucyIsImlzQmFzZVBsYWNlbWVudCIsImZhbGxiYWNrUGxhY2VtZW50cyIsInBsYWNlbWVudHMiLCJvdmVyZmxvdyIsIm92ZXJmbG93cyIsIm92ZXJmbG93c0RhdGEiLCJfZ2V0QWxpZ25tZW50U2lkZXMiLCJfbWlkZGxld2FyZURhdGEkZmxpcDIiLCJfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIiLCJuZXh0SW5kZXgiLCJuZXh0UGxhY2VtZW50IiwicmVzZXRQbGFjZW1lbnQiLCJfb3ZlcmZsb3dzRGF0YSRtYXAkc28iLCJfcGxhY2VtZW50IiwiX2NhbGxlZTMkIiwiX2NvbnRleHQzIiwiY3Jvc3NBeGlzIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJfZXhjbHVkZWQyIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiZXZlcnkiLCJzb3J0IiwiYSIsImIiLCJhY2MiLCJnZXRDcm9zc0F4aXMiLCJzaGlmdCIsIl9jYWxsZWU0IiwiX2V4dGVuZHMzIiwiX29wdGlvbnMyIiwiX29wdGlvbnMyJG1haW5BeGlzIiwiX29wdGlvbnMyJGNyb3NzQXhpcyIsIl9vcHRpb25zMiRsaW1pdGVyIiwibGltaXRlciIsIm1haW5BeGlzQ29vcmQiLCJjcm9zc0F4aXNDb29yZCIsIm1pblNpZGUiLCJtYXhTaWRlIiwiX21pbiIsIl9tYXgiLCJfbWluU2lkZSIsIl9tYXhTaWRlIiwiX21pbjIiLCJfbWF4MiIsImxpbWl0ZWRDb29yZHMiLCJfY2FsbGVlNCQiLCJfY29udGV4dDQiLCJfZXhjbHVkZWQ0IiwibGltaXRTaGlmdCIsIl9yZWY2IiwiX29wdGlvbnMzIiwiX29wdGlvbnMzJG9mZnNldCIsIl9vcHRpb25zMyRtYWluQXhpcyIsIl9vcHRpb25zMyRjcm9zc0F4aXMiLCJyYXdPZmZzZXQiLCJjb21wdXRlZE9mZnNldCIsImxlbiIsImxpbWl0TWluIiwibGltaXRNYXgiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UyIiwiaXNPcmlnaW5TaWRlIiwiZ2V0V2luZG93Iiwibm9kZSIsIl9ub2RlJG93bmVyRG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlJDEiLCJnZXRDb21wdXRlZFN0eWxlIiwiaXNOb2RlIiwiTm9kZSIsImdldE5vZGVOYW1lIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsInVhU3RyaW5nIiwiZ2V0VUFTdHJpbmciLCJ1YURhdGEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnREYXRhIiwiYnJhbmRzIiwiaXRlbSIsImJyYW5kIiwidmVyc2lvbiIsImpvaW4iLCJ1c2VyQWdlbnQiLCJpc0hUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsIk93bkVsZW1lbnQiLCJpc092ZXJmbG93RWxlbWVudCIsIl9nZXRDb21wdXRlZFN0eWxlJCIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImRpc3BsYXkiLCJ0ZXN0IiwiaXNUYWJsZUVsZW1lbnQiLCJpc0NvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsImNzcyIsImJhY2tkcm9wRmlsdGVyIiwiV2Via2l0QmFja2Ryb3BGaWx0ZXIiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsIndpbGxDaGFuZ2UiLCJzb21lIiwiY29udGFpbiIsImlzQ2xpZW50UmVjdFZpc3VhbFZpZXdwb3J0QmFzZWQiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJyb3VuZCIsImdldENzc0RpbWVuc2lvbnMiLCJwYXJzZUZsb2F0IiwiaGFzT2Zmc2V0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzaG91bGRGYWxsYmFjayIsImZhbGxiYWNrIiwidW53cmFwRWxlbWVudCIsIkZBTExCQUNLX1NDQUxFIiwiZG9tRWxlbWVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIl9nZXRDc3NEaW1lbnNpb25zIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpbmNsdWRlU2NhbGUiLCJpc0ZpeGVkU3RyYXRlZ3kiLCJfd2luJHZpc3VhbFZpZXdwb3J0IiwiX3dpbiR2aXN1YWxWaWV3cG9ydDIiLCJjbGllbnRSZWN0Iiwic2NhbGUiLCJ3aW4iLCJhZGRWaXN1YWxPZmZzZXRzIiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0V2luIiwiY3VycmVudElGcmFtZSIsImZyYW1lRWxlbWVudCIsImlmcmFtZVNjYWxlIiwiaWZyYW1lUmVjdCIsImNsaWVudExlZnQiLCJwYWRkaW5nTGVmdCIsImNsaWVudFRvcCIsInBhZGRpbmdUb3AiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXROb2RlU2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsInNjcm9sbCIsIm9mZnNldHMiLCJvZmZzZXRSZWN0IiwiZ2V0V2luZG93U2Nyb2xsQmFyWCIsImdldERvY3VtZW50UmVjdCIsImh0bWwiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZ2V0UGFyZW50Tm9kZSIsInJlc3VsdCIsImFzc2lnbmVkU2xvdCIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IiLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsInNjcm9sbGFibGVBbmNlc3RvciIsImlzQm9keSIsImdldFZpZXdwb3J0UmVjdCIsInZpc3VhbFZpZXdwb3J0QmFzZWQiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvciIsImNsaXBwaW5nQW5jZXN0b3IiLCJtdXRhYmxlUmVjdCIsImdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyIsImNhY2hlIiwiY2FjaGVkUmVzdWx0IiwiZ2V0IiwiY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUiLCJlbGVtZW50SXNGaXhlZCIsInBvc2l0aW9uIiwiY3VycmVudE5vZGUiLCJjb21wdXRlZFN0eWxlIiwiY29udGFpbmluZ0Jsb2NrIiwic2hvdWxkSWdub3JlQ3VycmVudE5vZGUiLCJzaG91bGREcm9wQ3VycmVudE5vZGUiLCJhbmNlc3RvciIsInNldCIsImVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyIsIl9jIiwiY2xpcHBpbmdBbmNlc3RvcnMiLCJmaXJzdENsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsInBvbHlmaWxsIiwiZ2V0Q29udGFpbmluZ0Jsb2NrIiwiZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQiLCJfdGhpczMiLCJfY2FsbGVlNSIsImdldE9mZnNldFBhcmVudEZuIiwiZ2V0RGltZW5zaW9uc0ZuIiwiX2NhbGxlZTUkIiwiX2NvbnRleHQ1IiwiZ2V0Q2xpZW50UmVjdHMiLCJmcm9tIiwiYXV0b1VwZGF0ZSIsInVwZGF0ZSIsIl9vcHRpb25zNCIsIl9vcHRpb25zNCRhbmNlc3RvclNjciIsImFuY2VzdG9yU2Nyb2xsIiwiX2FuY2VzdG9yU2Nyb2xsIiwiX29wdGlvbnM0JGFuY2VzdG9yUmVzIiwiYW5jZXN0b3JSZXNpemUiLCJfb3B0aW9uczQkZWxlbWVudFJlc2kiLCJlbGVtZW50UmVzaXplIiwiX29wdGlvbnM0JGFuaW1hdGlvbkZyIiwiYW5pbWF0aW9uRnJhbWUiLCJhbmNlc3RvcnMiLCJwYXNzaXZlIiwib2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJmcmFtZUlkIiwicHJldlJlZlJlY3QiLCJmcmFtZUxvb3AiLCJuZXh0UmVmUmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9vYnNlcnZlciIsImRpc2Nvbm5lY3QiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIk1hcCIsIm1lcmdlZE9wdGlvbnMiLCJwbGF0Zm9ybVdpdGhDYWNoZSIsInNldHVwVG9vbHRpcCIsImNsZWFudXAiLCJhdHRhY2hUb09wdGlvbnMiLCJfZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMiLCJmbG9hdGluZ1VJT3B0aW9ucyIsImdldEZsb2F0aW5nVUlPcHRpb25zIiwic2hvdWxkQ2VudGVyIiwiY29udGVudCIsInNoZXBoZXJkRWxlbWVudENvbXBvbmVudCIsImdldEVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJzZXRQb3NpdGlvbiIsIm1lcmdlVG9vbHRpcENvbmZpZyIsInRvdXJPcHRpb25zIiwiZGVzdHJveVRvb2x0aXAiLCJ0aGVuIiwiZmxvYXRpbmdVSXBvc2l0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZm9jdXMiLCJwcmV2ZW50U2Nyb2xsIiwic3R5bGUiLCJkYXRhc2V0IiwicG9wcGVyUGxhY2VtZW50IiwicGxhY2VBcnJvdyIsImFycm93RWwiLCJfbWlkZGxld2FyZURhdGEkYXJyb3ciLCJhcnJvd1giLCJhcnJvd1kiLCJhZGRBcnJvdyIsIm5vb3AiLCJ0YXIiLCJzcmMiLCJrIiwicnVuIiwiYmxhbmtfb2JqZWN0IiwiY3JlYXRlIiwicnVuX2FsbCIsImZucyIsImlzX2Z1bmN0aW9uIiwidGhpbmciLCJzYWZlX25vdF9lcXVhbCIsImlzX2VtcHR5Iiwib2JqIiwiYXBwZW5kIiwiYXBwZW5kQ2hpbGQiLCJpbnNlcnQiLCJhbmNob3IiLCJpbnNlcnRCZWZvcmUiLCJkZXRhY2giLCJyZW1vdmVDaGlsZCIsImRlc3Ryb3lfZWFjaCIsIml0ZXJhdGlvbnMiLCJkZXRhY2hpbmciLCJjcmVhdGVFbGVtZW50Iiwic3ZnX2VsZW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJ0ZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJzcGFjZSIsImVtcHR5IiwibGlzdGVuIiwiYXR0ciIsImF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInNldF9hdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsImRlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fcHJvdG9fXyIsImNzc1RleHQiLCJjaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJ0b2dnbGVfY2xhc3MiLCJ0b2dnbGUiLCJjdXJyZW50X2NvbXBvbmVudCIsInNldF9jdXJyZW50X2NvbXBvbmVudCIsImNvbXBvbmVudCIsImdldF9jdXJyZW50X2NvbXBvbmVudCIsIm9uTW91bnQiLCIkJCIsIm9uX21vdW50IiwiYWZ0ZXJVcGRhdGUiLCJhZnRlcl91cGRhdGUiLCJkaXJ0eV9jb21wb25lbnRzIiwiYmluZGluZ19jYWxsYmFja3MiLCJyZW5kZXJfY2FsbGJhY2tzIiwiZmx1c2hfY2FsbGJhY2tzIiwicmVzb2x2ZWRfcHJvbWlzZSIsInVwZGF0ZV9zY2hlZHVsZWQiLCJzY2hlZHVsZV91cGRhdGUiLCJmbHVzaCIsImFkZF9yZW5kZXJfY2FsbGJhY2siLCJzZWVuX2NhbGxiYWNrcyIsIlNldCIsImZsdXNoaWR4Iiwic2F2ZWRfY29tcG9uZW50IiwicG9wIiwiY2FsbGJhY2siLCJoYXMiLCJjbGVhciIsImZyYWdtZW50IiwiYmVmb3JlX3VwZGF0ZSIsImRpcnR5IiwicCIsImZsdXNoX3JlbmRlcl9jYWxsYmFja3MiLCJmaWx0ZXJlZCIsInRhcmdldHMiLCJpbmRleE9mIiwib3V0cm9pbmciLCJvdXRyb3MiLCJncm91cF9vdXRyb3MiLCJjaGVja19vdXRyb3MiLCJ0cmFuc2l0aW9uX2luIiwiYmxvY2siLCJsb2NhbCIsImRlbGV0ZSIsInRyYW5zaXRpb25fb3V0IiwibyIsImdldF9zcHJlYWRfdXBkYXRlIiwibGV2ZWxzIiwidXBkYXRlcyIsInRvX251bGxfb3V0IiwiYWNjb3VudGVkX2ZvciIsIiQkc2NvcGUiLCJuIiwiY3JlYXRlX2NvbXBvbmVudCIsIm1vdW50X2NvbXBvbmVudCIsImN1c3RvbUVsZW1lbnQiLCJfY29tcG9uZW50JCQkIiwibSIsIm5ld19vbl9kZXN0cm95Iiwib25fZGVzdHJveSIsIl9jb21wb25lbnQkJCQkb25fZGVzdCIsImRlc3Ryb3lfY29tcG9uZW50IiwibWFrZV9kaXJ0eSIsImZpbGwiLCJpbml0IiwiaW5zdGFuY2UiLCJjcmVhdGVfZnJhZ21lbnQiLCJub3RfZXF1YWwiLCJwcm9wcyIsImFwcGVuZF9zdHlsZXMiLCJwYXJlbnRfY29tcG9uZW50IiwiYm91bmQiLCJvbl9kaXNjb25uZWN0IiwiY2FsbGJhY2tzIiwic2tpcF9ib3VuZCIsInJvb3QiLCJyZWFkeSIsInJldCIsImh5ZHJhdGUiLCJub2RlcyIsImwiLCJpbnRybyIsIlN2ZWx0ZUNvbXBvbmVudCIsIiRkZXN0cm95IiwiJG9uIiwidHlwZSIsIiRzZXQiLCIkJHByb3BzIiwiJCRzZXQiLCJidXR0b24iLCJidXR0b25fY2xhc3NfdmFsdWUiLCJhY3Rpb24iLCJjbGFzc2VzIiwiZGlzYWJsZWQiLCJsYWJlbCIsInNlY29uZGFyeSIsImdldENvbmZpZ09wdGlvbiIsIm9wdGlvbiIsIiQkaW52YWxpZGF0ZSIsImVhY2hfYmxvY2tzIiwiY3JlYXRlX2lmX2Jsb2NrJDMiLCJmb290ZXIiLCJidXR0b25zIiwiYnV0dG9uX2FyaWFfbGFiZWxfdmFsdWUiLCJzcGFuIiwiY2FuY2VsSWNvbiIsImhhbmRsZUNhbmNlbENsaWNrIiwicHJldmVudERlZmF1bHQiLCJjYW5jZWwiLCJoMyIsImxhYmVsSWQiLCJ0aXRsZSIsImlubmVySFRNTCIsIiQkdmFsdWUiLCJjcmVhdGVfaWZfYmxvY2tfMSQxIiwiZW5hYmxlZCIsImNyZWF0ZV9pZl9ibG9jayQyIiwiaGVhZGVyIiwiZGl2IiwiZGVzY3JpcHRpb25JZCIsInNob3dfaWZfMiIsInNob3dfaWZfMSIsInNob3dfaWYiLCJjcmVhdGVfaWZfYmxvY2siLCJkaXZfYXJpYV9kZXNjcmliZWRieV92YWx1ZSIsImN1cnJlbnQiLCJLRVlfVEFCIiwiS0VZX0VTQyIsIkxFRlRfQVJST1ciLCJSSUdIVF9BUlJPVyIsImdldENsYXNzZXNBcnJheSIsImNsYXNzTmFtZSIsImNsYXNzUHJlZml4IiwiZmlyc3RGb2N1c2FibGVFbGVtZW50IiwiZm9jdXNhYmxlRWxlbWVudHMiLCJsYXN0Rm9jdXNhYmxlRWxlbWVudCIsImRhdGFTdGVwSWQiLCJoYXNDYW5jZWxJY29uIiwiaGFzVGl0bGUiLCJpZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ1cGRhdGVEeW5hbWljQ2xhc3NlcyIsInJlbW92ZUNsYXNzZXMiLCJhZGRDbGFzc2VzIiwib2xkQ2xhc3NlcyIsIl9lbGVtZW50JGNsYXNzTGlzdCIsInJlbW92ZSIsIm5ld0NsYXNzZXMiLCJfZWxlbWVudCRjbGFzc0xpc3QyIiwiaGFuZGxlS2V5RG93biIsIl9zdGVwIiwia2V5Q29kZSIsInNoaWZ0S2V5IiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwiZXhpdE9uRXNjIiwia2V5Ym9hcmROYXZpZ2F0aW9uIiwiYmFjayIsIlN0ZXAiLCJfRXZlbnRlZCIsIl9pbmhlcml0cyIsIl9zdXBlcjkiLCJfY3JlYXRlU3VwZXIiLCJfdGhpczEyIiwic3R5bGVzIiwiX3Jlc29sdmVkQXR0YWNoVG8iLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX3NldE9wdGlvbnMiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNvbXBsZXRlIiwiZGVzdHJveSIsIl91cGRhdGVTdGVwVGFyZ2V0T25IaWRlIiwiZ2V0VG91ciIsImhpZGUiLCJtb2RhbCIsImhpZGRlbiIsIl9yZXNvbHZlQXR0YWNoVG9PcHRpb25zIiwic2hvdyIsIl90aGlzMTMiLCJiZWZvcmVTaG93UHJvbWlzZSIsIl9zaG93IiwidXBkYXRlU3RlcE9wdGlvbnMiLCJnZXRUYXJnZXQiLCJfY3JlYXRlVG9vbHRpcENvbnRlbnQiLCJTaGVwaGVyZF9lbGVtZW50Iiwic3RlcHNDb250YWluZXIiLCJfc2Nyb2xsVG8iLCJzY3JvbGxUb09wdGlvbnMiLCJfdGhpcyRfZ2V0UmVzb2x2ZWRBdHQiLCJzY3JvbGxUb0hhbmRsZXIiLCJzY3JvbGxJbnRvVmlldyIsIl9nZXRDbGFzc09wdGlvbnMiLCJzdGVwT3B0aW9ucyIsImRlZmF1bHRTdGVwT3B0aW9ucyIsInN0ZXBDbGFzc2VzIiwiZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3NlcyIsImFsbENsYXNzZXMiLCJ1bmlxQ2xhc3NlcyIsInRyaW0iLCJfdGhpczE0Iiwid2hlbiIsIl9zZXR1cEVsZW1lbnRzIiwiX3RoaXMxNSIsIl9zZXR1cE1vZGFsIiwic2V0dXBGb3JTdGVwIiwiX3N0eWxlVGFyZ2V0RWxlbWVudEZvclN0ZXAiLCJzY3JvbGxUbyIsInRhcmdldEVsZW1lbnQiLCJoaWdobGlnaHRDbGFzcyIsImNhbkNsaWNrVGFyZ2V0IiwiY2xlYW51cFN0ZXBzIiwic3RlcHMiLCJtYWtlT3ZlcmxheVBhdGgiLCJfcmVmJHgiLCJfcmVmJHkiLCJfcmVmJHIiLCJfd2luZG93IiwidyIsImlubmVyV2lkdGgiLCJoIiwiaW5uZXJIZWlnaHQiLCJfcmVmMTUiLCJ0b3BMZWZ0IiwidG9wUmlnaHQiLCJib3R0b21SaWdodCIsImJvdHRvbUxlZnQiLCJfcmVmMTUkdG9wTGVmdCIsIl9yZWYxNSR0b3BSaWdodCIsIl9yZWYxNSRib3R0b21SaWdodCIsIl9yZWYxNSRib3R0b21MZWZ0Iiwic3ZnIiwicGF0aCIsIl9nZXRTY3JvbGxQYXJlbnQiLCJpc0h0bWxFbGVtZW50IiwiaXNTY3JvbGxhYmxlIiwicGFyZW50RWxlbWVudCIsIl9nZXRWaXNpYmxlSGVpZ2h0Iiwic2Nyb2xsUGFyZW50IiwiZWxlbWVudFJlY3QiLCJzY3JvbGxSZWN0Iiwic2Nyb2xsQm90dG9tIiwib3BlbmluZ1Byb3BlcnRpZXMiLCJtb2RhbElzVmlzaWJsZSIsInJhZklkIiwicGF0aERlZmluaXRpb24iLCJjbG9zZU1vZGFsT3BlbmluZyIsIl9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzIiwicG9zaXRpb25Nb2RhbCIsIm1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nIiwibW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyIsIl9nZXRWaXNpYmxlSGVpZ2h0MiIsIl90YXJnZXRFbGVtZW50JGdldEJvdSIsInVzZU1vZGFsT3ZlcmxheSIsIl9zdHlsZUZvclN0ZXAiLCJfcHJldmVudE1vZGFsQm9keVRvdWNoIiwiX3ByZXZlbnRNb2RhbE92ZXJsYXlUb3VjaCIsInN0b3BQcm9wYWdhdGlvbiIsIl9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMiLCJfc3RlcCRvcHRpb25zIiwicmFmTG9vcCIsIlNoZXBoZXJkIiwiVG91ciIsIl9FdmVudGVkMiIsIl9zdXBlcjExIiwiX3RoaXMxNyIsImRlZmF1bHRUb3VyT3B0aW9ucyIsImFkZFN0ZXBzIiwiZXZlbnRzIiwib3B0cyIsIl9zZXRUb3VySUQiLCJhZGRTdGVwIiwiX3RoaXMxOCIsImN1cnJlbnRTdGVwIiwiX2NhbmNlbCIsIl9jYWxsZWU2IiwiY29uZmlybUNhbmNlbElzRnVuY3Rpb24iLCJjYW5jZWxNZXNzYWdlIiwic3RvcFRvdXIiLCJfY2FsbGVlNiQiLCJfY29udGV4dDYiLCJjb25maXJtQ2FuY2VsIiwiY29uZmlybUNhbmNlbE1lc3NhZ2UiLCJjb25maXJtIiwiX2RvbmUiLCJnZXRCeUlkIiwiZmluZCIsImdldEN1cnJlbnRTdGVwIiwiaXNBY3RpdmUiLCJhY3RpdmVUb3VyIiwicmVtb3ZlU3RlcCIsIl90aGlzMTkiLCJmb3J3YXJkIiwiX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdyIsInNob3VsZFNraXBTdGVwIiwic2hvd09uIiwiX3NraXBTdGVwIiwicHJldmlvdXMiLCJmb2N1c2VkRWxCZWZvcmVPcGVuIiwiX3NldHVwQWN0aXZlVG91ciIsIm1vZGFsQ29udGFpbmVyIiwiU2hlcGhlcmRfbW9kYWwiLCJ0b3VyTmFtZSIsImlzU2VydmVyU2lkZSIsIk5vT3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/shepherd.js/dist/js/shepherd.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/shepherd/shepherd.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});